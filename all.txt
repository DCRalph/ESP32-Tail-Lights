==== AppStuff/ApplicationWireless.cpp: ====
#include "Application.h"
#include "IO/Wireless.h"
#include "IO/LED/Effects.h"
#include "IO/LED/LEDStripManager.h"
#include "Sync/SyncManager.h"
#include "IO/TimeProfiler.h"

// Command constants
constexpr uint8_t CMD_PING = 0xe0;
constexpr uint8_t CMD_SET_MODE = 0xe1;
constexpr uint8_t CMD_SET_EFFECTS = 0xe2;
constexpr uint8_t CMD_GET_EFFECTS = 0xe3;
constexpr uint8_t CAR_CMD_SET_INPUTS = 0xe4;
constexpr uint8_t CAR_CMD_GET_INPUTS = 0xe5;
constexpr uint8_t CAR_CMD_TRIGGER_SEQUENCE = 0xe6;
constexpr uint8_t CAR_CMD_GET_STATS = 0xe7;

// Sync management commands
constexpr uint8_t CMD_SYNC_GET_DEVICES = 0xe8;
constexpr uint8_t CMD_SYNC_GET_GROUPS = 0xe9;
constexpr uint8_t CMD_SYNC_GET_GROUP_INFO = 0xea;
constexpr uint8_t CMD_SYNC_JOIN_GROUP = 0xeb;
constexpr uint8_t CMD_SYNC_LEAVE_GROUP = 0xec;
constexpr uint8_t CMD_SYNC_CREATE_GROUP = 0xed;
constexpr uint8_t CMD_SYNC_GET_STATUS = 0xee;
constexpr uint8_t CMD_SYNC_SET_MODE = 0xef;
constexpr uint8_t CMD_SYNC_GET_MODE = 0xf0;

// Struct definitions for wireless communication
struct PingCmd
{
  ApplicationMode mode;
  bool headlight;
  bool taillight;
  bool underglow;
  bool interior;
};

struct SetModeCmd
{
  ApplicationMode mode;
};

struct EffectsCmd
{
  bool leftIndicator;
  bool rightIndicator;

  int headlightMode;
  bool headlightSplit;
  bool headlightR;
  bool headlightG;
  bool headlightB;

  int taillightMode;
  bool taillightSplit;

  bool brake;
  bool reverse;

  bool rgb;
  bool nightrider;
  bool police;
  PoliceMode policeMode;
  bool testEffect1;
  bool testEffect2;
  bool solidColor;
  SolidColorPreset solidColorPreset;
  uint8_t solidColorR;
  uint8_t solidColorG;
  uint8_t solidColorB;
  bool colorFade;
};

struct InputsCmd
{
  bool accOn;
  bool indicatorLeft;
  bool indicatorRight;
  bool headlight;
  bool brake;
  bool reverse;
};

struct TriggerSequenceCmd
{
  uint8_t sequence;
};

// Sync management structs
struct SyncDeviceInfo
{
  uint32_t deviceId;
  uint8_t mac[6];
  uint32_t lastSeen;
  uint32_t timeSinceLastSeen;
  bool inCurrentGroup;
  bool isGroupMaster;
  bool isThisDevice;
};

struct SyncDevicesResponse
{
  uint8_t deviceCount;
  uint32_t currentTime;
  SyncDeviceInfo devices[8];
};

struct SyncGroupInfo
{
  uint32_t groupId;
  uint32_t masterDeviceId;
  uint8_t masterMac[6];
  uint32_t lastSeen;
  uint32_t timeSinceLastSeen;
  bool isCurrentGroup;
  bool canJoin;
};

struct SyncGroupsResponse
{
  uint8_t groupCount;
  uint32_t currentTime;
  uint32_t ourGroupId;
  SyncGroupInfo groups[4];
};

struct SyncGroupMemberInfo
{
  uint32_t deviceId;
  uint8_t mac[6];
  bool isGroupMaster;
  bool isThisDevice;
  uint32_t lastHeartbeat;
};

struct SyncCurrentGroupInfo
{
  uint32_t groupId;
  uint32_t masterDeviceId;
  bool isMaster;
  bool timeSynced;
  int32_t timeOffset;
  uint32_t syncedTime;
  uint8_t memberCount;
  uint32_t currentTime;
  SyncGroupMemberInfo members[6];
};

struct SyncJoinGroupCmd
{
  uint32_t groupId;
};

struct SyncCreateGroupCmd
{
  uint32_t groupId;
};

struct SyncDetailedStatus
{
  uint32_t deviceId;
  uint32_t groupId;
  uint32_t masterDeviceId;
  bool isMaster;
  bool timeSynced;
  int32_t timeOffset;
  uint32_t syncedTime;
  uint8_t memberCount;
  uint8_t discoveredDeviceCount;
  uint8_t discoveredGroupCount;
  int syncMode; // 0=SOLO, 1=JOIN, 2=HOST
};

struct SyncModeCmd
{
  uint8_t mode; // 0=SOLO, 1=JOIN, 2=HOST
};

// Setup wireless communication handlers
void Application::setupWireless()
{
  // Ping command (0xe0) - send current mode and enabled strips
  wireless.addOnReceiveFor(CMD_PING, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             LEDStripManager *ledManager = LEDStripManager::getInstance();

                             data_packet pTX = {0};
                             pTX.type = CMD_PING;

                             PingCmd pCmd;
                             pCmd.mode = mode;
                             pCmd.headlight = ledManager->isStripEnabled(LEDStripType::HEADLIGHT);
                             pCmd.taillight = ledManager->isStripEnabled(LEDStripType::TAILLIGHT);
                             pCmd.underglow = ledManager->isStripEnabled(LEDStripType::UNDERGLOW);
                             pCmd.interior = ledManager->isStripEnabled(LEDStripType::INTERIOR);

                             pTX.len = sizeof(pCmd);
                             memcpy(pTX.data, &pCmd, sizeof(pCmd));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Set mode command (0xe1)
  wireless.addOnReceiveFor(CMD_SET_MODE, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             uint8_t *data = fp->p.data;
                             uint8_t rxMode = data[0];

                             switch (rxMode)
                             {
                             case 0:
                               enableNormalMode();
                               break;
                             case 1:
                               enableTestMode();
                               break;
                             case 2:
                               enableRemoteMode();
                               break;
                             case 3:
                               enableOffMode();
                               break;
                             default:
                               break;
                             }

                             data_packet pTX = {0};
                             pTX.type = CMD_SET_MODE;
                             pTX.len = 1;

                             // Send current mode as uint8_t
                             switch (mode)
                             {
                             case ApplicationMode::NORMAL:
                               pTX.data[0] = 0;
                               break;
                             case ApplicationMode::TEST:
                               pTX.data[0] = 1;
                               break;
                             case ApplicationMode::REMOTE:
                               pTX.data[0] = 2;
                               break;
                             case ApplicationMode::OFF:
                               pTX.data[0] = 3;
                               break;
                             default:
                               pTX.data[0] = 0;
                               break;
                             }

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Get effects command (0xe3) - Returns current effects for each strip
  wireless.addOnReceiveFor(CMD_GET_EFFECTS, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             LEDStripManager *ledManager = LEDStripManager::getInstance();

                             data_packet pTX = {0};
                             pTX.type = CMD_GET_EFFECTS;

                             EffectsCmd eCmd = {0};

                             eCmd.leftIndicator = leftIndicatorEffect->isActive();
                             eCmd.rightIndicator = rightIndicatorEffect->isActive();

                             eCmd.headlightMode = headlightEffect ? static_cast<int>(headlightEffect->getMode()) : 0;
                             eCmd.headlightSplit = headlightEffect->getSplit();
                             headlightEffect->getColor(eCmd.headlightR, eCmd.headlightG, eCmd.headlightB);

                             // Use new TaillightEffect
                             eCmd.taillightMode = taillightEffect ? static_cast<int>(taillightEffect->getMode()) : 0;
                             eCmd.taillightSplit = taillightEffect->getSplit();
                             // Keep separate brake and reverse effects
                             eCmd.brake = brakeEffect->isActive();
                             eCmd.reverse = reverseLightEffect->isActive();

                             eCmd.rgb = rgbEffect->isActive();
                             eCmd.nightrider = nightriderEffect->isActive();
                             eCmd.police = policeEffect->isActive();
                             eCmd.policeMode = policeEffect->getMode();
                             eCmd.testEffect1 = pulseWaveEffect->isActive();
                             eCmd.testEffect2 = auroraEffect->isActive();
                             eCmd.solidColor = solidColorEffect->isActive();
                             eCmd.solidColorPreset = solidColorEffect->getColorPreset();
                             solidColorEffect->getCustomColor(eCmd.solidColorR, eCmd.solidColorG, eCmd.solidColorB);
                             eCmd.colorFade = colorFadeEffect->isActive();

                             pTX.len = sizeof(eCmd);
                             memcpy(pTX.data, &eCmd, sizeof(eCmd));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Set effects command (0xe2) - Set effects for each strip
  wireless.addOnReceiveFor(CMD_SET_EFFECTS, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             LEDStripManager *ledManager = LEDStripManager::getInstance();

                             EffectsCmd eCmd = {0};
                             memcpy(&eCmd, fp->p.data, sizeof(eCmd));

                             leftIndicatorEffect->setActive(eCmd.leftIndicator);
                             rightIndicatorEffect->setActive(eCmd.rightIndicator);

                             headlightEffect->setMode(eCmd.headlightMode);
                             headlightEffect->setSplit(eCmd.headlightSplit);
                             headlightEffect->setColor(eCmd.headlightR, eCmd.headlightG, eCmd.headlightB);

                             taillightEffect->setMode(eCmd.taillightMode);
                             taillightEffect->setSplit(eCmd.taillightSplit);

                             // Keep separate brake and reverse effects
                             brakeEffect->setActive(eCmd.brake);
                             brakeEffect->setIsReversing(eCmd.reverse);
                             reverseLightEffect->setActive(eCmd.reverse);

                             rgbEffect->setActive(eCmd.rgb);
                             nightriderEffect->setActive(eCmd.nightrider);
                             policeEffect->setActive(eCmd.police);
                             policeEffect->setMode(eCmd.policeMode);
                             pulseWaveEffect->setActive(eCmd.testEffect1);
                             auroraEffect->setActive(eCmd.testEffect2);
                             solidColorEffect->setActive(eCmd.solidColor);
                             solidColorEffect->setColorPreset(eCmd.solidColorPreset);
                             solidColorEffect->setCustomColor(eCmd.solidColorR, eCmd.solidColorG, eCmd.solidColorB);
                             colorFadeEffect->setActive(eCmd.colorFade);

                             SyncManager *syncMgr = SyncManager::getInstance();

                             if (syncMgr->isGroupMaster() && syncMgr->isEffectSyncEnabled())
                             {
                               EffectSyncState effectState = {};

                               effectState.rgbSyncData = rgbEffect->getSyncData();
                               effectState.nightRiderSyncData = nightriderEffect->getSyncData();
                               effectState.policeSyncData = policeEffect->getSyncData();
                               effectState.solidColorSyncData = solidColorEffect->getSyncData();
                               effectState.colorFadeSyncData = colorFadeEffect->getSyncData();

                               syncMgr->setEffectSyncState(effectState);
                               syncMgr->sendEffectState();
                             }

                             //
                           });

  wireless.addOnReceiveFor(CAR_CMD_SET_INPUTS, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             InputsCmd iCmd = {0};
                             memcpy(&iCmd, fp->p.data, sizeof(iCmd));

                             if (mode != ApplicationMode::TEST)
                               return;

                             accOnInput.override(iCmd.accOn);
                             leftIndicatorInput.override(iCmd.indicatorLeft);
                             rightIndicatorInput.override(iCmd.indicatorRight);
                             headlightInput.override(iCmd.headlight);
                             brakeInput.override(iCmd.brake);
                             reverseInput.override(iCmd.reverse);

                             //
                           });

  wireless.addOnReceiveFor(CAR_CMD_GET_INPUTS, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             InputsCmd iCmd = {0};
                             iCmd.accOn = accOnInput.get();
                             iCmd.indicatorLeft = leftIndicatorInput.get();
                             iCmd.indicatorRight = rightIndicatorInput.get();
                             iCmd.headlight = headlightInput.get();
                             iCmd.brake = brakeInput.get();
                             iCmd.reverse = reverseInput.get();

                             data_packet pTX = {0};
                             pTX.type = CAR_CMD_GET_INPUTS;
                             pTX.len = sizeof(iCmd);
                             memcpy(pTX.data, &iCmd, sizeof(iCmd));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  wireless.addOnReceiveFor(CAR_CMD_TRIGGER_SEQUENCE, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             TriggerSequenceCmd tCmd = {0};
                             memcpy(&tCmd, fp->p.data, sizeof(tCmd));

                             switch (tCmd.sequence)
                             {
                             case 0:
                               if (unlockSequence)
                                 unlockSequence->trigger();
                               break;
                             case 1:
                               if (lockSequence)
                                 lockSequence->trigger();
                               break;
                             case 2:
                               if (RGBFlickSequence)
                                 RGBFlickSequence->trigger();
                               break;
                             case 3:
                               if (nightRiderFlickSequence)
                                 nightRiderFlickSequence->trigger();
                               break;
                             }
                             //
                           });

  wireless.addOnReceiveFor(CAR_CMD_GET_STATS, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             data_packet pTX = {0};
                             pTX.type = CAR_CMD_GET_STATS;

                             AppStats stats = {0};
                             stats.updateInputTime = timeProfiler.getTimeUs("updateInputs");
                             stats.updateModeTime = timeProfiler.getTimeUs("updateMode");
                             stats.updateSyncTime = timeProfiler.getTimeUs("updateSync");
                             stats.updateEffectsTime = timeProfiler.getTimeUs("updateEffects");
                             stats.drawTime = timeProfiler.getTimeUs("drawEffects");

                             pTX.len = sizeof(AppStats);
                             memcpy(pTX.data, &stats, sizeof(AppStats));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Sync management commands

  // Get discovered devices (0xe8)
  wireless.addOnReceiveFor(CMD_SYNC_GET_DEVICES, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             SyncManager *syncMgr = SyncManager::getInstance();
                             const auto &discoveredDevices = syncMgr->getDiscoveredDevices();
                             const auto &groupInfo = syncMgr->getGroupInfo();
                             uint32_t ourDeviceId = syncMgr->getDeviceId();
                             uint32_t now = millis();

                             data_packet pTX = {0};
                             pTX.type = CMD_SYNC_GET_DEVICES;

                             SyncDevicesResponse response = {0};
                             response.deviceCount = std::min((size_t)8, discoveredDevices.size());
                             response.currentTime = now;

                             int i = 0;
                             for (const auto &devicePair : discoveredDevices)
                             {
                               if (i >= 8)
                                 break;
                               const auto &device = devicePair.second;

                               response.devices[i].deviceId = device.deviceId;
                               memcpy(response.devices[i].mac, device.mac, 6);
                               response.devices[i].lastSeen = device.lastSeen;
                               response.devices[i].timeSinceLastSeen = now - device.lastSeen;
                               response.devices[i].isThisDevice = (device.deviceId == ourDeviceId);

                               // Check if device is in our current group
                               response.devices[i].inCurrentGroup = false;
                               response.devices[i].isGroupMaster = false;

                               if (groupInfo.groupId != 0)
                               {
                                 auto memberIt = groupInfo.members.find(devicePair.first);
                                 if (memberIt != groupInfo.members.end())
                                 {
                                   response.devices[i].inCurrentGroup = true;
                                   response.devices[i].isGroupMaster = (device.deviceId == groupInfo.masterDeviceId);
                                 }
                               }

                               i++;
                             }

                             pTX.len = sizeof(response);
                             memcpy(pTX.data, &response, sizeof(response));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Get discovered groups (0xe9)
  wireless.addOnReceiveFor(CMD_SYNC_GET_GROUPS, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             SyncManager *syncMgr = SyncManager::getInstance();
                             const auto discoveredGroups = syncMgr->getDiscoveredGroups();
                             const auto &groupInfo = syncMgr->getGroupInfo();
                             uint32_t ourGroupId = groupInfo.groupId;
                             uint32_t now = millis();

                             data_packet pTX = {0};
                             pTX.type = CMD_SYNC_GET_GROUPS;

                             SyncGroupsResponse response = {0};
                             response.groupCount = std::min((size_t)4, discoveredGroups.size());
                             response.currentTime = now;
                             response.ourGroupId = ourGroupId;

                             for (int i = 0; i < response.groupCount; i++)
                             {
                               const auto &group = discoveredGroups[i];
                               response.groups[i].groupId = group.groupId;
                               response.groups[i].masterDeviceId = group.masterDeviceId;
                               memcpy(response.groups[i].masterMac, group.masterMac, 6);
                               response.groups[i].lastSeen = group.lastSeen;
                               response.groups[i].timeSinceLastSeen = now - group.lastSeen;
                               response.groups[i].isCurrentGroup = (group.groupId == ourGroupId);
                               response.groups[i].canJoin = (ourGroupId == 0 || group.groupId != ourGroupId);
                             }

                             pTX.len = sizeof(response);
                             memcpy(pTX.data, &response, sizeof(response));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Get current group info (0xea)
  wireless.addOnReceiveFor(CMD_SYNC_GET_GROUP_INFO, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             SyncManager *syncMgr = SyncManager::getInstance();
                             const auto &groupInfo = syncMgr->getGroupInfo();
                             const auto &discoveredDevices = syncMgr->getDiscoveredDevices();
                             uint32_t ourDeviceId = syncMgr->getDeviceId();
                             uint32_t now = millis();

                             data_packet pTX = {0};
                             pTX.type = CMD_SYNC_GET_GROUP_INFO;

                             SyncCurrentGroupInfo response = {0};
                             response.groupId = groupInfo.groupId;
                             response.masterDeviceId = groupInfo.masterDeviceId;
                             response.isMaster = groupInfo.isMaster;
                             response.timeSynced = syncMgr->isTimeSynced();
                             response.timeOffset = syncMgr->getTimeOffset();
                             response.syncedTime = syncMgr->getSyncedTime();
                             response.memberCount = std::min((size_t)6, groupInfo.members.size());
                             response.currentTime = now;

                             // Fill member details
                             int i = 0;
                             for (const auto &memberPair : groupInfo.members)
                             {
                               if (i >= 6)
                                 break;

                               const auto &member = memberPair.second;
                               response.members[i].deviceId = member.deviceId;
                               memcpy(response.members[i].mac, member.mac, 6);
                               response.members[i].isGroupMaster = (member.deviceId == groupInfo.masterDeviceId);
                               response.members[i].isThisDevice = (member.deviceId == ourDeviceId);

                               // Try to find heartbeat info from discovered devices
                               auto discoveredIt = discoveredDevices.find(memberPair.first);
                               if (discoveredIt != discoveredDevices.end())
                               {
                                 response.members[i].lastHeartbeat = now - discoveredIt->second.lastSeen;
                               }
                               else
                               {
                                 response.members[i].lastHeartbeat = 0; // Unknown
                               }

                               i++;
                             }

                             pTX.len = sizeof(response);
                             memcpy(pTX.data, &response, sizeof(response));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Join group (0xeb)
  wireless.addOnReceiveFor(CMD_SYNC_JOIN_GROUP, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             SyncJoinGroupCmd cmd = {0};
                             memcpy(&cmd, fp->p.data, sizeof(cmd));

                             SyncManager *syncMgr = SyncManager::getInstance();
                             syncMgr->joinGroup(cmd.groupId);

                             // Send back current group info as confirmation
                             const auto &groupInfo = syncMgr->getGroupInfo();

                             data_packet pTX = {0};
                             pTX.type = CMD_SYNC_JOIN_GROUP;
                             pTX.len = sizeof(uint32_t);
                             memcpy(pTX.data, &groupInfo.groupId, sizeof(uint32_t));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Leave group (0xec)
  wireless.addOnReceiveFor(CMD_SYNC_LEAVE_GROUP, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             SyncManager *syncMgr = SyncManager::getInstance();
                             syncMgr->leaveGroup();

                             // Send back confirmation (group ID should be 0 now)
                             data_packet pTX = {0};
                             pTX.type = CMD_SYNC_LEAVE_GROUP;
                             pTX.len = sizeof(uint32_t);
                             uint32_t groupId = 0;
                             memcpy(pTX.data, &groupId, sizeof(uint32_t));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Create group (0xed)
  wireless.addOnReceiveFor(CMD_SYNC_CREATE_GROUP, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             SyncCreateGroupCmd cmd = {0};
                             memcpy(&cmd, fp->p.data, sizeof(cmd));

                             SyncManager *syncMgr = SyncManager::getInstance();
                             syncMgr->createGroup(cmd.groupId); // 0 = auto-generate

                             // Send back created group info as confirmation
                             const auto &groupInfo = syncMgr->getGroupInfo();

                             data_packet pTX = {0};
                             pTX.type = CMD_SYNC_CREATE_GROUP;

                             SyncCurrentGroupInfo response = {0};
                             response.groupId = groupInfo.groupId;
                             response.masterDeviceId = groupInfo.masterDeviceId;
                             response.isMaster = groupInfo.isMaster;
                             response.timeSynced = syncMgr->isTimeSynced();
                             response.timeOffset = syncMgr->getTimeOffset();
                             response.memberCount = groupInfo.members.size();

                             pTX.len = sizeof(response);
                             memcpy(pTX.data, &response, sizeof(response));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Get comprehensive status (0xee)
  wireless.addOnReceiveFor(CMD_SYNC_GET_STATUS, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             SyncManager *syncMgr = SyncManager::getInstance();
                             const auto &groupInfo = syncMgr->getGroupInfo();
                             const auto &discoveredDevices = syncMgr->getDiscoveredDevices();
                             const auto discoveredGroups = syncMgr->getDiscoveredGroups();

                             data_packet pTX = {0};
                             pTX.type = CMD_SYNC_GET_STATUS;

                             SyncDetailedStatus response = {0};
                             response.deviceId = syncMgr->getDeviceId();
                             response.groupId = groupInfo.groupId;
                             response.masterDeviceId = groupInfo.masterDeviceId;
                             response.isMaster = groupInfo.isMaster;
                             response.timeSynced = syncMgr->isTimeSynced();
                             response.timeOffset = syncMgr->getTimeOffset();
                             response.syncedTime = syncMgr->getSyncedTime();
                             response.memberCount = groupInfo.members.size();
                             response.discoveredDeviceCount = std::min((size_t)255, discoveredDevices.size());
                             response.discoveredGroupCount = std::min((size_t)255, discoveredGroups.size());
                             response.syncMode = static_cast<int>(syncMgr->getSyncMode());

                             pTX.len = sizeof(response);
                             memcpy(pTX.data, &response, sizeof(response));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Set sync mode (0xef)
  wireless.addOnReceiveFor(CMD_SYNC_SET_MODE, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             SyncModeCmd cmd = {0};
                             memcpy(&cmd, fp->p.data, sizeof(cmd));

                             SyncManager *syncMgr = SyncManager::getInstance();
                             syncMgr->setSyncMode(static_cast<SyncMode>(cmd.mode));

                             // Send back confirmation
                             data_packet pTX = {0};
                             pTX.type = CMD_SYNC_SET_MODE;
                             pTX.len = sizeof(uint8_t);
                             uint8_t currentMode = static_cast<int>(syncMgr->getSyncMode());
                             memcpy(pTX.data, &currentMode, sizeof(currentMode));

                             wireless.send(&pTX, fp->mac);
                             //
                           });

  // Get sync mode (0xf0)
  wireless.addOnReceiveFor(CMD_SYNC_GET_MODE, [this](fullPacket *fp)
                           {
                             lastRemotePing = millis();

                             SyncManager *syncMgr = SyncManager::getInstance();

                             data_packet pTX = {0};
                             pTX.type = CMD_SYNC_GET_MODE;
                             pTX.len = sizeof(uint8_t);
                             uint8_t mode = static_cast<int>(syncMgr->getSyncMode());
                             memcpy(pTX.data, &mode, sizeof(mode));

                             wireless.send(&pTX, fp->mac);
                             //
                           });
}========
==== AppStuff/BtnLoop-new.cpp: ====
// /*
//  * LED MENU SYSTEM EXAMPLE - Complete Implementation Guide
//  * =======================================================
//  *
//  * This file demonstrates how to use the enhanced LEDMenu system with hierarchical
//  * sub-menus for ESP32 Tail Lights. The system now supports complex menu structures
//  * with multiple levels of navigation.
//  *
//  * HARDWARE REQUIREMENTS:
//  * ----------------------
//  * - 4 Buttons: BtnBoot, BtnPrev, BtnSel, BtnNext
//  * - 2 Status LEDs: statusLed1, statusLed2
//  *
//  * MENU NAVIGATION:
//  * ----------------
//  * 1. ENTERING MENU:
//  *    - Long press SELECT button (hold for ~1 second) to enter menu mode
//  *    - LEDs will change from dim green (idle) to menu indication mode
//  *
//  * 2. NAVIGATING MENU ITEMS:
//  *    - NEXT button: Move to next menu item
//  *    - PREV button: Move to previous menu item
//  *    - Each menu item has a unique LED pattern for identification
//  *
//  * 3. ENTERING SUB-MENUS:
//  *    - SELECT button on submenu items: Enter the submenu
//  *    - Sub-menus have their own set of items with unique patterns
//  *
//  * 4. EDITING VALUES:
//  *    - SELECT button on toggle/select items: Enter editing mode
//  *    - LEDs show alternating red/blue pattern during editing
//  *
//  * 5. MODIFYING VALUES (in editing mode):
//  *    - NEXT button: Increase/next value
//  *    - PREV button: Decrease/previous value
//  *    - SELECT button: Save changes and exit editing
//  *    - BOOT button: Cancel changes and exit editing
//  *
//  * 6. NAVIGATING BACK:
//  *    - BOOT button: Go back one level (submenu to parent, or exit main menu)
//  *    - "Back" menu items: Explicit back navigation
//  *
//  * 7. AUTO-EXIT:
//  *    - Menu exits automatically after 10 seconds of inactivity
//  *
//  * MENU STRUCTURE:
//  * ---------------
//  * Main Menu:
//  * ├── Sync Settings (submenu)
//  * │   ├── Create Group
//  * │   ├── Leave Group
//  * │   ├── Auto-Join (toggle)
//  * │   └── Back
//  * ├── LED Settings (submenu)
//  * │   ├── Brightness (0-255)
//  * │   ├── Speed (Slow/Medium/Fast/Turbo)
//  * │   ├── Mode (Normal/Pulse/Flash/Rainbow)
//  * │   └── Back
//  * ├── System Settings (submenu)
//  * │   ├── LED Enable (toggle)
//  * │   ├── Save Settings
//  * │   ├── Reset Defaults
//  * │   └── Back
//  * └── Exit
//  */

// #include "Application.h"
// #include "IO/StatusLed.h"
// #include "IO/LEDMenu.h"
// #include "Sync/SyncManager.h"

// // Settings variables
// static bool ledEnabled = true;
// static bool autoJoinEnabled = false;
// static int brightness = 128;
// static int speed = 2; // 0=Slow, 1=Medium, 2=Fast, 3=Turbo
// static int mode = 0;  // 0=Normal, 1=Pulse, 2=Flash, 3=Rainbow

// // Options for select menu items
// static std::vector<String> speedOptions = {"Slow", "Medium", "Fast", "Turbo"};
// static std::vector<String> modeOptions = {"Normal", "Pulse", "Flash", "Rainbow"};

// // Sub-menu containers
// static std::vector<LEDMenuItem> syncMenuItems;
// static std::vector<LEDMenuItem> ledMenuItems;
// static std::vector<LEDMenuItem> systemMenuItems;

// // Action functions
// void saveSettings()
// {
//   // In real implementation, save to preferences/EEPROM
//   ESP_LOGI("Settings", "Settings saved!");
//   statusLed1.blink(0x00FF00, 3, 3); // Green success
//   statusLed2.blink(0x00FF00, 3, 3);
// }

// void resetDefaults()
// {
//   ledEnabled = true;
//   autoJoinEnabled = false;
//   brightness = 128;
//   speed = 2;
//   mode = 0;
//   ESP_LOGI("Settings", "Reset to defaults!");
//   statusLed1.blink(0xFF8000, 5, 5); // Orange warning
//   statusLed2.blink(0xFF8000, 5, 5);
// }

// void Application::btnLoop()
// {
//   static bool menuInitialized = false;

//   if (!appInitialized)
//     return;

//   // Initialize the hierarchical LED menu system once
//   if (!menuInitialized)
//   {
//     menuInitialized = true;
//     auto *sync = SyncManager::getInstance();

//     // Build Sync Settings submenu
//     syncMenuItems.clear();

//     // Create Group - Green pulsing
//     syncMenuItems.push_back(LEDMenuItem::createAction(
//         "Create Group",
//         [sync]()
//         {
//           sync->createGroup();
//           statusLed1.blink(0x00FF00, 3, 3);
//           statusLed2.blink(0x00FF00, 3, 3);
//         },
//         LEDPattern::createPulse(0x00FF00, 0x00FF00, 1000, 128, 255)));

//     // Leave Group - Red pulsing
//     syncMenuItems.push_back(LEDMenuItem::createAction(
//         "Leave Group",
//         [sync]()
//         {
//           if (sync->isInGroup())
//           {
//             sync->leaveGroup();
//             statusLed1.blink(0xFF0000, 3, 3);
//             statusLed2.blink(0xFF0000, 3, 3);
//           }
//         },
//         LEDPattern::createPulse(0xFF0000, 0xFF0000, 1000, 128, 255)));

//     // Auto-Join Toggle - Purple/White alternating
//     syncMenuItems.push_back(LEDMenuItem::createToggle(
//         "Auto-Join",
//         &autoJoinEnabled,
//         LEDPattern::createAlternating(0x800080, 0xFFFFFF, 0x800080, 0xFFFFFF, 500),
//         LEDPattern::createAlternating(0xFF0000, 0x000000, 0x0000FF, 0x000000, 250)));

//     // Back item
//     syncMenuItems.push_back(LEDMenuItem::createBack());

//     // Build LED Settings submenu
//     ledMenuItems.clear();

//     // Brightness - Yellow pulse
//     ledMenuItems.push_back(LEDMenuItem::createSelect(
//         "Brightness",
//         &brightness,
//         0, 255, nullptr,
//         LEDPattern::createPulse(0xFFFF00, 0xFFFF00, 800, 100, 255),
//         LEDPattern::createAlternating(0xFF0000, 0x000000, 0x0000FF, 0x000000, 250)));

//     // Speed selection - Cyan alternating
//     ledMenuItems.push_back(LEDMenuItem::createSelect(
//         "Speed",
//         &speed,
//         0, 3, &speedOptions,
//         LEDPattern::createAlternating(0x00FFFF, 0x000000, 0x00FFFF, 0x000000, 600),
//         LEDPattern::createAlternating(0xFF0000, 0x000000, 0x0000FF, 0x000000, 250)));

//     // Mode selection - White flash
//     ledMenuItems.push_back(LEDMenuItem::createSelect(
//         "Mode",
//         reinterpret_cast<int *>(&mode),
//         0, 3, &modeOptions,
//         LEDPattern::createFlash(0xFFFFFF, 0xFFFFFF, 200, 800),
//         LEDPattern::createAlternating(0xFF0000, 0x000000, 0x0000FF, 0x000000, 250)));

//     // Back item
//     ledMenuItems.push_back(LEDMenuItem::createBack());

//     // Build System Settings submenu
//     systemMenuItems.clear();

//     // LED Enable toggle - Green/Red alternating
//     systemMenuItems.push_back(LEDMenuItem::createToggle(
//         "LED Enable",
//         &ledEnabled,
//         LEDPattern::createAlternating(0x00FF00, 0xFF0000, 0x00FF00, 0xFF0000, 750),
//         LEDPattern::createAlternating(0xFF0000, 0x000000, 0x0000FF, 0x000000, 250)));

//     // Save Settings - Blue pulse
//     systemMenuItems.push_back(LEDMenuItem::createAction(
//         "Save Settings",
//         saveSettings,
//         LEDPattern::createPulse(0x0000FF, 0x0000FF, 1200, 80, 255)));

//     // Reset Defaults - Orange flash
//     systemMenuItems.push_back(LEDMenuItem::createAction(
//         "Reset Defaults",
//         resetDefaults,
//         LEDPattern::createFlash(0xFF8000, 0xFF8000, 150, 850)));

//     // Back item
//     systemMenuItems.push_back(LEDMenuItem::createBack());

//     // Build main menu with submenus
//     ledMenu.clearMenuItems();

//     // Sync Settings submenu - Green pulse
//     ledMenu.addMenuItem(LEDMenuItem::createSubMenu(
//         "Sync Settings",
//         &syncMenuItems,
//         LEDPattern::createPulse(0x00FF00, 0x008000, 1500, 100, 255)));

//     // LED Settings submenu - Yellow pulse
//     ledMenu.addMenuItem(LEDMenuItem::createSubMenu(
//         "LED Settings",
//         &ledMenuItems,
//         LEDPattern::createPulse(0xFFFF00, 0x808000, 1500, 100, 255)));

//     // System Settings submenu - Blue pulse
//     ledMenu.addMenuItem(LEDMenuItem::createSubMenu(
//         "System Settings",
//         &systemMenuItems,
//         LEDPattern::createPulse(0x0000FF, 0x000080, 1500, 100, 255)));

//     // Exit - Orange flash
//     ledMenu.addMenuItem(LEDMenuItem::createAction(
//         "Exit",
//         []()
//         { ledMenu.exit(); },
//         LEDPattern::createFlash(0xFFA500, 0xFFA500, 300, 1700)));

//     // Enable the LED menu
//     ledMenu.setEnabled(true);
//     ledMenu.begin();
//   }

//   // Handle button events and clear click counts after processing
//   auto handleButton = [](auto &btn, ButtonType type)
//   {
//     if (btn.clicks == 1)
//     {
//       ledMenu.handleButtonEvent(ButtonEvent{type, ButtonEventType::SINGLE_CLICK});
//       btn.clicks = 0;
//     }
//     else if (btn.clicks == 2)
//     {
//       ledMenu.handleButtonEvent(ButtonEvent{type, ButtonEventType::DOUBLE_CLICK});
//       btn.clicks = 0;
//     }
//     else if (btn.clicks == 3)
//     {
//       ledMenu.handleButtonEvent(ButtonEvent{type, ButtonEventType::TRIPLE_CLICK});
//       btn.clicks = 0;
//     }
//     else if (btn.clicks == -1)
//     {
//       ledMenu.handleButtonEvent(ButtonEvent{type, ButtonEventType::LONG_CLICK});
//       btn.clicks = 0;
//     }
//     else if (btn.clicks == -2)
//     {
//       ledMenu.handleButtonEvent(ButtonEvent{type, ButtonEventType::DOUBLE_LONG_CLICK});
//       btn.clicks = 0;
//     }
//     else if (btn.clicks == -3)
//     {
//       ledMenu.handleButtonEvent(ButtonEvent{type, ButtonEventType::TRIPLE_LONG_CLICK});
//       btn.clicks = 0;
//     }
//   };

//   // Process all button events
//   handleButton(BtnBoot, ButtonType::BOOT);
//   handleButton(BtnPrev, ButtonType::PREV);
//   handleButton(BtnSel, ButtonType::SELECT);
//   handleButton(BtnNext, ButtonType::NEXT);

//   // Update the menu system
//   ledMenu.update();
// }========
==== AppStuff/BtnLoop-old.cpp: ====
#include "Application.h"
#include "IO/StatusLed.h"
#include "Sync/SyncManager.h"

void Application::btnLoop()
{
  if (!appInitialized)
    return;

  if (BtnBoot.clicks == 1)
  {
    // cycle through modes
    mode = static_cast<ApplicationMode>((static_cast<int>(mode) + 1) % NUM_MODES);
    preferences.putUInt("mode", static_cast<int>(mode));
  }

  if (BtnPrev.clicks == 1)
  {
    // cycle through modes
    SyncManager::getInstance()->setSyncMode(static_cast<SyncMode>((static_cast<int>(SyncManager::getInstance()->getSyncMode()) + 1) % 3));
  }

  switch (mode)
  {
  case ApplicationMode::NORMAL:
    statusLed1.setColor(0, 255, 0);
    // statusLeds.show();
    break;
  case ApplicationMode::TEST:
    statusLed1.setColor(255, 0, 255);
    // statusLeds.show();
    break;
  case ApplicationMode::REMOTE:
    statusLed1.setColor(0, 0, 255);
    // statusLeds.show();
    break;
  case ApplicationMode::OFF:
    statusLed1.setColor(255, 0, 0);
    // statusLeds.show();
    break;
  }

  SyncManager::getInstance()->updateSyncedLED();
}
========
==== AppStuff/BtnLoop.cpp: ====
// #include "Application.h"
// #include "IO/StatusLed.h"
// #include "Sync/SyncManager.h"

// // Constants for menu timing
// #define GROUP_INFO_DISPLAY_TIME 3000 // 3 seconds
// #define DOUBLE_CLICK_TIME 500        // 500ms for double click detection
// #define SYNC_UPDATE_INTERVAL 50      // 50ms for smooth sync LED updates
// #define GROUP_ID_MAX_DIGITS 8        // Maximum digits for group ID input

// void Application::btnLoop()
// {
//   if (!appInitialized)
//     return;

//   // Handle menu navigation first
//   handleMenuNavigation();

//   // Update synced LED timing based on current state
//   updateSyncedLEDTiming();

//   // Display appropriate LED status based on current menu state
//   switch (menuContext.currentState)
//   {
//   case MenuState::NORMAL_MODE:
//     displayNormalMode();
//     break;
//   case MenuState::GROUP_INFO:
//     displayGroupInfo();
//     break;
//   case MenuState::GROUP_MENU:
//     displayGroupMenu();
//     break;
//   }
// }

// void Application::handleMenuNavigation()
// {
//   uint32_t currentTime = millis();

//   // Handle Boot button for menu state transitions
//   if (BtnBoot.clicks == 2)
//   {
//     // Double click: Toggle between normal mode and group info
//     if (menuContext.currentState == MenuState::NORMAL_MODE)
//     {
//       menuContext.currentState = MenuState::GROUP_INFO;
//       menuContext.groupInfoDisplayStart = currentTime;
//     }
//     else if (menuContext.currentState == MenuState::GROUP_INFO)
//     {
//       menuContext.currentState = MenuState::GROUP_MENU;
//       menuContext.inGroupMenu = true;
//     }
//     else if (menuContext.currentState == MenuState::GROUP_MENU)
//     {
//       menuContext.currentState = MenuState::NORMAL_MODE;
//       menuContext.inGroupMenu = false;
//       menuContext.editingGroupId = false;
//     }
//     BtnBoot.clicks = 0;
//   }
//   else if (BtnBoot.clicks == 1)
//   {
//     // Single click: Mode cycling in normal mode, menu actions in group menu
//     if (menuContext.currentState == MenuState::NORMAL_MODE)
//     {
//       // Cycle through application modes
//       mode = static_cast<ApplicationMode>((static_cast<uint8_t>(mode) + 1) % NUM_MODES);
//       preferences.putUInt("mode", static_cast<uint8_t>(mode));
//     }
//     else if (menuContext.currentState == MenuState::GROUP_MENU)
//     {
//       executeGroupMenuAction();
//     }
//     BtnBoot.clicks = 0;
//   }

//   // Handle navigation buttons in group menu
//   if (menuContext.currentState == MenuState::GROUP_MENU)
//   {
//     if (BtnNext.clicks == 1)
//     {
//       if (menuContext.editingGroupId)
//       {
//         // Navigate through group ID digits
//         if (menuContext.groupIdDigitIndex < GROUP_ID_MAX_DIGITS - 1)
//           menuContext.groupIdDigitIndex++;
//       }
//       else
//       {
//         // Navigate through menu options
//         int optionCount = static_cast<int>(GroupMenuOption::BACK_TO_NORMAL) + 1;
//         menuContext.selectedOption = static_cast<GroupMenuOption>(
//             (static_cast<int>(menuContext.selectedOption) + 1) % optionCount);
//       }
//       BtnNext.clicks = 0;
//     }

//     if (BtnPrev.clicks == 1)
//     {
//       if (menuContext.editingGroupId)
//       {
//         // Navigate through group ID digits backwards
//         if (menuContext.groupIdDigitIndex > 0)
//           menuContext.groupIdDigitIndex--;
//       }
//       else
//       {
//         // Navigate through menu options backwards
//         int optionCount = static_cast<int>(GroupMenuOption::BACK_TO_NORMAL) + 1;
//         int currentOption = static_cast<int>(menuContext.selectedOption);
//         menuContext.selectedOption = static_cast<GroupMenuOption>(
//             (currentOption - 1 + optionCount) % optionCount);
//       }
//       BtnPrev.clicks = 0;
//     }

//     if (BtnSel.clicks == 1)
//     {
//       if (menuContext.editingGroupId)
//       {
//         // Increment digit value
//         uint32_t digitValue = (menuContext.groupIdToJoin /
//                                static_cast<uint32_t>(pow(10, GROUP_ID_MAX_DIGITS - 1 - menuContext.groupIdDigitIndex))) %
//                               10;
//         digitValue = (digitValue + 1) % 10;

//         uint32_t powerOf10 = static_cast<uint32_t>(pow(10, GROUP_ID_MAX_DIGITS - 1 - menuContext.groupIdDigitIndex));
//         menuContext.groupIdToJoin = (menuContext.groupIdToJoin / (powerOf10 * 10)) * (powerOf10 * 10) +
//                                     digitValue * powerOf10 +
//                                     (menuContext.groupIdToJoin % powerOf10);
//       }
//       BtnSel.clicks = 0;
//     }
//   }

//   // Auto-return to normal mode from group info after timeout
//   if (menuContext.currentState == MenuState::GROUP_INFO &&
//       currentTime - menuContext.groupInfoDisplayStart > GROUP_INFO_DISPLAY_TIME)
//   {
//     menuContext.currentState = MenuState::NORMAL_MODE;
//   }
// }

// void Application::displayNormalMode()
// {
//   // Display current application mode on status LEDs
//   switch (mode)
//   {
//   case ApplicationMode::NORMAL:
//     statusLed1.setColor(0, 255, 0); // Green
//     statusLed2.setColor(0, 255, 0);
//     break;
//   case ApplicationMode::TEST:
//     statusLed1.setColor(255, 0, 255); // Magenta
//     statusLed2.setColor(255, 0, 255);
//     break;
//   case ApplicationMode::REMOTE:
//     statusLed1.setColor(0, 0, 255); // Blue
//     statusLed2.setColor(0, 0, 255);
//     break;
//   case ApplicationMode::OFF:
//     statusLed1.setColor(255, 0, 0); // Red
//     statusLed2.setColor(255, 0, 0);
//     break;
//   }
// }

// void Application::displayGroupInfo()
// {
//   SyncManager *syncMgr = SyncManager::getInstance();

//   if (syncMgr->isInGroup())
//   {
//     // In a group: Show group status
//     if (syncMgr->isGroupMaster())
//     {
//       // Master: Solid cyan
//       statusLed1.setColor(0, 255, 255);
//       statusLed2.setColor(0, 255, 255);
//     }
//     else
//     {
//       // Member: Blinking cyan
//       uint32_t blinkTime = millis() % 1000;
//       if (blinkTime < 500)
//       {
//         statusLed1.setColor(0, 255, 255);
//         statusLed2.setColor(0, 255, 255);
//       }
//       else
//       {
//         statusLed1.off();
//         statusLed2.off();
//       }
//     }
//   }
//   else
//   {
//     // Not in a group: Show search status
//     uint32_t searchTime = millis() % 2000;
//     if (searchTime < 200)
//     {
//       statusLed1.setColor(255, 255, 0); // Yellow flash
//       statusLed2.off();
//     }
//     else if (searchTime < 400)
//     {
//       statusLed1.off();
//       statusLed2.setColor(255, 255, 0);
//     }
//     else
//     {
//       statusLed1.off();
//       statusLed2.off();
//     }
//   }
// }

// void Application::displayGroupMenu()
// {
//   // Display current menu option using LED patterns
//   uint32_t menuTime = millis() % 1000;

//   switch (menuContext.selectedOption)
//   {
//   case GroupMenuOption::CREATE_GROUP:
//   {
//     // Green pulsing
//     uint8_t brightness = static_cast<uint8_t>(128 + 127 * sin(menuTime * 2 * PI / 1000));
//     statusLed1.setColor(0, brightness, 0);
//     statusLed2.setColor(0, brightness, 0);
//   }
//   break;

//   case GroupMenuOption::JOIN_GROUP:
//   {
//     // Blue pulsing (editing mode shows different pattern)
//     if (menuContext.editingGroupId)
//     {
//       // Show digit position with alternating pattern
//       if ((millis() / 200) % 2 == 0)
//       {
//         statusLed1.setColor(0, 0, 255);
//         statusLed2.setColor(255, 255, 255);
//       }
//       else
//       {
//         statusLed1.setColor(255, 255, 255);
//         statusLed2.setColor(0, 0, 255);
//       }
//     }
//     else
//     {
//       uint8_t brightness = static_cast<uint8_t>(128 + 127 * sin(menuTime * 2 * PI / 1000));
//       statusLed1.setColor(0, 0, brightness);
//       statusLed2.setColor(0, 0, brightness);
//     }
//   }
//   break;

//   case GroupMenuOption::LEAVE_GROUP:
//   {
//     // Red pulsing
//     uint8_t brightness = static_cast<uint8_t>(128 + 127 * sin(menuTime * 2 * PI / 1000));
//     statusLed1.setColor(brightness, 0, 0);
//     statusLed2.setColor(brightness, 0, 0);
//   }
//   break;

//   case GroupMenuOption::AUTO_JOIN_TOGGLE:
//   {
//     // Purple/White alternating
//     if (menuTime < 500)
//     {
//       statusLed1.setColor(128, 0, 128);
//       statusLed2.setColor(128, 0, 128);
//     }
//     else
//     {
//       statusLed1.setColor(255, 255, 255);
//       statusLed2.setColor(255, 255, 255);
//     }
//   }
//   break;

//   case GroupMenuOption::BACK_TO_NORMAL:
//   {
//     // Orange blinking
//     if (menuTime < 300)
//     {
//       statusLed1.setColor(255, 165, 0);
//       statusLed2.setColor(255, 165, 0);
//     }
//     else
//     {
//       statusLed1.off();
//       statusLed2.off();
//     }
//   }
//   break;
//   }
// }

// void Application::executeGroupMenuAction()
// {
//   SyncManager *syncMgr = SyncManager::getInstance();

//   if (menuContext.selectedOption == GroupMenuOption::CREATE_GROUP)
//   {
//     syncMgr->createGroup();
//     statusLed1.blink(0x00FF00, 3, 3);
//     statusLed2.blink(0x00FF00, 3, 3);
//   }
//   else if (menuContext.selectedOption == GroupMenuOption::JOIN_GROUP)
//   {
//     if (!menuContext.editingGroupId)
//     {
//       menuContext.editingGroupId = true;
//       menuContext.groupIdToJoin = 0;
//       menuContext.groupIdDigitIndex = 0;
//     }
//     else
//     {
//       if (menuContext.groupIdToJoin > 0)
//       {
//         syncMgr->joinGroup(menuContext.groupIdToJoin);
//         statusLed1.blink(0x0000FF, 3, 3);
//         statusLed2.blink(0x0000FF, 3, 3);
//       }
//       menuContext.editingGroupId = false;
//     }
//   }
//   else if (menuContext.selectedOption == GroupMenuOption::LEAVE_GROUP)
//   {
//     if (syncMgr->isInGroup())
//     {
//       syncMgr->leaveGroup();
//       statusLed1.blink(0xFF0000, 3, 3);
//       statusLed2.blink(0xFF0000, 3, 3);
//     }
//   }
//   else if (menuContext.selectedOption == GroupMenuOption::AUTO_JOIN_TOGGLE)
//   {
//     syncMgr->enableAutoJoin(!syncMgr->isAutoJoinEnabled());
//     uint32_t color = syncMgr->isAutoJoinEnabled() ? 0x800080 : 0xFFFFFF;
//     statusLed1.blink(color, 3, 3);
//     statusLed2.blink(color, 3, 3);
//   }
//   else if (menuContext.selectedOption == GroupMenuOption::BACK_TO_NORMAL)
//   {
//     menuContext.currentState = MenuState::NORMAL_MODE;
//     menuContext.inGroupMenu = false;
//     menuContext.editingGroupId = false;
//   }
// }

// void Application::updateSyncedLEDTiming()
// {
//   uint32_t currentTime = millis();

//   // Only update synced LED when in normal mode and at controlled intervals
//   if (menuContext.currentState == MenuState::NORMAL_MODE &&
//       currentTime - menuContext.lastSyncUpdate > SYNC_UPDATE_INTERVAL)
//   {
//     menuContext.lastSyncUpdate = currentTime;
//     SyncManager::getInstance()->updateSyncedLED();
//   }
// }========
==== AppStuff/Effects.cpp: ====
#include "Application.h"
#include "IO/LED/LEDStripManager.h"

void Application::setupEffects()
{
  LEDStripManager *ledManager = LEDStripManager::getInstance();

  // Set each effect's LED manager pointer.
  leftIndicatorEffect = new IndicatorEffect(IndicatorEffect::LEFT,
                                            10, true);
  rightIndicatorEffect = new IndicatorEffect(IndicatorEffect::RIGHT,
                                             10, true);
  leftIndicatorEffect->setOtherIndicator(rightIndicatorEffect);
  rightIndicatorEffect->setOtherIndicator(leftIndicatorEffect);

  brakeEffect = new BrakeLightEffect(9, true);
  reverseLightEffect = new ReverseLightEffect(8, true);

  headlightEffect = new HeadlightEffect(4, false);
  taillightEffect = new TaillightEffect(4, false);

  rgbEffect = new RGBEffect(5, false);
  nightriderEffect = new NightRiderEffect(5, false);
  pulseWaveEffect = new PulseWaveEffect(5, false);
  auroraEffect = new AuroraEffect(5, false);
  solidColorEffect = new SolidColorEffect(5, false);
  colorFadeEffect = new ColorFadeEffect(5, false);

  policeEffect = new PoliceEffect(4, false);

  // Add effects to the LED manager.

  auto headlightStrip = ledManager->getStrip(LEDStripType::HEADLIGHT);
  auto taillightStrip = ledManager->getStrip(LEDStripType::TAILLIGHT);
  auto underglowStrip = ledManager->getStrip(LEDStripType::UNDERGLOW);
  auto interiorStrip = ledManager->getStrip(LEDStripType::INTERIOR);

  if (headlightStrip)
  {
    headlightStrip->addEffect(leftIndicatorEffect);
    headlightStrip->addEffect(rightIndicatorEffect);

    headlightStrip->addEffect(headlightEffect);

    headlightStrip->addEffect(rgbEffect);
    headlightStrip->addEffect(nightriderEffect);
    headlightStrip->addEffect(policeEffect);
    // headlightStrip->addEffect(pulseWaveEffect);
    // headlightStrip->addEffect(auroraEffect);
    headlightStrip->addEffect(solidColorEffect);
    headlightStrip->addEffect(colorFadeEffect);
  }

  if (taillightStrip)
  {
    taillightStrip->addEffect(leftIndicatorEffect);
    taillightStrip->addEffect(rightIndicatorEffect);

    taillightStrip->addEffect(taillightEffect);

    taillightStrip->addEffect(brakeEffect);
    taillightStrip->addEffect(reverseLightEffect);

    taillightStrip->addEffect(rgbEffect);
    taillightStrip->addEffect(nightriderEffect);
    taillightStrip->addEffect(policeEffect);
    // taillightStrip->addEffect(pulseWaveEffect);
    // taillightStrip->addEffect(auroraEffect);
    taillightStrip->addEffect(solidColorEffect);
    taillightStrip->addEffect(colorFadeEffect);
  }

  if (underglowStrip)
  {
    taillightStrip->addEffect(rgbEffect);
    taillightStrip->addEffect(nightriderEffect);
    taillightStrip->addEffect(policeEffect);
    // taillightStrip->addEffect(pulseWaveEffect);
    // taillightStrip->addEffect(auroraEffect);
    taillightStrip->addEffect(solidColorEffect);
    taillightStrip->addEffect(colorFadeEffect);
  }
}========
==== AppStuff/NormalMode.cpp: ====
#include "Application.h"
#include "Sync/SyncManager.h"

void Application::handleNormalEffects()
{
  unsigned long currentTime = millis();

#ifdef ENABLE_SYNC
  SyncManager *syncMgr = SyncManager::getInstance();
  bool isSyncing = syncMgr->isInGroup() && syncMgr->getGroupInfo().members.size() > 1;
  bool isMaster = syncMgr->isGroupMaster();
#else
  bool isSyncing = false;
  bool isMaster = false;
#endif

  unlockSequence->setInputs(accOnInput.get(), leftIndicatorInput.get(), rightIndicatorInput.get());
  lockSequence->setInputs(accOnInput.get(), leftIndicatorInput.get(), rightIndicatorInput.get());
  RGBFlickSequence->setInputs(accOnInput.get(), leftIndicatorInput.get(), rightIndicatorInput.get());
  nightRiderFlickSequence->setInputs(accOnInput.get(), leftIndicatorInput.get(), rightIndicatorInput.get());

  unlockSequence->loop();
  lockSequence->loop();
  RGBFlickSequence->loop();
  nightRiderFlickSequence->loop();

  policeEffect->setActive(false); // ensure police effect is off

  if (accOnInput.getLastActiveTime() != 0 && currentTime - accOnInput.getLastActiveTime() > 1 * 60 * 1000) 
  {
    accOnInput.setLastActiveTime(0);
    unlockSequence->setActive(true);

    LEDEffect::disableAllEffects();
  }

  if (accOnInput.getLast() != accOnInput.get() && accOnInput.get() == false) // acc just went off
  {
    if (taillightEffect)
    {
      taillightEffect->setStartup();
    }
    // headlightStartupEffect->setStartup();
  }

  bool debugSync = false;
#ifdef DEBUG_SYNC
  debugSync = true;
#endif

  if (accOnInput.get() == false) // acc is off
  {
    // Since ACC is off, disable the other effects.
    leftIndicatorEffect->setActive(false);
    rightIndicatorEffect->setActive(false);

    brakeEffect->setActive(false);
    brakeEffect->setIsReversing(false);
    reverseLightEffect->setActive(false);
    policeEffect->setActive(false);

    pulseWaveEffect->setActive(false);
    auroraEffect->setActive(false);

    rgbEffect->setActive(false);
    nightriderEffect->setActive(false);
    solidColorEffect->setActive(false);
  }

  if (accOnInput.getLast() != accOnInput.get() && accOnInput.get() == true) // acc just went on
  {
    if (taillightEffect)
    {
      taillightEffect->setDim();
      headlightEffect->setCarOn();
    }
  }

  if (accOnInput.get() == true) // acc is on
  { 
    // Only apply physical input controls if we're the master
    // or we're not syncing with other devices
    if (!isSyncing || isMaster)
    {
      // And process the other effects normally.
      leftIndicatorEffect->setActive(leftIndicatorInput.get());
      rightIndicatorEffect->setActive(rightIndicatorInput.get());

      // Keep separate brake and reverse effects
      brakeEffect->setActive(brakeInput.get());
      brakeEffect->setIsReversing(reverseInput.get() || reverseLightEffect->isAnimating());
      reverseLightEffect->setActive(reverseInput.get());

      if (isMaster && syncMgr->isEffectSyncEnabled())
      {
        EffectSyncState effectState = {};

        effectState.rgbSyncData = rgbEffect->getSyncData();
        effectState.nightRiderSyncData = nightriderEffect->getSyncData();
        effectState.policeSyncData = policeEffect->getSyncData();
        effectState.solidColorSyncData = solidColorEffect->getSyncData();

        syncMgr->setEffectSyncState(effectState);
      }
    }
  }
}========
==== AppStuff/Sequences.cpp: ====
#include "Application.h"

void Application::setupSequences()
{
  // Sequences
  unlockSequence = new BothIndicatorsSequence(1);
  lockSequence = new BothIndicatorsSequence(3);
  RGBFlickSequence = new IndicatorFlickSequence(IndicatorSide::LEFT_SIDE);
  nightRiderFlickSequence = new IndicatorFlickSequence(IndicatorSide::RIGHT_SIDE);

  brakeTapSequence3 = new BrakeTapSequence(3);

  unlockSequence->setActive(true);
  unlockSequence->setCallback([this]()
                              {
                                taillightEffect->setStartup();
                                headlightEffect->setStartup();
                                unlockSequence->setActive(false);
                                // lockSequence->reset();
                                //
                              });

  lockSequence->setActive(true);
  lockSequence->setCallback([this]()
                            {
                              taillightEffect->setOff();
                              headlightEffect->setOff();
                              unlockSequence->setActive(true);
                              //
                            });

  RGBFlickSequence->setActive(true);
  RGBFlickSequence->setCallback([this]()
                                {
                                  rgbEffect->setActive(!rgbEffect->isActive());
                                  nightRiderFlickSequence->reset();

                                  nightriderEffect->setActive(false);
                                  //
                                });

  nightRiderFlickSequence->setActive(true);
  nightRiderFlickSequence->setCallback([this]()
                                       {
                                         nightriderEffect->setActive(!nightriderEffect->isActive());
                                         RGBFlickSequence->reset();

                                         rgbEffect->setActive(false);
                                         //
                                       });

  brakeTapSequence3->setActive(true);
  brakeTapSequence3->setCallback([this]()
                                 {
                                   // diable all special effects
                                   rgbEffect->setActive(false);
                                   nightriderEffect->setActive(false);
                                   policeEffect->setActive(false);
                                   pulseWaveEffect->setActive(false);
                                   auroraEffect->setActive(false);

                                   enableNormalMode();
                                   //
                                 });
}========
==== Application.cpp: ====
// application.cpp

#include "Application.h"
#include "config.h"
#include "IO/Wireless.h"
#include "IO/LED/LEDStripManager.h"
#include "Sync/SyncManager.h"
#include "IO/StatusLed.h"
#include "IO/TimeProfiler.h"
#include <math.h>

//----------------------------------------------------------------------------

Application *Application::getInstance()
{
  static Application instance;
  return &instance;
}

//----------------------------------------------------------------------------
/*
 * Application constructor. Initialize pointers and set defaults.
 */
Application::Application()
{
// Initialize HVInput instances.
#ifdef ENABLE_HV_INPUTS
  accOnInput = HVInput(&input1, HV_HIGH_ACTIVE);
  leftIndicatorInput = HVInput(&input2, HV_HIGH_ACTIVE);
  rightIndicatorInput = HVInput(&input3, HV_HIGH_ACTIVE);

  headlightInput = HVInput(&input4, HV_HIGH_ACTIVE);

  brakeInput = HVInput(&input5, HV_HIGH_ACTIVE);
  reverseInput = HVInput(&input6, HV_HIGH_ACTIVE);

#endif

  // Initialize effect pointers to nullptr
  leftIndicatorEffect = nullptr;
  rightIndicatorEffect = nullptr;
  rgbEffect = nullptr;
  nightriderEffect = nullptr;
  taillightEffect = nullptr;
  policeEffect = nullptr;
  pulseWaveEffect = nullptr;
  auroraEffect = nullptr;
  colorFadeEffect = nullptr;
  solidColorEffect = nullptr;

  // Initialize sequence pointers to nullptr
  unlockSequence = nullptr;
  lockSequence = nullptr;
  RGBFlickSequence = nullptr;
  nightRiderFlickSequence = nullptr;

  brakeTapSequence3 = nullptr;

  appInitialized = false;
}

/*
 * Begin: Initializes the LED strip, effects, wireless, etc.
 */
void Application::begin()
{
  if (appInitialized)
    return;

  appInitialized = true;

  mode = static_cast<ApplicationMode>(preferences.getUInt("mode", 0));
  prevMode = mode == ApplicationMode::NORMAL ? ApplicationMode::OFF : ApplicationMode::NORMAL;

  LEDStripManager *ledManager = LEDStripManager::getInstance();
  ledManager->begin();

  // ledManager->startTask();

  if (ledConfig.headlightsEnabled)
  {
    LEDStripConfig headlights(
        LEDStripType::HEADLIGHT,
        new LEDStrip(ledConfig.headlightLedCount, OUTPUT_LED_1_PIN),
        "Headlights");
    headlights.strip->setFliped(ledConfig.headlightFlipped);

    ledManager->addLEDStrip(headlights);

    headlights.strip->getBuffer()[0] = Color(255, 0, 0);
    delay(500);
    headlights.strip->getBuffer()[0] = Color(0, 0, 0);
  }

  if (ledConfig.taillightsEnabled)
  {
    LEDStripConfig taillights(
        LEDStripType::TAILLIGHT,
        new LEDStrip(ledConfig.taillightLedCount, OUTPUT_LED_2_PIN),
        "Taillights");
    taillights.strip->setFliped(ledConfig.taillightFlipped);

    ledManager->addLEDStrip(taillights);

    taillights.strip->getBuffer()[0] = Color(255, 0, 0);
    delay(500);
    taillights.strip->getBuffer()[0] = Color(0, 0, 0);
  }

  if (ledConfig.underglowEnabled)
  {
    LEDStripConfig underglow(
        LEDStripType::UNDERGLOW,
        new LEDStrip(ledConfig.underglowLedCount, OUTPUT_LED_3_PIN),
        "Underglow");
    underglow.strip->setFliped(ledConfig.underglowFlipped);

    ledManager->addLEDStrip(underglow);

    underglow.strip->getBuffer()[0] = Color(255, 0, 0);
    delay(500);
    underglow.strip->getBuffer()[0] = Color(0, 0, 0);
  }

  if (ledConfig.interiorEnabled)
  {
    LEDStripConfig interior(
        LEDStripType::INTERIOR,
        new LEDStrip(ledConfig.interiorLedCount, OUTPUT_LED_4_PIN),
        "Interior");
    interior.strip->setFliped(ledConfig.interiorFlipped);

    ledManager->addLEDStrip(interior);

    interior.strip->getBuffer()[0] = Color(255, 0, 0);
    delay(500);
    interior.strip->getBuffer()[0] = Color(0, 0, 0);
  }

  setupEffects();
  setupSequences();
  setupWireless();
  setupBLE();

  // Initialize SyncManager
  SyncManager *syncMgr = SyncManager::getInstance();
  syncMgr->begin();

#ifdef ENABLE_SYNC
  // Set up callbacks for sync events
  syncMgr->setDeviceDiscoveredCallback([this](const DiscoveredDevice &device)
                                       { Serial.println("Application: Device discovered - ID: 0x" + String(device.deviceId, HEX)); });

  syncMgr->setGroupFoundCallback([this](const GroupAdvert &advert)
                                 { Serial.println("Application: Group found - ID: 0x" + String(advert.groupId, HEX)); });

  syncMgr->setGroupCreatedCallback([this](const GroupInfo &group)
                                   { Serial.println("Application: Group created - ID: 0x" + String(group.groupId, HEX)); });

  syncMgr->setGroupJoinedCallback([this](const GroupInfo &group)
                                  { Serial.println("Application: Joined group - ID: 0x" + String(group.groupId, HEX)); });

  syncMgr->setGroupLeftCallback([this]()
                                { Serial.println("Application: Left group"); });

  syncMgr->setTimeSyncCallback([this](uint32_t syncedTime)
                               {
                                 Serial.println("Application: Time synchronized - synced time: " + String(syncedTime));
                                 // TODO: Use synchronized time for effect timing coordination
                               });

  syncMgr->setEffectSyncCallback([this](const EffectSyncState &effectState)
                                 {
                                  Serial.println("Application: Effect sync received");
                                  handleSyncedEffects(effectState); });

  Serial.println("Application: Auto-join enabled - devices will automatically pair");
#endif

  // set brightness to 100
  ledManager->setBrightness(255);
}

ApplicationMode Application::getMode()
{
  return mode;
}

void Application::updateInputs()
{
  accOnInput.update();
  leftIndicatorInput.update();
  rightIndicatorInput.update();
  headlightInput.update();
  brakeInput.update();
  reverseInput.update();
}

/*
 * update():
 * Main loop update.
 */
void Application::loop()
{
  if (!appInitialized)
    return;

  timeProfiler.increment("appFps");
  timeProfiler.start("appLoop", TimeUnit::MICROSECONDS);
  // Update input states.
  timeProfiler.start("updateInputs", TimeUnit::MICROSECONDS);
  updateInputs();
  timeProfiler.stop("updateInputs");

  // handle remote dissconnection
  if (lastRemotePing != 0 && millis() - lastRemotePing > 2000)
  {
    if (mode == ApplicationMode::TEST || mode == ApplicationMode::REMOTE)
    {
      lastRemotePing = 0;
      mode = ApplicationMode::NORMAL;

      // disable all effects
      LEDEffect::disableAllEffects();
    }
  }

  // handle brake tap sequence. always check if this is triggered
  brakeTapSequence3->setInput(brakeInput.get());
  brakeTapSequence3->loop();

  timeProfiler.start("updateMode", TimeUnit::MICROSECONDS);
  switch (mode)
  {
  case ApplicationMode::NORMAL:
    handleNormalEffects();
    break;

  case ApplicationMode::TEST:
  {
    // handleTestEffects();
    handleNormalEffects();
  }
  break;

  case ApplicationMode::REMOTE:
    handleRemoteEffects();
    break;

  case ApplicationMode::OFF:
  {
    // turn off all effects
    LEDEffect::disableAllEffects();
    SyncManager::getInstance()->setSyncMode(SyncMode::SOLO);
  }
  break;
  }

  if (mode != prevMode)
  {
    prevMode = mode;
  }

  timeProfiler.stop("updateMode");

  // Update SyncManager
  timeProfiler.start("updateSync", TimeUnit::MICROSECONDS);
  SyncManager *syncMgr = SyncManager::getInstance();
  syncMgr->loop();

  timeProfiler.stop("updateSync");

  // Update BLE
  timeProfiler.start("updateBLE", TimeUnit::MICROSECONDS);
  BLEManager *bleManager = BLEManager::getInstance();
  bleManager->loop();
  timeProfiler.stop("updateBLE");

  // Update and draw LED effects.
  timeProfiler.start("updateEffects", TimeUnit::MICROSECONDS);
  LEDStripManager::getInstance()->updateEffects();
  timeProfiler.stop("updateEffects");

  LEDStripManager::getInstance()->draw();

  timeProfiler.stop("appLoop");
}

void Application::enableNormalMode()
{
  mode = ApplicationMode::NORMAL;
  preferences.putUInt("mode", static_cast<int>(mode));

  // clear all overrides
  accOnInput.clearOverride();
  leftIndicatorInput.clearOverride();
  rightIndicatorInput.clearOverride();
  headlightInput.clearOverride();
  brakeInput.clearOverride();
  reverseInput.clearOverride();
}

void Application::enableTestMode()
{
  mode = ApplicationMode::TEST;
  preferences.putUInt("mode", static_cast<uint8_t>(mode));
}

void Application::enableRemoteMode()
{
  mode = ApplicationMode::REMOTE;
  preferences.putUInt("mode", static_cast<uint8_t>(mode));
}

void Application::enableOffMode()
{
  mode = ApplicationMode::OFF;
  preferences.putUInt("mode", static_cast<uint8_t>(mode));

  // turn off all effects
  LEDEffect::disableAllEffects();
}

void Application::handleTestEffects()
{

  // Regular test mode controls (commented out)
  // reverseLightEffect->setActive(true);
  // headlightEffect->setActive(true);
  // headlightEffect->setSplit(false);
  // brakeEffect->setIsReversing(true);
  // brakeEffect->setActive(io0.read());
  // leftIndicatorEffect->setActive(io0.read());
  // rightIndicatorEffect->setActive(io0.read());
  // reverseLightEffect->setActive(io0.read());
  // rgbEffect->setActive(io0.read());
  // startupEffect->setActive(io0.read());
}

void Application::handleRemoteEffects()
{
  SyncManager *syncMgr = SyncManager::getInstance();
  bool isSyncing = syncMgr->isInGroup() && syncMgr->getGroupInfo().members.size() > 1;
  bool isMaster = syncMgr->isGroupMaster();

  if (isMaster && syncMgr->isEffectSyncEnabled())
  {
    EffectSyncState effectState = {};

    effectState.rgbSyncData = rgbEffect->getSyncData();
    effectState.nightRiderSyncData = nightriderEffect->getSyncData();
    effectState.policeSyncData = policeEffect->getSyncData();
    effectState.solidColorSyncData = solidColorEffect->getSyncData();

    syncMgr->setEffectSyncState(effectState);
  }
}

void Application::handleSyncedEffects(const EffectSyncState &effectState)
{
  rgbEffect->setSyncData(effectState.rgbSyncData);
  nightriderEffect->setSyncData(effectState.nightRiderSyncData);
  policeEffect->setSyncData(effectState.policeSyncData);
  solidColorEffect->setSyncData(effectState.solidColorSyncData);
}

void Application::setupBLE()
{
  Serial.println("Application: Setting up BLE...");

  BLEManager *bleManager = BLEManager::getInstance();
  bleManager->setApplication(this);
  bleManager->begin();

  Serial.println("Application: BLE setup complete");
}
========
==== Application.h: ====
// application.h

#pragma once

#include "config.h"
#include "IO/LED/LEDStrip.h"
#include "IO/LED/Effects/BrakeLightEffect.h"
#include "IO/LED/Effects/IndicatorEffect.h"
#include "IO/LED/Effects/ReverseLightEffect.h"
#include "IO/LED/Effects/RGBEffect.h"
#include "IO/LED/Effects/NightRiderEffect.h"
#include "IO/LED/Effects/TaillightEffect.h"
#include "IO/LED/Effects/HeadlightEffect.h"
// #include "IO/LED/Effects/HeadlightStartupEffect.h"
#include "IO/LED/Effects/PoliceEffect.h"
#include "IO/LED/Effects/PulseWaveEffect.h"
#include "IO/LED/Effects/AuroraEffect.h"
#include "IO/LED/Effects/SolidColorEffect.h"
#include "IO/LED/Effects/ColorFadeEffect.h"

#include "Sequences/SequenceBase.h"
#include "Sequences/BothIndicatorsSequence.h"
#include "Sequences/IndicatorFlickSequence.h"
#include "Sequences/BrakeTapSequence.h"

#include "IO/GPIO.h"
#include "IO/Inputs.h"
#include "IO/Wireless.h"

#include "SerialMenu.h"
#include "IO/Inputs.h"
#include "Sync/SyncManager.h"
#include "IO/BLE.h"

#define NUM_MODES 4

enum class ApplicationMode
{
  NORMAL,
  TEST,
  REMOTE,
  OFF
};

// Add menu system enums and states
enum class MenuState
{
  NORMAL_MODE, // Regular mode display
  GROUP_INFO,  // Show group information
  GROUP_MENU   // Group management menu
};

enum class GroupMenuOption
{
  CREATE_GROUP,
  JOIN_GROUP,
  LEAVE_GROUP,
  AUTO_JOIN_TOGGLE,
  BACK_TO_NORMAL
};

struct MenuContext
{
  MenuState currentState = MenuState::NORMAL_MODE;
  GroupMenuOption selectedOption = GroupMenuOption::CREATE_GROUP;
  uint32_t lastBootPress = 0;
  uint32_t groupInfoDisplayStart = 0;
  uint32_t lastSyncUpdate = 0;
  bool inGroupMenu = false;
  uint32_t groupIdToJoin = 0;
  uint8_t groupIdDigitIndex = 0;
  bool editingGroupId = false;
};

struct AppStats
{
  uint32_t loopsPerSecond;
  uint32_t updateInputTime;

  uint32_t updateModeTime;
  uint32_t updateSyncTime;

  uint32_t updateEffectsTime;
  uint32_t drawTime;
};

class Application
{
  friend class BLEManager;

public:
  static Application *getInstance();

  Application();

  // Call once to initialize the system.
  void begin();

  void setupEffects();
  void setupSequences();

  ApplicationMode getMode();

  // Main loop function to be called from loop()
  void loop();

  void btnLoop();

  // Set testMode externally.
  void enableNormalMode();
  void enableTestMode();
  void enableRemoteMode();
  void enableOffMode();

  // HVInput instances
  HVInput accOnInput;          // 12v ACC
  HVInput leftIndicatorInput;  // Left indicator
  HVInput rightIndicatorInput; // Right indicator
  HVInput headlightInput;      // Headlight
  HVInput brakeInput;          // Brake
  HVInput reverseInput;        // Reverse

  // Effect instances.
  IndicatorEffect *leftIndicatorEffect;
  IndicatorEffect *rightIndicatorEffect;

  HeadlightEffect *headlightEffect;
  TaillightEffect *taillightEffect;

  BrakeLightEffect *brakeEffect;
  ReverseLightEffect *reverseLightEffect;

  RGBEffect *rgbEffect;
  NightRiderEffect *nightriderEffect;
  PoliceEffect *policeEffect;
  PulseWaveEffect *pulseWaveEffect;
  AuroraEffect *auroraEffect;
  SolidColorEffect *solidColorEffect;
  ColorFadeEffect *colorFadeEffect;

  // Sequences
  BothIndicatorsSequence *unlockSequence;
  BothIndicatorsSequence *lockSequence;
  IndicatorFlickSequence *RGBFlickSequence;
  IndicatorFlickSequence *nightRiderFlickSequence;
  BrakeTapSequence *brakeTapSequence3;

  // Application Mode
  ApplicationMode mode;
  ApplicationMode prevMode;

private:
  void updateInputs();
  void setupWireless();
  void setupBLE();

  

  bool appInitialized;

  // Menu system
  MenuContext menuContext;

  // Internal method to handle effect selection based on inputs.
  void handleNormalEffects();
  void handleTestEffects();
  void handleRemoteEffects();
  void handleSyncedEffects(const EffectSyncState &effectState);

  uint64_t lastRemotePing;
  AppStats stats;
};
========
==== IO/BLE.cpp: ====
#include "BLE.h"
#include "../Application.h"
#include "LED/LEDStripManager.h"
#include "TimeProfiler.h"
#include <esp_system.h>

// Initialize static instance
BLEManager *BLEManager::instance = nullptr;

BLEManager *BLEManager::getInstance()
{
  if (!instance)
  {
    instance = new BLEManager();
  }
  return instance;
}

BLEManager::BLEManager()
    : pServer(nullptr), pService(nullptr), app(nullptr), deviceConnected(false), connectionCount(0), lastPingUpdate(0)
{
  // Initialize characteristic pointers to nullptr
  pPingCharacteristic = nullptr;
  pModeCharacteristic = nullptr;
  pEffectsCharacteristic = nullptr;
}

BLEManager::~BLEManager()
{
  end();
}

void BLEManager::begin()
{
  Serial.println("BLEManager: Initializing BLE...");

  // Initialize BLE Device
  String deviceName = "ESP32-TailLights-" + String((uint32_t)ESP.getEfuseMac(), HEX);
  BLEDevice::init(deviceName.c_str());

  // Create BLE Server
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new TaillightBLEServerCallbacks(this));

  // Create BLE Service
  pService = pServer->createService(TAILLIGHT_SERVICE_UUID);

  setupCharacteristics();
  setupCallbacks();

  // Start the service
  pService->start();

  // Start advertising
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(TAILLIGHT_SERVICE_UUID);
  pAdvertising->setScanResponse(true);
  pAdvertising->setMinPreferred(0x06); // Functions that help with iPhone connections issue
  pAdvertising->setMinPreferred(0x12);
  BLEDevice::startAdvertising();

  Serial.println("BLEManager: BLE service started and advertising");
}

void BLEManager::setupCharacteristics()
{
  // Ping Characteristic (Read only + Notify)
  pPingCharacteristic = pService->createCharacteristic(
      PING_CHARACTERISTIC_UUID,
      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_NOTIFY);
  pPingCharacteristic->addDescriptor(new BLE2902());

  // Mode Characteristic (Read/Write + Notify)
  pModeCharacteristic = pService->createCharacteristic(
      MODE_CHARACTERISTIC_UUID,
      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE | BLECharacteristic::PROPERTY_NOTIFY);
  pModeCharacteristic->addDescriptor(new BLE2902());

  // Effects Characteristic (Read/Write + Notify)
  pEffectsCharacteristic = pService->createCharacteristic(
      EFFECTS_CHARACTERISTIC_UUID,
      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE | BLECharacteristic::PROPERTY_NOTIFY);
  pEffectsCharacteristic->addDescriptor(new BLE2902());
}

void BLEManager::setupCallbacks()
{
  // Setup callbacks for the 3 characteristics
  pPingCharacteristic->setCallbacks(new TaillightBLECharacteristicCallbacks(this, "Ping"));
  pModeCharacteristic->setCallbacks(new TaillightBLECharacteristicCallbacks(this, "Mode"));
  pEffectsCharacteristic->setCallbacks(new TaillightBLECharacteristicCallbacks(this, "Effects"));
}

void BLEManager::loop()
{
  uint32_t now = millis();

  if (!deviceConnected)
  {
    return;
  }

  // Update ping data every 1000ms
  if (now - lastPingUpdate > 1000)
  {
    updatePingData();
    lastPingUpdate = now;
  }
}

void BLEManager::end()
{
  if (pServer)
  {
    pServer->getAdvertising()->stop();
    BLEDevice::deinit();
    pServer = nullptr;
    pService = nullptr;
  }
  deviceConnected = false;
  connectionCount = 0;
}

bool BLEManager::isConnected()
{
  return deviceConnected;
}

uint16_t BLEManager::getConnectionCount()
{
  return connectionCount;
}

void BLEManager::setApplication(Application *application)
{
  app = application;
}

void BLEManager::updatePingData()
{
  if (!deviceConnected || !pPingCharacteristic)
  {
    return;
  }

  BLEPingData pingData = preparePingData();

  // Check if data has changed
  bool changed = memcmp(&pingData, &lastPingData, sizeof(BLEPingData)) != 0;
  if (changed)
  {
    pPingCharacteristic->setValue((uint8_t *)&pingData, sizeof(pingData));
    pPingCharacteristic->notify();
    lastPingData = pingData;
  }
}

// Data preparation methods
BLEPingData BLEManager::preparePingData()
{
  BLEPingData data = {};

  if (!app)
    return data;

  LEDStripManager *ledManager = LEDStripManager::getInstance();

  data.mode = static_cast<uint8_t>(app->getMode());
  data.headlight = ledManager->isStripEnabled(LEDStripType::HEADLIGHT);
  data.taillight = ledManager->isStripEnabled(LEDStripType::TAILLIGHT);
  data.underglow = ledManager->isStripEnabled(LEDStripType::UNDERGLOW);
  data.interior = ledManager->isStripEnabled(LEDStripType::INTERIOR);
  data.deviceId = (uint32_t)ESP.getEfuseMac();
  data.batteryLevel = 100; // TODO: Add battery monitoring
  data.uptime = millis() / 1000;

  return data;
}

BLEModeData BLEManager::prepareModeData()
{
  BLEModeData data = {};

  if (app)
  {
    data.mode = static_cast<uint8_t>(app->getMode());
  }

  return data;
}

BLEEffectsData BLEManager::prepareEffectsData()
{
  BLEEffectsData data = {};

  if (!app)
    return data;

  // Get effect states from the application
  data.leftIndicator = app->leftIndicatorEffect ? app->leftIndicatorEffect->isActive() : false;
  data.rightIndicator = app->rightIndicatorEffect ? app->rightIndicatorEffect->isActive() : false;

  if (app->headlightEffect)
  {
    data.headlightMode = static_cast<uint8_t>(app->headlightEffect->getMode());
    data.headlightSplit = app->headlightEffect->getSplit();
    bool r, g, b;
    app->headlightEffect->getColor(r, g, b);
    data.headlightR = r;
    data.headlightG = g;
    data.headlightB = b;
  }

  if (app->taillightEffect)
  {
    data.taillightMode = static_cast<uint8_t>(app->taillightEffect->getMode());
    data.taillightSplit = app->taillightEffect->getSplit();
  }

  data.brake = app->brakeInput.get();
  data.reverse = app->reverseInput.get();
  data.rgb = app->rgbEffect ? app->rgbEffect->isActive() : false;
  data.nightrider = app->nightriderEffect ? app->nightriderEffect->isActive() : false;
  data.police = app->policeEffect ? app->policeEffect->isActive() : false;
  data.policeMode = app->policeEffect ? static_cast<uint8_t>(app->policeEffect->getMode()) : 0;
  data.pulseWave = app->pulseWaveEffect ? app->pulseWaveEffect->isActive() : false;
  data.aurora = app->auroraEffect ? app->auroraEffect->isActive() : false;
  data.solidColor = app->solidColorEffect ? app->solidColorEffect->isActive() : false;
  data.colorFade = app->colorFadeEffect ? app->colorFadeEffect->isActive() : false;

  if (app->solidColorEffect)
  {
    data.solidColorPreset = static_cast<uint8_t>(app->solidColorEffect->getColorPreset());
    uint8_t r, g, b;
    app->solidColorEffect->getCustomColor(r, g, b);
    data.solidColorR = r;
    data.solidColorG = g;
    data.solidColorB = b;
  }

  return data;
}

// Characteristic callback handlers
void BLEManager::handleModeWrite(BLECharacteristic *pCharacteristic)
{
  if (!app)
    return;

  std::string value = pCharacteristic->getValue();
  if (value.length() != sizeof(BLEModeData))
  {
    Serial.println("BLE Mode: Invalid data size");
    return;
  }

  BLEModeData *data = (BLEModeData *)value.data();
  Serial.printf("BLE Mode: Setting mode to %d\n", data->mode);

  // Set the mode in the application

  switch (data->mode)
  {
  case 0:
    app->enableNormalMode();
    break;
  case 1:
    app->enableTestMode();
    break;
  case 2:
    app->enableRemoteMode();
    break;
  case 3:
    app->enableOffMode();
    break;
  default:
    break;
  }
}

void BLEManager::handleEffectsWrite(BLECharacteristic *pCharacteristic)
{
  if (!app)
    return;

  std::string value = pCharacteristic->getValue();
  if (value.length() != sizeof(BLEEffectsData))
  {
    Serial.println("BLE Effects: Invalid data size");
    return;
  }

  BLEEffectsData *data = (BLEEffectsData *)value.data();
  Serial.println("BLE Effects: Updating effects");

  // Update indicators
  if (app->leftIndicatorEffect)
    app->leftIndicatorEffect->setActive(data->leftIndicator);
  if (app->rightIndicatorEffect)
    app->rightIndicatorEffect->setActive(data->rightIndicator);

  // Update headlight
  if (app->headlightEffect)
  {
    app->headlightEffect->setMode(data->headlightMode);
    app->headlightEffect->setSplit(data->headlightSplit);
    app->headlightEffect->setColor(data->headlightR, data->headlightG, data->headlightB);
  }

  // Update taillight
  if (app->taillightEffect)
  {
    app->taillightEffect->setMode(data->taillightMode);
    app->taillightEffect->setSplit(data->taillightSplit);
  }

  // Update other effects
  if (app->rgbEffect)
    app->rgbEffect->setActive(data->rgb);
  if (app->nightriderEffect)
    app->nightriderEffect->setActive(data->nightrider);
  if (app->policeEffect)
  {
    app->policeEffect->setActive(data->police);
    app->policeEffect->setMode(static_cast<PoliceMode>(data->policeMode));
  }
  if (app->pulseWaveEffect)
    app->pulseWaveEffect->setActive(data->pulseWave);
  if (app->auroraEffect)
    app->auroraEffect->setActive(data->aurora);
  if (app->solidColorEffect)
  {
    app->solidColorEffect->setActive(data->solidColor);
    app->solidColorEffect->setColorPreset(static_cast<SolidColorPreset>(data->solidColorPreset));
    app->solidColorEffect->setCustomColor(data->solidColorR, data->solidColorG, data->solidColorB);
  }
  if (app->colorFadeEffect)
    app->colorFadeEffect->setActive(data->colorFade);
}

// BLE Server Callbacks
TaillightBLEServerCallbacks::TaillightBLEServerCallbacks(BLEManager *manager)
    : bleManager(manager)
{
}

void TaillightBLEServerCallbacks::onConnect(BLEServer *pServer)
{
  bleManager->deviceConnected = true;
  bleManager->connectionCount++;
  Serial.printf("BLE Client connected (count: %d)\n", bleManager->connectionCount);
}

void TaillightBLEServerCallbacks::onDisconnect(BLEServer *pServer)
{
  bleManager->deviceConnected = false;
  if (bleManager->connectionCount > 0)
  {
    bleManager->connectionCount--;
  }
  Serial.printf("BLE Client disconnected (count: %d)\n", bleManager->connectionCount);

  // Restart advertising
  pServer->startAdvertising();
}

// BLE Characteristic Callbacks
TaillightBLECharacteristicCallbacks::TaillightBLECharacteristicCallbacks(BLEManager *manager, const String &charName)
    : bleManager(manager), characteristicName(charName)
{
}

void TaillightBLECharacteristicCallbacks::onWrite(BLECharacteristic *pCharacteristic)
{
  Serial.println("BLE Write to " + characteristicName);

  if (characteristicName == "Mode")
  {
    bleManager->handleModeWrite(pCharacteristic);
  }
  else if (characteristicName == "Effects")
  {
    bleManager->handleEffectsWrite(pCharacteristic);
  }
}

void TaillightBLECharacteristicCallbacks::onRead(BLECharacteristic *pCharacteristic)
{
  Serial.println("BLE Read from " + characteristicName);

  // Update characteristic value based on current state
  if (characteristicName == "Ping")
  {
    BLEPingData data = bleManager->preparePingData();
    pCharacteristic->setValue((uint8_t *)&data, sizeof(data));
  }
  else if (characteristicName == "Mode")
  {
    BLEModeData data = bleManager->prepareModeData();
    pCharacteristic->setValue((uint8_t *)&data, sizeof(data));
  }
  else if (characteristicName == "Effects")
  {
    BLEEffectsData data = bleManager->prepareEffectsData();
    pCharacteristic->setValue((uint8_t *)&data, sizeof(data));
  }
}========
==== IO/BLE.h: ====
#pragma once

#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include <functional>
#include "config.h"
#include "IO/LED/Types.h"

// BLE Service and Characteristic UUIDs
#define TAILLIGHT_SERVICE_UUID "51afeb92-c5fe-4efb-bf6f-5b9baf50d87f"

// Only 3 Characteristics
#define PING_CHARACTERISTIC_UUID "7285c8f6-30eb-4266-b5c3-7a34ba69a8b7"
#define MODE_CHARACTERISTIC_UUID "44969bf5-4a79-4fce-8acd-3b794f81c380"
#define EFFECTS_CHARACTERISTIC_UUID "7645b13d-3f3b-4046-8929-05c1c72e2900"

// Simplified BLE Data Structures
struct __attribute__((packed)) BLEPingData
{
  uint8_t mode;
  bool headlight;
  bool taillight;
  bool underglow;
  bool interior;
  uint32_t deviceId;
  uint8_t batteryLevel;
  uint32_t uptime;
};

struct __attribute__((packed)) BLEModeData
{
  uint8_t mode; // 0=NORMAL, 1=TEST, 2=REMOTE, 3=OFF
};

struct __attribute__((packed)) BLEEffectsData
{
  bool leftIndicator;
  bool rightIndicator;
  uint8_t headlightMode;
  bool headlightSplit;
  bool headlightR;
  bool headlightG;
  bool headlightB;
  uint8_t taillightMode;
  bool taillightSplit;
  bool brake;
  bool reverse;
  bool rgb;
  bool nightrider;
  bool police;
  uint8_t policeMode;
  bool pulseWave;
  bool aurora;
  bool solidColor;
  uint8_t solidColorPreset;
  uint8_t solidColorR;
  uint8_t solidColorG;
  uint8_t solidColorB;
  bool colorFade;
};

// Forward declarations
class Application;

class BLEManager
{
  friend class TaillightBLEServerCallbacks;
  friend class TaillightBLECharacteristicCallbacks;

public:
  static BLEManager *getInstance();

  void begin();
  void loop();
  void end();

  bool isConnected();
  uint16_t getConnectionCount();

  // Data update methods (called by Application)
  void updatePingData();

  // Callbacks
  void setApplication(Application *app);

private:
  BLEManager();
  ~BLEManager();

  static BLEManager *instance;

  BLEServer *pServer;
  BLEService *pService;

  // Only 3 characteristic pointers
  BLECharacteristic *pPingCharacteristic;
  BLECharacteristic *pModeCharacteristic;
  BLECharacteristic *pEffectsCharacteristic;

  Application *app;
  bool deviceConnected;
  uint16_t connectionCount;

  // Data caching for notifications
  BLEPingData lastPingData;

  // Timing
  uint32_t lastPingUpdate;

  void setupCharacteristics();
  void setupCallbacks();

  // Simplified characteristic callback handlers
  void handleModeWrite(BLECharacteristic *pCharacteristic);
  void handleEffectsWrite(BLECharacteristic *pCharacteristic);

  // Simplified data preparation methods
  BLEPingData preparePingData();
  BLEModeData prepareModeData();
  BLEEffectsData prepareEffectsData();
};

// BLE Server Callbacks
class TaillightBLEServerCallbacks : public BLEServerCallbacks
{
public:
  TaillightBLEServerCallbacks(BLEManager *manager);
  void onConnect(BLEServer *pServer) override;
  void onDisconnect(BLEServer *pServer) override;

private:
  BLEManager *bleManager;
};

// Generic BLE Characteristic Callbacks
class TaillightBLECharacteristicCallbacks : public BLECharacteristicCallbacks
{
public:
  TaillightBLECharacteristicCallbacks(BLEManager *manager, const String &charName);
  void onWrite(BLECharacteristic *pCharacteristic) override;
  void onRead(BLECharacteristic *pCharacteristic) override;

private:
  BLEManager *bleManager;
  String characteristicName;
};========
==== IO/Battery.cpp: ====
#include "Battery.h"
#include <driver/adc.h>
#include <esp_adc_cal.h>
#include <soc/adc_channel.h>

#define minVoltage 3.2f
#define maxVoltage 5.0f

const adc1_channel_t ADC_CHANNEL = ADC1_GPIO2_CHANNEL;

// ADC Configuration
const adc_atten_t ATTENUATION = ADC_ATTEN_DB_12;     // 11dB attenuation for full range
const adc_bits_width_t BIT_WIDTH = ADC_WIDTH_BIT_12; // 12-bit resolution

// ADC calibration characteristics
static esp_adc_cal_characteristics_t adc_chars;
static bool adc_initialized = false;

static float batteryVoltage = 1.0f;
static float batteryVoltageSmooth = 1.0f;

// Initialize ADC with calibration
void initADC()
{
  if (!adc_initialized)
  {
    // Configure ADC
    adc1_config_width(BIT_WIDTH);
    adc1_config_channel_atten(ADC_CHANNEL, ATTENUATION);

    // Characterize ADC for calibration
    esp_adc_cal_characterize(ADC_UNIT_1, ATTENUATION, BIT_WIDTH, 0, &adc_chars);

    adc_initialized = true;
  }
}

float batteryGetVoltage()
{
  return batteryVoltage;
}

float batteryGetVoltageSmooth()
{
  return batteryVoltageSmooth;
}

int batteryGetPercentage()
{
  float percentage = ((constrain(batteryVoltage, minVoltage, maxVoltage) - minVoltage) / (maxVoltage - minVoltage)) * 100.0f;

  return static_cast<int>(percentage);
}

int batteryGetPercentageSmooth()
{
  float percentage = ((constrain(batteryVoltageSmooth, minVoltage, maxVoltage) - minVoltage) / (maxVoltage - minVoltage)) * 100.0f;

  return static_cast<int>(percentage);
}

void batteryUpdate()
{
  // Initialize ADC if not already done
  initADC();

  int adcRaw = adc1_get_raw(ADC_CHANNEL);
  uint32_t adcVoltage_mV = esp_adc_cal_raw_to_voltage(adcRaw, &adc_chars);

  // Convert to volts
  float adcVoltage = adcVoltage_mV / 1000.0f;

  // adcVoltage += 0.029; // calibration

  batteryVoltage = adcVoltage * (BATTERY_SENSE_R1 + BATTERY_SENSE_R2) / BATTERY_SENSE_R2;

  // Apply smoothing filter
  if (batteryVoltageSmooth <= 1.0f)
  {
    batteryVoltageSmooth = batteryVoltage;
  }
  else
  {
    batteryVoltageSmooth = batteryVoltageSmooth * 0.9 + batteryVoltage * 0.1;
  }
}========
==== IO/Battery.h: ====
#pragma once

#include "config.h"
#include "IO/GPIO.h"

#define BATTERY_SENSE_R1 10000 // 10k
#define BATTERY_SENSE_R2 1000  // 1k

extern float batteryGetVoltage();
extern float batteryGetVoltageSmooth();
extern int batteryGetPercentage();
extern int batteryGetPercentageSmooth();
extern void batteryUpdate();========
==== IO/Display.cpp: ====
#include "Display.h"
#include "Wireless.h"
#include "TimeProfiler.h"

Display::Display()
{
}

void Display::init(void)
{
  Serial.println("\t[INFO] [Display] Initializing...");
  u8g2.begin();
  u8g2.setBusClock(1600000);

  Serial.println("\t[INFO] [Display] Initialized");
}

void Display::drawCenteredText(uint8_t y, String text)
{
  u8g2.drawStr((DISPLAY_WIDTH - u8g2.getStrWidth(text.c_str())) / 2, y, text.c_str());
}

int Display::getCustomIconX(int width)
{
  int iconX;

  if (isFirstIcon)
  {
    // First icon position is next to WiFi icon
    u8g2.setFont(u8g2_font_koleeko_tf);
    char buffer[32];
    sprintf(buffer, "%d%%%", batteryGetPercentageSmooth());
    int battW = u8g2.getStrWidth(buffer);

    // Position is DISPLAY_WIDTH - battW - 2 - 8 - 2 - width
    // (screen width - battery text width - space - wifi icon width - space - icon width)
    iconX = DISPLAY_WIDTH - battW - 2 - 8 - 2 - width;

    isFirstIcon = false;
  }
  else
  {
    // Subsequent icons are positioned to the left of the previous icon
    iconX = lastIconX - 2 - width; // 2 pixels spacing between icons
  }

  // Update last icon position for next call
  lastIconX = iconX;

  return iconX;
}

void Display::resetCustomIconPosition()
{
  isFirstIcon = true;
  lastIconX = 0;
}

void Display::drawTopBar(void)
{
  u8g2.setFont(u8g2_font_koleeko_tf);
  u8g2.setDrawColor(1);

  if (screenManager.getCurrentScreen())
    u8g2.drawStr(0, 9, screenManager.getCurrentScreen()->topBarText.c_str());
  else
    u8g2.drawStr(0, 9, "Unknown");

  u8g2.drawLine(0, 10, DISPLAY_WIDTH, 10);

  char buffer[32];

  sprintf(buffer, "%.1fV", batteryGetVoltageSmooth());

  u8g2.setFont(u8g2_font_koleeko_tf);
  int battW = u8g2.getStrWidth(buffer);
  u8g2.drawStr(DISPLAY_WIDTH - battW, 9, buffer);

  u8g2.setFont(u8g2_font_open_iconic_all_1x_t);
  if (WiFi.status() == WL_CONNECTED)
    u8g2.drawGlyph(DISPLAY_WIDTH - 8 - battW - 2, 9, 0x00f8); // wifi icon
  else if (wireless.isSetupDone())
    u8g2.drawGlyph(DISPLAY_WIDTH - 8 - battW - 2, 9, 0x00c6); // link icon
  else
    u8g2.drawGlyph(DISPLAY_WIDTH - 8 - battW - 2, 9, 0x0079); // x icon

  // Reset custom icon positions for the next frame
  resetCustomIconPosition();
}

void Display::noTopBar()
{
  _noTopBar = true;
}

void Display::display(void)
{
  timeProfiler.increment("displayFps");
  timeProfiler.start("display", TimeUnit::MICROSECONDS);

  // u8g2.firstPage();
  // do
  // {
  //   screenManager.draw();
  //   if (!_noTopBar)
  //     drawTopBar();
  // } while (u8g2.nextPage());

  timeProfiler.start("clearBuffer", TimeUnit::MICROSECONDS);
  u8g2.clearBuffer(); // Clear the internal buffer
  timeProfiler.stop("clearBuffer");

  timeProfiler.start("screenManagerDraw", TimeUnit::MICROSECONDS);
  screenManager.draw();
  timeProfiler.stop("screenManagerDraw");

  timeProfiler.start("drawTopBar", TimeUnit::MICROSECONDS);
  if (!_noTopBar)
    drawTopBar();
  timeProfiler.stop("drawTopBar");

  // Check and draw notification if active
  if (isNotificationActive())
  {
    timeProfiler.start("drawNotification", TimeUnit::MICROSECONDS);
    drawNotification();
    timeProfiler.stop("drawNotification");
  }

  timeProfiler.start("sendBuffer", TimeUnit::MILLISECONDS);
  u8g2.sendBuffer();
  timeProfiler.stop("sendBuffer");

  timeProfiler.start("screenUpdate", TimeUnit::MICROSECONDS);
  screenManager.update();
  timeProfiler.stop("screenUpdate");

  timeProfiler.stop("display");

  _noTopBar = false;
}

// Notification system implementation
void Display::showNotification(String message, uint32_t durationMs)
{
  notificationMessage = message;
  notificationStartTime = millis();
  notificationDuration = durationMs;
  notificationActive = true;
}

void Display::hideNotification()
{
  notificationActive = false;
  notificationMessage = "";
}

bool Display::isNotificationActive()
{
  if (!notificationActive)
    return false;

  // Check if notification has expired
  if (millis() - notificationStartTime >= notificationDuration)
  {
    hideNotification();
    return false;
  }

  return true;
}

void Display::drawNotification()
{
  if (!isNotificationActive() || notificationMessage.length() == 0)
    return;

  u8g2.setFont(u8g2_font_6x10_tf);

  // Calculate text dimensions
  int textWidth = u8g2.getStrWidth(notificationMessage.c_str());
  int textHeight = 8; // Font height for u8g2_font_6x10_tf

  // Calculate notification box dimensions and position
  int boxWidth = textWidth + 8;   // 4px padding on each side
  int boxHeight = textHeight + 6; // 3px padding top and bottom
  int boxX = (DISPLAY_WIDTH - boxWidth) / 2;
  int boxY = (DISPLAY_HEIGHT - boxHeight) / 2;

  // Draw notification background (inverted box)
  u8g2.setDrawColor(1);
  u8g2.drawBox(boxX, boxY, boxWidth, boxHeight);

  // Draw notification border
  u8g2.drawFrame(boxX - 1, boxY - 1, boxWidth + 2, boxHeight + 2);

  // Draw notification text (inverted color)
  u8g2.setDrawColor(0);
  u8g2.drawStr(boxX + 4, boxY + textHeight + 1, notificationMessage.c_str());

  // Reset draw color
  u8g2.setDrawColor(1);
}

Display display;========
==== IO/Display.h: ====
#pragma once

#include "config.h"
#include <U8g2lib.h>
#include "IO/Battery.h"

#include "IO/ScreenManager.h"

#define DISPLAY_WIDTH 128
#define DISPLAY_HEIGHT 64

class Display
{
private:
  bool _noTopBar = false;

  // Variables to track custom icon positions in the top bar
  int lastIconX = 0;
  bool isFirstIcon = true;

  // Notification system
  String notificationMessage = "";
  uint64_t notificationStartTime = 0;
  uint32_t notificationDuration = 0;
  bool notificationActive = false;

public:
  U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2 = U8G2_SH1106_128X64_NONAME_F_HW_I2C(U8G2_R0, U8X8_PIN_NONE);
  // U8G2_SSD1309_128X64_NONAME0_F_HW_I2C u8g2 = U8G2_SSD1309_128X64_NONAME0_F_HW_I2C(U8G2_R0, U8X8_PIN_NONE);

  Display();

  void init(void);

  void drawCenteredText(uint8_t y, String text);

  void drawTopBar(void);
  void noTopBar(void);
  void display(void);

  // Notification system
  void showNotification(String message, uint32_t durationMs = 2000);
  void hideNotification();
  bool isNotificationActive();
  void drawNotification();

  // Get X position for placing custom icons in the top bar
  int getCustomIconX(int width);

  // Reset custom icon positioning (call this before drawing a new frame if you want to reset positions)
  void resetCustomIconPosition();
};

// class Screen
// {
// public:
//   String name;
//   String topBarText;

//   /**
//    * @brief Constructs a new Screen object with the specified name.
//    *
//    * @param _name The name of the screen.
//    */
//   Screen(String _name);
//   Screen(String _name, String _topBarText);

//   void setTopBarText(String _text);

//   /**
//    * @brief Draws the screen.
//    */
//   virtual void draw();

//   /**
//    * @brief Updates the screen.
//    */
//   virtual void update();

//   /**
//    * @brief Called when the screen is entered.
//    */
//   virtual void onEnter();

//   /**
//    * @brief Called when the screen is exited.
//    */
//   virtual void onExit();
// };

extern Display display;========
==== IO/GPIO.cpp: ====
#include "GPIO.h"

#ifdef S3_V1
GpIO btnBoot(INPUT_BTN_BOOT_PIN, InputPullup, LOW);
GpIO btnPrev(INPUT_BTN_PREV_PIN, InputPullup, LOW);
GpIO btnSel(INPUT_BTN_SEL_PIN, InputPullup, LOW);
GpIO btnNext(INPUT_BTN_NEXT_PIN, InputPullup, LOW);

GpIO voltage(INPUT_VOLTAGE_PIN, Input);
#endif

#ifdef ENABLE_HV_INPUTS
GpIO input1(INPUT_1_PIN, Input);
GpIO input2(INPUT_2_PIN, Input);
GpIO input3(INPUT_3_PIN, Input);
GpIO input4(INPUT_4_PIN, Input);
GpIO input5(INPUT_5_PIN, Input);
GpIO input6(INPUT_6_PIN, Input);
GpIO input7(INPUT_7_PIN, Input);
GpIO input8(INPUT_8_PIN, Input);
#endif

ClickButton BtnBoot(INPUT_BTN_BOOT_PIN, LOW);
ClickButton BtnPrev(INPUT_BTN_PREV_PIN, LOW);
ClickButton BtnSel(INPUT_BTN_SEL_PIN, LOW);
ClickButton BtnNext(INPUT_BTN_NEXT_PIN, LOW);

String GpIO::PinModeString(PinMode mode)
{
  switch (mode)
  {
  case Input:
    return "Input";
  case Output:
    return "Output";
  case InputPullup:
    return "InputPullup";
  default:
    return "Unknown";
  }
}

GpIO::GpIO()
{
  pin = -1;
  mode = Input;
  activeState = HIGH;
}

GpIO::GpIO(uint8_t _pin, PinMode _mode)
{
  pin = _pin;
  mode = _mode;
  activeState = HIGH;

  debounceEnabled = false;
  debounceTime = 0;
  lastDebounceTime = 0;
  lastStableValue = digitalRead(pin);
  lastReadValue = lastStableValue;
}

GpIO::GpIO(uint8_t _pin, PinMode _mode, bool _activeState)
{
  pin = _pin;
  mode = _mode;
  activeState = _activeState;

  debounceEnabled = false;
  debounceTime = 0;
  lastDebounceTime = 0;
  lastStableValue = digitalRead(pin);
  lastReadValue = lastStableValue;
}

void GpIO::init()
{
  Serial.println("\t[GPIO] " + String(pin) + " as " + PinModeString(mode) + " Initializing...");
  pinMode(pin, mode);

  if (mode == Output)
    digitalWrite(pin, !activeState);
}

void GpIO::SetMode(PinMode _mode)
{
  mode = _mode;
  pinMode(pin, mode);
}

void GpIO::setActive(bool _activeState)
{
  activeState = _activeState;
}

void GpIO::Write(bool _value)
{
  if (mode == Input)
    return;
  digitalWrite(pin, _value ^ !activeState);
}

void GpIO::PWM(uint8_t _value)
{
  if (mode == Input)
    return;
  analogWrite(pin, _value);
}

bool GpIO::read()
{
  if (debounceEnabled)
  {
    bool currentValue = digitalRead(pin);
    if (currentValue != lastReadValue)
    {
      lastDebounceTime = millis();
      lastReadValue = currentValue;
    }

    if ((millis() - lastDebounceTime) > debounceTime)
    {
      if (lastStableValue != lastReadValue)
      {
        lastStableValue = lastReadValue;
      }
    }

    return lastStableValue == activeState;
  }
  else
  {
    return digitalRead(pin) == activeState;
  }
}

int GpIO::analogRead()
{
  return ::analogRead(pin);
}

void GpIO::Toggle()
{
  if (mode == Input)
    return;
  digitalWrite(pin, !digitalRead(pin));
}

void GpIO::On()
{
  if (mode == Input)
    return;
  digitalWrite(pin, activeState);
}

void GpIO::Off()
{
  if (mode == Input)
    return;
  digitalWrite(pin, !activeState);
}

void GpIO::enableDebounce(unsigned long _debounceTime)
{
  debounceEnabled = true;
  debounceTime = _debounceTime;
  lastDebounceTime = millis();
  lastStableValue = digitalRead(pin);
  lastReadValue = lastStableValue;
}

uint8_t GpIO::getPin()
{
  return pin;
}

PinMode GpIO::getMode()
{
  return mode;
}

void GpIO::initIO()
{
  Serial.println("\t[INFO] [IO] Configuring pins...");

#ifdef S3_V1
  btnBoot.init();
  btnBoot.enableDebounce(50);
  btnPrev.init();
  btnPrev.enableDebounce(50);
  btnSel.init();
  btnSel.enableDebounce(50);
  btnNext.init();
  btnNext.enableDebounce(50);

  BtnBoot.debounceTime = 20;
  BtnBoot.multiclickTime = 100;
  BtnBoot.longClickTime = 300;
  BtnPrev.debounceTime = 20;
  BtnPrev.multiclickTime = 100;
  BtnPrev.longClickTime = 300;
  BtnSel.debounceTime = 20;
  BtnSel.multiclickTime = 100;
  BtnSel.longClickTime = 300;
  BtnNext.debounceTime = 20;
  BtnNext.multiclickTime = 100;
  BtnNext.longClickTime = 300;

  voltage.init();
#endif

#ifdef ENABLE_HV_INPUTS
  input1.init();
  input2.init();
  input3.init();
  input4.init();
  input5.init();
  input6.init();
  input7.init();
  input8.init();
#endif

  Serial.println("\t[INFO] [IO] Pins configured.");
  Serial.println();
}
========
==== IO/GPIO.h: ====
#pragma once
#include "config.h"
#include "ClickButton.h"

class GpIO;

extern GpIO btnBoot;
extern GpIO btnPrev;
extern GpIO btnSel;
extern GpIO btnNext;

extern GpIO voltage;

extern GpIO input1;
extern GpIO input2;
extern GpIO input3;
extern GpIO input4;
extern GpIO input5;
extern GpIO input6;
extern GpIO input7;
extern GpIO input8;

extern ClickButton BtnBoot;
extern ClickButton BtnPrev;
extern ClickButton BtnSel;
extern ClickButton BtnNext;

enum PinMode
{
  Input = INPUT,
  Output = OUTPUT,
  InputPullup = INPUT_PULLUP
};

class GpIO
{
private:
  uint8_t pin;
  PinMode mode;
  bool activeState;

  bool debounceEnabled;
  unsigned long debounceTime;
  unsigned long lastDebounceTime;
  bool lastStableValue;
  bool lastReadValue;

  String PinModeString(PinMode mode);

public:
  GpIO();
  GpIO(uint8_t _pin, PinMode _mode);
  GpIO(uint8_t _pin, PinMode _mode, bool _activeState);

  void init();

  void SetMode(PinMode _mode);
  void setActive(bool _activeState);

  void Write(bool _value);
  void PWM(uint8_t _value);

  bool read();
  int analogRead();

  void Toggle();
  void On();
  void Off();

  void enableDebounce(unsigned long debounceTime);

  uint8_t getPin();
  PinMode getMode();

  static void initIO();
};========
==== IO/Inputs.cpp: ====
#include "Inputs.h"
#include <Arduino.h>

HVInput::HVInput()
{
  _gpio = nullptr;
  _activeState = HV_HIGH_ACTIVE;
  _threshold = 0.0f;
  _debounceTime = 0.0f;

  _state = !_activeState;
  _lastState = _state;
  _debouncedState = _state;
  _lastRawState = _state;
  _voltage = 0.0f;
  _lastActiveTime = 0;
  _lastDebounceTime = 0;

  _enabled = false;
  _override = false;
  _overrideState = false;

  // Initialize optimization members
  _rawAdcValue = 0;
  _rawThreshold = 0;
}

HVInput::HVInput(GpIO *gpio, bool activeState, float threshold, float debounceTime)
    : _gpio(gpio), _activeState(activeState), _threshold(threshold), _debounceTime(debounceTime)
{
  _state = !_activeState;
  _lastState = _state;
  _debouncedState = _state;
  _lastRawState = _state;
  _voltage = 0.0f;
  _lastActiveTime = 0;
  _lastDebounceTime = 0;

  _enabled = true;
  _override = false;
  _overrideState = false;

  // Initialize optimization members
  _rawAdcValue = 0;
  _rawThreshold = 0;
  _calculateRawThreshold();

  // Initialize the raw ADC value if GPIO is available
  if (_gpio)
  {
    _rawAdcValue = _gpio->analogRead();
  }
}

void HVInput::_calculateRawThreshold()
{
  // Pre-calculate the threshold as a raw ADC value to avoid float calculations in update()
  // Formula: threshold_adc = (V_thresh / (V_ref * Divider)) * ADC_MAX
  _rawThreshold = (int32_t)((_threshold / (ADC_REF_VOLTAGE * DIVIDER_FACTOR)) * ADC_MAX_INT);
}

void HVInput::enable()
{
  _enabled = true;
}

void HVInput::disable()
{
  _enabled = false;
}

bool HVInput::isEnabled()
{
  return _enabled;
}

void HVInput::update()
{
  if (_override)
  {
    _lastState = _state;
    _state = _overrideState;

    if (_state == _activeState)
    {
      _lastActiveTime = millis();
    }
    return;
  }

  if (!_enabled)
    return;

  if (!_gpio)
    return;

  // 1. Read the raw ADC value (this is still the main time cost)
  int32_t newRawAdc = _gpio->analogRead();

  // 2. Apply smoothing using fast integer math
  // This is an integer-based Exponential Moving Average (EMA)
  // new_value = old_value - (old_value / N) + (new_sample / N)
  _rawAdcValue = _rawAdcValue - (_rawAdcValue / SMOOTHING_FACTOR) + (newRawAdc / SMOOTHING_FACTOR);

  // 3. Compare raw integer values - this is extremely fast
  _lastState = _state;
  bool rawState = _rawAdcValue > _rawThreshold;

  // If debouncing is disabled (debounce time is 0), use raw state directly
  if (_debounceTime <= 0)
  {
    _state = rawState;
    _debouncedState = rawState;
  }
  else
  {
    // Debouncing logic - cache millis() call for efficiency
    uint64_t currentTime = millis();

    // If the raw state has changed from the last raw state, reset the debounce timer
    if (rawState != _lastRawState)
    {
      _lastDebounceTime = currentTime;
      _lastRawState = rawState;
    }

    // If enough time has passed, update the debounced state
    if ((currentTime - _lastDebounceTime) >= _debounceTime)
    {
      _debouncedState = rawState;
    }

    _state = _debouncedState;
  }

  // Update last active time if we're in active state
  if (_state == _activeState)
  {
    _lastActiveTime = millis();
  }
}

float HVInput::getVoltage()
{
  // Calculate voltage on-demand from the smoothed raw ADC value
  // This avoids floating-point math in the critical update() path
  return ((float)_rawAdcValue / (float)ADC_MAX_INT) * ADC_REF_VOLTAGE * DIVIDER_FACTOR;
}

bool HVInput::get()
{
  return _state == _activeState;
}

bool HVInput::getLast()
{
  return _lastState == _activeState;
}

bool HVInput::isActiveFor(uint64_t duration)
{
  if (!get())
    return false;

  uint64_t currentTime = millis();
  return (currentTime - _lastActiveTime) >= duration;
}

void HVInput::setLastActiveTime(uint64_t time)
{
  _lastActiveTime = time;
}

uint64_t HVInput::getLastActiveTime()
{
  return _lastActiveTime;
}

void HVInput::override(bool state)
{
  _override = true;
  _overrideState = state;
}

void HVInput::clearOverride()
{
  _override = false;
}

bool HVInput::isOverride()
{
  return _override;
}========
==== IO/Inputs.h: ====
#pragma once

#include "config.h"

#define HV_HIGH_ACTIVE true
#define HV_LOW_ACTIVE false

class HVInput
{
  static constexpr float DEFAULT_SMOOTH_FACTOR = 0.5f;
  static constexpr float ADC_MAX = 4095;
  static constexpr float ADC_REF_VOLTAGE = 3.3;
  static constexpr float DIVIDER_FACTOR = 11.0;
  static constexpr float DEFAULT_VOLTAGE_THRESHOLD = 3;

  static constexpr float DEFAULT_DEBOUNCE_TIME = 20;

  // --- OPTIMIZATION CONSTANTS ---
  // Integer-based smoothing factor. Using power of 2 for fast bit-shift operations
  // A factor of 8 means we keep 7/8 of the old value and add 1/8 of the new one
  static constexpr int32_t SMOOTHING_FACTOR = 8;
  static constexpr int32_t ADC_MAX_INT = 4095;

private:
  bool _enabled;

  GpIO *_gpio;
  bool _state;
  bool _activeState;
  bool _debouncedState;
  bool _lastState;
  bool _lastRawState;
  float _voltage; // Keep for backward compatibility, but calculate on-demand
  float _threshold;
  uint64_t _lastDebounceTime;

  uint64_t _lastActiveTime;
  float _debounceTime;

  bool _override;
  bool _overrideState;

  // --- OPTIMIZATION MEMBERS ---
  // Raw ADC values for integer-based processing
  int32_t _rawAdcValue;
  int32_t _rawThreshold;

public:
  HVInput();
  HVInput(GpIO *gpio, bool activeState, float threshold = DEFAULT_VOLTAGE_THRESHOLD, float debounceTime = DEFAULT_DEBOUNCE_TIME);
  void enable();
  void disable();
  bool isEnabled();

  void update();
  float getVoltage(); // Now calculates voltage on-demand from raw ADC value
  bool get();
  bool getLast();
  bool isActiveFor(uint64_t duration);
  void setLastActiveTime(uint64_t time);
  uint64_t getLastActiveTime();

  void override(bool state);
  void clearOverride();
  bool isOverride();

private:
  // Helper function to calculate raw threshold from voltage threshold
  void _calculateRawThreshold();
};========
==== IO/LED/Effects.cpp: ====
#include "Effects.h"
#include <Arduino.h> // For millis()

//
// LEDEffect Base Class Implementation
//
LEDEffect::LEDEffect(uint8_t priority, bool transparent)
    : priority(priority), transparent(transparent)
{

    effects.push_back(this);
}

LEDEffect::~LEDEffect() {}

uint8_t LEDEffect::getPriority() const { return priority; }
bool LEDEffect::isTransparent() const { return transparent; }
void LEDEffect::setPriority(uint8_t prio) { priority = prio; }
void LEDEffect::setTransparent(bool transp) { transparent = transp; }

std::vector<LEDEffect *> LEDEffect::effects = {};

std::vector<LEDEffect *> LEDEffect::getEffects() { return effects; }
void LEDEffect::disableAllEffects()
{
    for (auto effect : effects)
    {
        effect->onDisable();
    }
}
========
==== IO/LED/Effects.h: ====
#pragma once

#include "LEDStrip.h"
#include <stdint.h>
#include "Sync/SyncManager.h"

struct Color;
class LEDStrip;

// Base class for LED effects.
class LEDEffect
{
public:
  // Each effect has a priority and may be "transparent" so that lower layers show
  LEDEffect(uint8_t priority = 0, bool transparent = false);
  virtual ~LEDEffect();

  // Called each update to change animation state.
  virtual void update(LEDStrip *strip) = 0;

  // Called to render the effect into the provided LED buffer.
  virtual void render(LEDStrip *strip, Color *buffer) = 0;

  virtual void onDisable() = 0;

  uint8_t getPriority() const;
  bool isTransparent() const;
  void setPriority(uint8_t priority);
  void setTransparent(bool transparent);

  static std::vector<LEDEffect *> getEffects();
  static void disableAllEffects();

protected:
  uint8_t priority;
  bool transparent;

private:
  static std::vector<LEDEffect *> effects;
};========
==== IO/LED/Effects/AuroraEffect.cpp: ====
#include "AuroraEffect.h"
#include <cmath>
#include <Arduino.h>
#include "../LEDStrip.h"

AuroraEffect::AuroraEffect(uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      active(false),
      lastUpdateTime(0),
      time(0.0f),
      movementSpeed(0.2f),
      waveIntensity(0.6f),
      intensity(0.85f),
      minHue(140.0f),
      maxHue(270.0f),
      saturationMin(0.7f),
      saturationMax(1.0f)
{

  phaseOffsets[0] = 0.0f;
  amplitudes[0] = 1.0f;
  frequencies[0] = 1.5f;
  hues[0] = 160.0f; // Green-blue

  // Second wave - slower, wider movements
  phaseOffsets[1] = 2.1f;
  amplitudes[1] = 0.7f;
  frequencies[1] = 0.8f;
  hues[1] = 200.0f; // Blue

  // Third wave - fast, subtle detail
  phaseOffsets[2] = 4.2f;
  amplitudes[2] = 0.4f;
  frequencies[2] = 3.0f;
  hues[2] = 240.0f; // Purple-blue
}

void AuroraEffect::setActive(bool _active)
{
  active = _active;
  if (active && lastUpdateTime == 0)
  {
    lastUpdateTime = millis();

    // Randomize phase offsets when activating for variety
    for (int i = 0; i < NUM_WAVES; i++)
    {
      phaseOffsets[i] = random(0, 1000) / 100.0f;
    }
  }
}

bool AuroraEffect::isActive() const
{
  return active;
}

float AuroraEffect::computeWave(float pos, float time, int waveIndex)
{
  // Different wave patterns for each component to create organic movement
  switch (waveIndex)
  {
  case 0:
    // Main sine wave
    return amplitudes[waveIndex] * 0.5f * (1.0f + sinf(2.0f * PI * (frequencies[waveIndex] * pos + time + phaseOffsets[waveIndex])));

  case 1:
    // Secondary wave with more complex shape (composite of two sine waves)
    return amplitudes[waveIndex] * 0.5f * (sinf(2.0f * PI * (frequencies[waveIndex] * pos + time * 0.7f + phaseOffsets[waveIndex])) + 0.3f * sinf(2.0f * PI * (frequencies[waveIndex] * 3 * pos + time * 1.3f)));

  case 2:
    // Fast subtle details using a different function
    return amplitudes[waveIndex] * 0.5f * (1.0f + sinf(2.0f * PI * (frequencies[waveIndex] * pos + time * 1.5f + phaseOffsets[waveIndex] + pos * 3.0f)));

  default:
    return 0.0f;
  }
}

void AuroraEffect::update(LEDStrip *strip)
{
  if (!active)
    return;

  unsigned long currentTime = millis();
  if (lastUpdateTime == 0)
  {
    lastUpdateTime = currentTime;
    return;
  }

  // Calculate elapsed time in seconds
  unsigned long dtMillis = currentTime - lastUpdateTime;
  float dtSeconds = dtMillis / 1000.0f;
  lastUpdateTime = currentTime;

  // Update animation time
  time += movementSpeed * dtSeconds;

  // Periodically adjust the hues slightly to create color variation over time
  if (fmod(time, 10.0f) < 0.1f) // Every ~10 seconds
  {
    for (int i = 0; i < NUM_WAVES; i++)
    {
      // Slowly drift the hues within their color families
      hues[i] += (random(-10, 10) / 10.0f);

      // Keep hues within the desired range
      if (hues[i] < minHue)
        hues[i] = minHue;
      if (hues[i] > maxHue)
        hues[i] = maxHue;
    }
  }
}

void AuroraEffect::render(LEDStrip *strip, Color *buffer)
{
  if (!active)
    return;

  uint16_t numLEDs = strip->getNumLEDs();
  bool isHeadlight = (strip->getType() == LEDStripType::HEADLIGHT);
  uint16_t midPoint = numLEDs / 2;

  // For headlights, we'll only process the first half and mirror it
  uint16_t ledsToProcess = isHeadlight ? midPoint + (numLEDs % 2) : numLEDs;

  for (uint16_t i = 0; i < ledsToProcess; i++)
  {
    // Calculate normalized position [0, 1] along the strip
    float pos;

    if (isHeadlight)
    {
      // For headlights, calculate distance from center (0 at center, 1 at edge)
      pos = static_cast<float>(abs(midPoint - i)) / midPoint;
    }
    else
    {
      // For other strips, maintain original behavior
      pos = static_cast<float>(i) / (numLEDs - 1);
    }

    // Calculate the combined influence of the different wave components
    float totalWave = 0.0f;
    float maxPossibleValue = 0.0f;

    for (int w = 0; w < NUM_WAVES; w++)
    {
      totalWave += computeWave(pos, time, w);
      maxPossibleValue += amplitudes[w];
    }

    // Normalize the combined wave value
    float waveValue = totalWave / maxPossibleValue;

    // Apply the wave intensity parameter
    waveValue = waveValue * waveIntensity + (1.0f - waveIntensity) * 0.5f;

    // Determine which color component is most dominant at this position
    int dominantWave = 0;
    float maxWaveValue = 0.0f;

    for (int w = 0; w < NUM_WAVES; w++)
    {
      float value = computeWave(pos, time, w);
      if (value > maxWaveValue)
      {
        maxWaveValue = value;
        dominantWave = w;
      }
    }

    // Get the hue from the dominant wave
    float hue = hues[dominantWave];

    // Vary saturation based on wave intensity
    float saturation = saturationMin + (saturationMax - saturationMin) * waveValue;

    // Vary brightness based on wave value (brighter at peaks)
    float brightness = waveValue * intensity;

    // Create the color
    Color color = Color::hsv2rgb(hue, saturation, brightness);

    // Apply to buffer
    buffer[i] = color;

    // For headlights, mirror to the other side
    if (isHeadlight && i != midPoint)
    { // Skip mirroring the center LED
      uint16_t mirrorIndex = numLEDs - i - 1;
      buffer[mirrorIndex] = color;
    }
  }
}

void AuroraEffect::onDisable()
{
  active = false;
}========
==== IO/LED/Effects/AuroraEffect.h: ====
#pragma once

#include "../Effects.h"
#include <stdint.h>

class AuroraEffect : public LEDEffect
{
public:
  // Constructs the Aurora Borealis effect
  AuroraEffect(uint8_t priority = 0, bool transparent = false);

  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;

  // Activate or disable the effect
  void setActive(bool active);
  bool isActive() const;

  // Customizable parameters
  float movementSpeed; // Speed of movement in cycles per second
  float waveIntensity; // Intensity of the wave motion
  float intensity;     // Maximum brightness (0.0-1.0)

  // Color range control
  float minHue;        // Minimum hue value (default: green-blue range)
  float maxHue;        // Maximum hue value
  float saturationMin; // Minimum saturation
  float saturationMax; // Maximum saturation

private:
  bool active;

  // Time tracking
  unsigned long lastUpdateTime;

  // Animation state variables
  float time; // Accumulated time for animation

  // Wave phase offsets for each component
  static const int NUM_WAVES = 3;
  float phaseOffsets[NUM_WAVES];
  float amplitudes[NUM_WAVES];
  float frequencies[NUM_WAVES];
  float hues[NUM_WAVES];

  // Helper function to compute a smooth, organic-looking wave
  float computeWave(float pos, float time, int waveIndex);
};========
==== IO/LED/Effects/BrakeLightEffect.cpp: ====
#include "BrakeLightEffect.h"
#include <cmath>

// Ease‑in quadratic: f(t) = t².
// (Since fadeProgress changes from 1 to 0, this curve makes the brightness drop quickly at
// the beginning; when fadeProgress reaches 0, the brightness is off.)
static inline float easeInQuadratic(float t)
{
  return t * t;
}

BrakeLightEffect::BrakeLightEffect(uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      lastUpdate(0),
      brakeActive(false),
      // When active, fadeProgress is 1. When brakes are released it counts down.
      fadeProgress(1.0f),
      // Full brightness when braking; when released this is immediately set to 0.3.
      baseBrightness(0.0f),
      // Fade-out duration in seconds (adjust as needed).
      fadeDuration(0.6f)
{
}

//
// IMPORTANT: Only update state when the brake state actually changes.
// If setActive(false) is called each frame, the fade will never progress!
//
void BrakeLightEffect::setActive(bool active)
{
  // Only update if the state is changing.
  if (active == brakeActive)
  {
    return;
  }

  brakeActive = active;

  if (brakeActive)
  {
    // When brakes are pressed: full brightness.
    baseBrightness = 1.0f;
    fadeProgress = 1.0f;
  }
  else
  {
    // When brakes are released: drop base brightness immediately to 0.3
    // and start the fade (fadeProgress counts down from 1 to 0).
    baseBrightness = 0.4f;
    fadeProgress = 1.0f;
  }
}

bool BrakeLightEffect::isActive() const
{
  return brakeActive;
}

void BrakeLightEffect::setIsReversing(bool reversing)
{
  isReversing = reversing;
}

bool BrakeLightEffect::getIsReversing() const
{
  return isReversing;
}

void BrakeLightEffect::update(LEDStrip *strip)
{
  unsigned long currentTime = millis();
  if (lastUpdate == 0)
  {
    lastUpdate = currentTime;
    return;
  }

  // Compute elapsed time in seconds.
  unsigned long dtMillis = currentTime - lastUpdate;
  float dtSeconds = dtMillis / 1000.0f;
  lastUpdate = currentTime;

  if (!brakeActive)
  {
    // Decrease fadeProgress linearly over fadeDuration seconds.
    fadeProgress -= dtSeconds / fadeDuration;
    if (fadeProgress < 0.0f)
    {
      fadeProgress = 0.0f;
    }
  }
  else
  {
    // When brakes are pressed, keep fadeProgress at full.
    fadeProgress = 1.0f;
  }
}

void BrakeLightEffect::render(LEDStrip *strip, Color *buffer)
{

  if (isReversing)
  {
    if (brakeActive)
    {
      int numLeds = strip->getNumLEDs() / 5;

      for (uint16_t i = 0; i < numLeds; i++)
      {
        buffer[i] = Color(255, 0, 0);
        buffer[strip->getNumLEDs() - i - 1] = Color(255, 0, 0);
      }
    }

    return;
  }

  if (brakeActive)
  {
    for (uint16_t i = 0; i < strip->getNumLEDs(); i++)
    {
      buffer[i] = Color(255, 0, 0);
    }

    return;
  }

  if (fadeProgress <= 0.0f)
  {
    return;
  }

  // if reversing only light up the edges

  uint16_t numLEDs = strip->getNumLEDs();
  uint16_t mid = numLEDs / 2;

  // Compute the fade factor using the ease‑in quadratic curve.
  float fadeFactor = easeInQuadratic(fadeProgress);
  // Overall brightness is the base brightness (1.0 when braking, 0.3 when released)
  // scaled by the fade factor.
  float overallBrightness = baseBrightness * fadeFactor;

  // Spatial fading: LEDs farther from the center fade faster.
  // Adjust spatialExponent to change how aggressively the fade is applied.
  constexpr float spatialExponent = 2.0f;

  for (uint16_t i = 0; i < numLEDs; i++)
  {
    // Calculate the normalized distance from the center (0 at center, 1 at edge).
    float normDist = (mid > 0)
                         ? fabs(static_cast<float>(i) - mid) / mid
                         : 0.0f;
    // The spatial factor lowers brightness for LEDs farther from the center.
    // changing the exponent will change how aggressively the fade is applied for.
    float spatialFactor = pow(1.0f - normDist, spatialExponent);

    // Final LED brightness is the product of overall brightness and spatial factor.
    float ledBrightness = overallBrightness * spatialFactor;

    uint8_t redVal = static_cast<uint8_t>(255 * ledBrightness);
    if (redVal > 10)
      buffer[i] = Color(redVal, 0, 0);
  }
}

void BrakeLightEffect::onDisable()
{
  brakeActive = false;
}========
==== IO/LED/Effects/BrakeLightEffect.h: ====
#pragma once

#include "../Effects.h"
#include <stdint.h>

class BrakeLightEffect : public LEDEffect
{
public:
  // Constructs a brake light effect for a given number of LEDs.
  BrakeLightEffect(uint8_t priority = 0, bool transparent = false);
  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;

  // Set whether the brakes are active.
  void setActive(bool active);
  bool isActive() const;
  void setIsReversing(bool reversing);
  bool getIsReversing() const;

private:
  unsigned long lastUpdate;

  bool brakeActive;
  bool isReversing;

  float fadeProgress;
  float baseBrightness;
  float fadeDuration;
};
========
==== IO/LED/Effects/ColorFadeEffect.cpp: ====
#include "ColorFadeEffect.h"
#include <cmath>

// Hardcoded color list - attractive color sequence
const Color ColorFadeEffect::colorList[] = {
    Color::RED,      // Red
    Color::ORANGE,   // Orange
    Color::YELLOW,   // Yellow
    Color::GREEN,    // Green
    Color::CYAN,     // Cyan
    Color::BLUE,     // Blue
    Color::MAGENTA,  // Magenta
    Color::WHITE     // White
};

const uint8_t ColorFadeEffect::numColors = sizeof(colorList) / sizeof(colorList[0]);

ColorFadeEffect::ColorFadeEffect(uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      active(false),
      holdTime(2.0f),    // Default: hold each color for 2 seconds
      fadeTime(1.0f),    // Default: fade over 1 second
      progress(0.0f),
      currentColorIndex(0),
      inFadePhase(false),
      lastUpdateTime(0)
{
}

void ColorFadeEffect::setActive(bool _active)
{
  active = _active;
  if (_active && lastUpdateTime == 0)
  {
    lastUpdateTime = SyncManager::syncMillis();
    progress = 0.0f;
    currentColorIndex = 0;
    inFadePhase = false;
  }
}

bool ColorFadeEffect::isActive() const
{
  return active;
}

void ColorFadeEffect::setSyncData(ColorFadeSyncData syncData)
{
  active = syncData.active;
  holdTime = syncData.holdTime;
  fadeTime = syncData.fadeTime;
  progress = syncData.progress;
  currentColorIndex = syncData.currentColorIndex;
  inFadePhase = syncData.inFadePhase;
  
  // Clamp currentColorIndex to valid range
  if (currentColorIndex >= numColors) {
    currentColorIndex = 0;
  }
}

ColorFadeSyncData ColorFadeEffect::getSyncData()
{
  ColorFadeSyncData syncData = {
      .active = active,
      .holdTime = holdTime,
      .fadeTime = fadeTime,
      .progress = progress,
      .currentColorIndex = currentColorIndex,
      .inFadePhase = inFadePhase
  };
  return syncData;
}

void ColorFadeEffect::update(LEDStrip *strip)
{
  // Return if the effect is not active
  if (!active)
    return;

  unsigned long currentTime = SyncManager::syncMillis();
  
  // Initialize last update time if needed
  if (lastUpdateTime == 0)
  {
    lastUpdateTime = currentTime;
    return;
  }

  // Calculate elapsed time in seconds
  unsigned long dtMillis = currentTime - lastUpdateTime;
  float dtSeconds = dtMillis / 1000.0f;
  lastUpdateTime = currentTime;

  // Update progress based on current phase
  float phaseTime = inFadePhase ? fadeTime : holdTime;
  
  if (phaseTime > 0.0f) {
    progress += dtSeconds / phaseTime;
  }

  // Check if we need to transition to the next phase
  if (progress >= 1.0f) {
    if (inFadePhase) {
      // Finished fading, move to next color and start holding
      currentColorIndex = getNextColorIndex();
      inFadePhase = false;
    } else {
      // Finished holding, start fading to next color
      inFadePhase = true;
    }
    progress = 0.0f;
  }
}

void ColorFadeEffect::render(LEDStrip *strip, Color *buffer)
{
  if (!active)
    return;

  uint16_t numLEDs = strip->getNumLEDs();
  Color currentColor;

  if (inFadePhase) {
    // We're fading between currentColorIndex and the next color
    uint8_t nextColorIndex = getNextColorIndex();
    currentColor = interpolateColors(colorList[currentColorIndex], colorList[nextColorIndex], progress);
  } else {
    // We're holding on the current color
    currentColor = colorList[currentColorIndex];
  }

  // Set all LEDs to the current color
  for (uint16_t i = 0; i < numLEDs; i++) {
    buffer[i] = currentColor;
  }
}

void ColorFadeEffect::onDisable()
{
  active = false;
}

Color ColorFadeEffect::interpolateColors(const Color& fromColor, const Color& toColor, float t)
{
  // Clamp t to [0, 1] range
  if (t < 0.0f) t = 0.0f;
  if (t > 1.0f) t = 1.0f;

  // Linear interpolation between colors
  uint8_t r = fromColor.r + (toColor.r - fromColor.r) * t;
  uint8_t g = fromColor.g + (toColor.g - fromColor.g) * t;
  uint8_t b = fromColor.b + (toColor.b - fromColor.b) * t;
  uint8_t w = fromColor.w + (toColor.w - fromColor.w) * t;

  return Color(r, g, b, w);
}

uint8_t ColorFadeEffect::getNextColorIndex()
{
  return (currentColorIndex + 1) % numColors;
}========
==== IO/LED/Effects/ColorFadeEffect.h: ====
#pragma once

#include "../Effects.h"
#include "../Types.h"
#include <stdint.h>

class ColorFadeEffect : public LEDEffect
{
public:
  // Constructs the ColorFade effect with default timing parameters
  ColorFadeEffect(uint8_t priority = 0, bool transparent = false);

  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;

  // Activate or disable the effect
  void setActive(bool active);
  bool isActive() const;

  // Sync data methods for network synchronization
  void setSyncData(ColorFadeSyncData syncData);
  ColorFadeSyncData getSyncData();

  // Customizable parameters
  float holdTime; // Time to hold each color (seconds)
  float fadeTime; // Time to fade between colors (seconds)

private:
  bool active;

  // Animation state
  float progress;            // Current progress through the cycle [0.0, 1.0]
  uint8_t currentColorIndex; // Index of the current color in the list
  bool inFadePhase;          // true if currently fading, false if holding

  // Timing
  unsigned long lastUpdateTime;

  // Hardcoded color list
  static const Color colorList[];
  static const uint8_t numColors;

  // Helper methods
  Color interpolateColors(const Color &fromColor, const Color &toColor, float t);
  uint8_t getNextColorIndex();
};========
==== IO/LED/Effects/HeadlightEffect.cpp: ====
#include "HeadlightEffect.h"
#include <cmath>
#include <Arduino.h> // For millis()

HeadlightEffect::HeadlightEffect(uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      mode(HeadlightEffectMode::Off),
      phase(-1),
      phase_start(0),
      T0(10.0f),          // 10 seconds for half brightness fill
      T1(0.2f),           // 0.2 seconds delay
      T2(1.0f),           // 1 second for full brightness fill
      T10(1.0f),          // 1 second for full brightness fill
      T20(1.0f),          // 1 second for full brightness fill
      T13(0.8f),          // 0.8 seconds for transition from full to split
      T14(0.8f),          // 0.8 seconds for transition from split to full
      headlight_size(32), // 10 LEDs from each edge by default
      ledsStepSize(2),    // Default to 1 LED at a time
      phase_0_progress(0.0f),
      phase_0_single_led_index(0),
      phase_0_single_led_progress(0.0f),
      phase_1_progress(0.0f),
      phase_2_progress(0.0f),
      phase_10_progress(0.0f),
      phase_20_progress(0.0f),
      phase_13_progress(0.0f),
      phase_14_progress(0.0f),
      red(false),
      blue(false),
      green(false),
      split(false),
      baseHueCenter(1.0f), // Default center hue is red.
      baseHueEdge(180.0f),
      hueCenter(0.0f), // Start with red
      hueEdge(240.0f), // End with blue
      hueOffset(0.0f),
      rainbowSpeed(120.0f),
      lastUpdate(0)
{
}

bool HeadlightEffect::isActive()
{
  // return active;
  return mode != HeadlightEffectMode::Off && phase != -1;
}

void HeadlightEffect::setOff()
{
  if (mode == HeadlightEffectMode::Off)
    return;

  if (mode == HeadlightEffectMode::CarOn)
  {
    phase = 20;
    phase_start = millis(); // Record the starting time (ms)
    phase_20_progress = 0.0f;
  }
  else
  {
    phase = -1;
    phase_start = 0;
  }
  mode = HeadlightEffectMode::Off;
}

void HeadlightEffect::setStartup()
{
  if (mode == HeadlightEffectMode::Startup)
    return;

  mode = HeadlightEffectMode::Startup;
  phase = 0;
  phase_start = millis(); // Record the starting time (ms)
  phase_0_progress = 0.0f;
  phase_0_single_led_index = 0;
  phase_0_single_led_progress = 0.0f;
  phase_0_start_single_led = 0;
  phase_1_progress = 0.0f;
  phase_2_progress = 0.0f;
}

void HeadlightEffect::setCarOn()
{
  if (mode == HeadlightEffectMode::CarOn)
    return;

  mode = HeadlightEffectMode::CarOn;
  phase = 10;
  phase_start = millis(); // Record the starting time (ms)
  phase_10_progress = 0.0f;
  phase_13_progress = 0.0f;
  phase_14_progress = 0.0f;
}

void HeadlightEffect::setMode(HeadlightEffectMode mode)
{
  if (this->mode == mode)
    return;

  this->mode = mode;
}

void HeadlightEffect::setMode(int mode)
{
  if (mode == 0)
    setOff();
  else if (mode == 1)
    setStartup();
  else if (mode == 2)
    setCarOn();
  else
    setOff();
}

HeadlightEffectMode HeadlightEffect::getMode()
{
  return mode;
}

void HeadlightEffect::setSplit(bool split)
{
  if (this->split == split)
    return;

  this->split = split;

  // If we're in CarOn mode and in steady states, transition between them
  if (mode == HeadlightEffectMode::CarOn)
  {
    if (phase >= 11 && phase <= 14)
    {
      if (split) // Transition from full strip to split mode
      {
        phase = 13;
        phase_start = millis();
        phase_13_progress = 0.0f;
      }
      else if (!split) // Transition from split mode to full strip
      {
        phase = 14;
        phase_start = millis();
        phase_14_progress = 0.0f;
      }
    }
  }
}

bool HeadlightEffect::getSplit()
{
  return split;
}

void HeadlightEffect::setColor(bool r, bool g, bool b)
{
  red = r;
  green = g;
  blue = b;
}

void HeadlightEffect::getColor(bool &r, bool &g, bool &b)
{
  r = red;
  g = green;
  b = blue;
}

void HeadlightEffect::update(LEDStrip *strip)
{
  // if (!active)
  if (mode == HeadlightEffectMode::Off && phase == -1)
    return;

  unsigned long now = millis();
  if (phase_start == 0)
    phase_start = now;

  uint16_t numLEDs = strip->getNumLEDs();
  uint16_t numLEDsHalf = numLEDs / 2;
  if (numLEDs % 2 == 1)
    numLEDsHalf += 1;
  uint16_t effective_size = std::min<uint16_t>(headlight_size, numLEDsHalf);

  // Convert elapsed time from milliseconds to seconds.
  float elapsed = (now - phase_start) / 1000.0f;

  unsigned long dtMillis = now - lastUpdate;
  float dtSeconds = dtMillis / 1000.0f;
  lastUpdate = now;

  // #########################################################
  // mode == HeadlightEffectMode::Startup
  // #########################################################

  if (phase == 0) // Phase 0: Filling from outside at half brightness
  {
    if (phase_0_start_single_led == 0)
    {
      phase_0_start_single_led = now;
    }

    float T0_perLed = T0 / effective_size;
    float elapsed_perLed = (now - phase_0_start_single_led) / 1000.0f;

    phase_0_progress = std::min(elapsed / T0, 1.0f); // probaly not needed
    phase_0_single_led_progress = std::min(elapsed_perLed / T0_perLed, 1.0f);

    int single_led_to_light = static_cast<float>(effective_size) * phase_0_single_led_progress;

    if (elapsed_perLed > T0_perLed || single_led_to_light >= (effective_size - phase_0_single_led_index) - ledsStepSize)
    {
      phase_0_single_led_index += ledsStepSize;
      phase_0_start_single_led = now;
    }

    if (elapsed > T0 || phase_0_single_led_index >= effective_size)
    {
      phase = 1;
      phase_start = now;
    }
  }
  else if (phase == 1) // Phase 1: Delay
  {
    phase_1_progress = std::min(elapsed / T1, 1.0f);

    if (elapsed > T1)
    {
      phase = 2;
      phase_start = now;
    }
  }
  else if (phase == 2) // Phase 2: Filling from outside at full brightness
  {
    phase_2_progress = std::min(elapsed / T2, 1.0f);

    if (elapsed > T2)
    {
      phase = 3;
      phase_start = now;
    }
  }
  else if (phase == 3) // Phase 3: Final phase - all LEDs at full brightness
  {
    // do nothing
  }

  // #########################################################
  // mode == HeadlightEffectMode::CarOn
  // #########################################################
  else if (phase == 10) // Phase 10: filling entire strip to full brightness
  {
    if (split)
    {
      phase = 12;
      phase_start = now;
    }

    phase_10_progress = std::min(elapsed / T10, 1.0f);

    if (elapsed > T10)
    {
      phase = 11;
      phase_start = now;
    }
  }
  else if (phase == 13) // Phase 13: Transition from full strip to split mode
  {
    phase_13_progress = std::min(elapsed / T13, 1.0f);

    if (elapsed > T13)
    {
      phase = 12;
      phase_start = now;
    }
  }
  else if (phase == 14) // Phase 14: Transition from split mode to full strip
  {
    phase_14_progress = std::min(elapsed / T14, 1.0f);

    if (elapsed > T14)
    {
      phase = 11;
      phase_start = now;
    }
  }

  // #########################################################
  // mode == HeadlightEffectMode::TurningOff
  // #########################################################
  else if (phase == 20) // Phase 20: fade full white strip to off by starting from the edges and moving inward
  {
    phase_20_progress = std::min(elapsed / T20, 1.0f);

    if (elapsed > T20)
    {
      phase = -1;
      phase_start = now;
      mode = HeadlightEffectMode::Off;
    }
  }

  if (red && green && blue)
  {
    hueOffset += rainbowSpeed * dtSeconds;
    // Wrap hueOffset to the range [0, 360)
    hueOffset = fmod(hueOffset, 360.0f);

    // Adjust the animated hues based on the offset
    hueCenter = baseHueCenter + hueOffset;
    hueEdge = baseHueEdge + hueOffset;

    // Wrap animated hues within the [0,360) range. use modulo operator to wrap the hue within [0,360).

    hueCenter = fmod(hueCenter, 360.0f);
    hueEdge = fmod(hueEdge, 360.0f);
  }
}

void HeadlightEffect::render(LEDStrip *strip, Color *buffer)
{
  // if (!active)
  if (mode == HeadlightEffectMode::Off && phase == -1)
    return;

  // Define colors

  float halfBrightness = 0.35f; // Half brightness version

  uint16_t numLEDs = strip->getNumLEDs();
  uint16_t numLEDsHalf = numLEDs / 2;
  if (numLEDs % 2 == 1)
    numLEDsHalf += 1;
  uint16_t effective_size = std::min<uint16_t>(headlight_size, numLEDsHalf);

  // For each phase, calculate which LEDs should be lit and at what brightness
  if (phase == 0) // Phase 0: Filling from outside at half brightness
  {
    int leds = floor(phase_0_progress * effective_size);

    int single_led_to_light = static_cast<float>(effective_size) * phase_0_single_led_progress;

    // Fill left side from the edge inward
    if (phase_0_single_led_index > 1)
    {
      for (int i = 0; i < phase_0_single_led_index; i++)
      {
        buffer[effective_size - i - 1] = _getColor(strip, effective_size - i - 1, numLEDsHalf) * halfBrightness;
        buffer[numLEDs - 1 - (effective_size - i - 1)] = buffer[effective_size - i - 1];
      }
    }

    // Highlight the current LED being filled
    for (int i = 0; i < ledsStepSize; i++)
    {
      int ledIndex = single_led_to_light + i;
      if (ledIndex < effective_size)
      {
        buffer[ledIndex] = _getColor(strip, ledIndex, numLEDsHalf) * halfBrightness;
        buffer[numLEDs - 1 - ledIndex] = buffer[ledIndex];
      }
    }
  }
  else if (phase == 1) // Phase 1: Delay
  {
    // fill with half brightness
    for (int i = 0; i < effective_size; i++)
    {
      buffer[i] = _getColor(strip, i, numLEDsHalf) * halfBrightness;
      buffer[numLEDs - 1 - i] = buffer[i];
    }
  }
  else if (phase == 2) // Phase 2: Filling from outside at full brightness
  {
    // First, set all LEDs that should be at half brightness
    for (int i = 0; i < effective_size; i++)
    {
      buffer[i] = _getColor(strip, i, numLEDsHalf) * halfBrightness; // Left side
      buffer[numLEDs - 1 - i] = buffer[i];                           // Right side
    }

    // Then, set LEDs that should be at full brightness based on progress
    int leftLeds = floor(phase_2_progress * effective_size);
    int rightLeds = floor(phase_2_progress * effective_size);

    // Fill left side from the edge inward with full brightness
    for (int i = 0; i < leftLeds; i++)
    {
      buffer[i] = _getColor(strip, i, numLEDsHalf);
    }

    // Fill right side from the edge inward with full brightness
    for (int i = 0; i < rightLeds; i++)
    {
      buffer[numLEDs - 1 - i] = buffer[i];
    }
  }
  else if (phase == 3) // Final phase - all LEDs at full brightness
  {
    // Set all headlight LEDs to full brightness
    for (int i = 0; i < effective_size; i++)
    {
      buffer[i] = _getColor(strip, i, numLEDsHalf); // Left side
      buffer[numLEDs - 1 - i] = buffer[i];          // Right side
    }
  }

  // #########################################################
  // mode == HeadlightEffectMode::CarOn
  // #########################################################
  else if (phase == 10) // Phase 10: filling entire strip to full brightness
  {
    int ledsToAnimate = numLEDs - effective_size * 2;
    int ledsToAnimateSide = ledsToAnimate / 2;

    float p = phase_10_progress;
    p = 3 * p * p - 2 * p * p * p;

    for (int i = 0; i < numLEDs; i++)
    {
      if (i < effective_size)
        buffer[i] = _getColor(strip, i, numLEDsHalf); // Left side

      if (i >= numLEDs - effective_size)
        buffer[i] = buffer[numLEDs - 1 - i];

      if (i > effective_size && i < effective_size + (ledsToAnimateSide * p))
        buffer[i] = _getColor(strip, i, numLEDsHalf);

      if (i > numLEDs - effective_size - ledsToAnimateSide && i > numLEDs - effective_size - (ledsToAnimateSide * p))
        buffer[i] = buffer[numLEDs - 1 - i];
    }
  }
  else if (phase == 11) // full strip full brightness
  {
    for (int i = 0; i < numLEDsHalf; i++)
    {
      buffer[i] = _getColor(strip, i, numLEDsHalf);
      buffer[numLEDs - 1 - i] = buffer[i];
    }
  }
  else if (phase == 12) // split strip full brightness
  {
    for (int i = 0; i < effective_size; i++)
    {
      buffer[i] = _getColor(strip, i, numLEDsHalf);
      buffer[numLEDs - 1 - i] = buffer[i];
    }
  }
  else if (phase == 13) // Transition from full strip to split mode
  {
    // Animate turning off middle section
    int middleLength = numLEDsHalf - effective_size;

    float p = phase_13_progress;
    p = 3 * p * p - 2 * p * p * p; // Smooth step

    int ledsToTurnOff = middleLength * p;

    // Handle left half of the strip
    for (int i = 0; i < numLEDsHalf; i++)
    {
      if (i < effective_size)
      {
        // Keep headlight section on
        buffer[i] = _getColor(strip, i, numLEDsHalf);
      }
      else if (i >= numLEDsHalf - ledsToTurnOff)
      {
        // Turn off middle section progressively from center outward
        buffer[i] = Color(0, 0, 0);
      }
      else
      {
        // Keep remaining middle section on until its turn
        buffer[i] = _getColor(strip, i, numLEDsHalf);
      }

      // Mirror to right side
      buffer[numLEDs - 1 - i] = buffer[i];
    }
  }
  else if (phase == 14) // Transition from split mode to full strip
  {
    // Animate turning on middle section
    int middleLength = numLEDsHalf - effective_size;

    float p = phase_14_progress;
    p = 3 * p * p - 2 * p * p * p; // Smooth step

    int ledsToTurnOn = middleLength * p;

    // Handle left half of the strip
    for (int i = 0; i < numLEDsHalf; i++)
    {
      if (i < effective_size)
      {
        // Keep headlight section on
        buffer[i] = _getColor(strip, i, numLEDsHalf);
      }
      else if (i < effective_size + ledsToTurnOn)
      {
        // Turn on middle section progressively from headlight outward
        buffer[i] = _getColor(strip, i, numLEDsHalf);
      }
      else
      {
        // Keep remaining middle section off until its turn
        buffer[i] = Color(0, 0, 0);
      }

      // Mirror to right side
      buffer[numLEDs - 1 - i] = buffer[i];
    }
  }

  // #########################################################
  // mode == HeadlightEffectMode::TurningOff
  // #########################################################
  else if (phase == 20)
  { // Phase 20: fade full white strip to off by starting

    float p = phase_20_progress;
    p = 3 * p * p - 2 * p * p * p;

    if (split)
    {
      // Only fade the headlight sections (effective_size LEDs from each edge)
      // Animation goes from inside out when split is true
      int ledsOffPerSide = effective_size * p;

      for (int i = 0; i < numLEDs; i++)
      {
        // Left side headlight section
        if (i < effective_size)
        {
          // Turn off LEDs from inside out: start at (effective_size - 1) and work towards 0
          if (i >= effective_size - ledsOffPerSide)
          {
            buffer[i] = Color(0, 0, 0);
          }
          else
          {
            buffer[i] = _getColor(strip, i, numLEDsHalf);
          }
        }
        // Right side headlight section
        else if (i >= numLEDs - effective_size)
        {
          // Turn off LEDs from inside out: start at (numLEDs - effective_size) and work towards end
          if (i < numLEDs - effective_size + ledsOffPerSide)
          {
            buffer[i] = Color(0, 0, 0);
          }
          else
          {
            buffer[i] = _getColor(strip, i, numLEDsHalf);
          }
        }
        // Middle section remains off when split is true
        else
        {
          buffer[i] = Color(0, 0, 0);
        }
      }
    }
    else
    {
      // Original behavior: fade entire strip from edges
      int ledsPerSide = numLEDsHalf;
      int ledsOffPerSide = ledsPerSide * p;

      for (int i = 0; i < numLEDsHalf; i++)
      {
        // If the LED is within the off-section on either side, turn it off.
        if (i < ledsOffPerSide)
        {
          buffer[i] = Color(0, 0, 0);
          buffer[numLEDs - 1 - i] = buffer[i];
        }
        else
        {
          buffer[i] = _getColor(strip, i, numLEDsHalf);
          buffer[numLEDs - 1 - i] = buffer[i];
        }
      }
    }
  }
  else if (phase == -1) // full strip off
  {
    for (int i = 0; i < numLEDs; i++)
    {
      buffer[i] = Color(0, 0, 0);
    }
  }
}

Color HeadlightEffect::_getColor(LEDStrip *strip, int i, int size)
{
  Color color;
  color.r = red ? 255 : 0;
  color.g = green ? 255 : 0;
  color.b = blue ? 255 : 0;

  bool rainbow = false;
  if (color == Color(255, 255, 255))
    rainbow = true;

  if (color == Color(0, 0, 0))
    color = Color(255, 255, 255);

  uint16_t numLEDs = strip->getNumLEDs();

  if (rainbow)
  {
    float normDist = (float)i / size; // 0 at edge, 1 at center

    float diff = hueEdge - hueCenter;
    if (diff < 0)
    {
      diff += 360.0f;
    }
    // Linearly interpolate along the positive direction.
    float hue = hueCenter - diff * normDist;

    // Normalize the hue to the [0, 360) range.
    hue = fmod(hue, 360.0f);
    if (hue < 0)
      hue += 360.0f;

    return Color::hsv2rgb(hue, 1.0f, 1.0f);
  }
  return color;
}

void HeadlightEffect::onDisable()
{
  phase = -1;
  mode = HeadlightEffectMode::Off;
}========
==== IO/LED/Effects/HeadlightEffect.h: ====
#pragma once

#include "../Effects.h"
#include <stdint.h>

enum class HeadlightEffectMode
{
  Off,
  Startup,
  CarOn,
};

class HeadlightEffect : public LEDEffect
{
public:
  HeadlightEffect(uint8_t priority = 0, bool transparent = false);

  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;


  bool isActive();

  void setOff();
  void setStartup();
  void setCarOn();
  void setMode(HeadlightEffectMode mode);
  void setMode(int mode);
  HeadlightEffectMode getMode();

  void setSplit(bool split);
  bool getSplit();

  void setColor(bool r, bool g, bool b);
  void getColor(bool &r, bool &g, bool &b);

private:
  // bool active;               // Is the effect active?
  HeadlightEffectMode mode;
  int phase;                 // Phase 0: filling from outside at half brightness
                             // Phase 1: filling from outside at full brightness
                             // Phase 2: final steady state (all LEDs at full brightness)
  unsigned long phase_start; // Timestamp (in ms) when the current phase started
  unsigned long lastUpdate;

  // Duration parameters (in seconds)
  float T0; // half brightness fill duration
  float T1; // delay duration
  float T2; // full brightness fill duration

  float T10; // filling entire strip to full brightness duration

  float T20; // fade full white strip to off by starting from the edges and moving inward duration

  float T13; // transition from full strip to split mode duration
  float T14; // transition from split mode to full strip duration

  // Effect parameters
  uint16_t headlight_size; // number of LEDs in the headlight section from edge

  uint8_t ledsStepSize; // How many LEDs to fill at once

  // Progress tracking variables
  // Phase 0 (half brightness fill)
  float phase_0_progress;
  int phase_0_single_led_index;           // Index of the single LED that we are on
  float phase_0_single_led_progress;      // Progress for half brightness fill (0 to 1)
  unsigned long phase_0_start_single_led; // Timestamp (in ms) when the current phase started

  // Phase 1 (delay)
  float phase_1_progress;

  // Phase 2 (full brightness fill)
  float phase_2_progress; // Progress for full brightness fill (0 to 1)

  // Phase 10 (filling entire strip to full brightness)
  float phase_10_progress;

  // Phase 20 (fade full white strip to off by starting from the edges and moving inward)
  float phase_20_progress;

  // Phase 13 (transition from full strip to split mode)
  float phase_13_progress;

  // Phase 14 (transition from split mode to full strip)
  float phase_14_progress;

  bool red;
  bool blue;
  bool green;

  bool split;

  Color _getColor(LEDStrip *strip, int i, int size);

  // Rainbow mode variables
  float baseHueCenter; // Base hue at center (0-360)
  float baseHueEdge;   // Base hue at edges (0-360)
  float hueCenter;     // Current hue at center (0-360)
  float hueEdge;       // Current hue at edges (0-360)
  float hueOffset;     // Accumulated hue offset for animation
  float rainbowSpeed;  // Speed of color cycling in degrees per second
};========
==== IO/LED/Effects/IndicatorEffect.cpp: ====
#include "IndicatorEffect.h"
#include <Arduino.h>
#include <math.h>

IndicatorEffect::IndicatorEffect(Side side, uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      side(side),
      indicatorActive(false),
      fadeFactor(0.0f),
      // Default parameters - feel free to adjust.
      blinkCycle(1200),
      fadeInTime(250)
{
  bigIndicator = false;
  activatedTime = 0;
  otherIndicator = nullptr;
  synced = false;

  // Default color is amber/yellow.
  baseR = 255;
  baseG = 120;
  baseB = 0;

  onTime = 0;
  blockTime = 1000;
}

void IndicatorEffect::setOtherIndicator(IndicatorEffect *otherIndicator)
{
  this->otherIndicator = otherIndicator;
}

IndicatorEffect *IndicatorEffect::getOtherIndicator() const
{
  return otherIndicator;
}

void IndicatorEffect::setActive(bool active)
{
  // If state is unchanged, nothing to do.
  if (indicatorActive == active)
  {
    return;
  }

  indicatorActive = active;

  if (active)
  {
    onTime = millis();
    blinkCycle = 3000;
    // If another indicator exists and is active, sync start times.
    if (otherIndicator != nullptr && otherIndicator->isActive())
    {
      // syncWithOtherIndicator();
    }
    else
    {
      // Otherwise, simply set this activatedTime.
    }
    activatedTime = millis();
  }
  else
  {
    // Clear fade factor if the indicator is turned off.
    fadeFactor = 0.0f;
    activatedTime = 0;

    if (millis() - onTime > 1000)
    {
      onTime = 0;
    }
    else
    {
      onTime = millis();
    }

    if (synced == true)
    {
      synced = false;
      if (otherIndicator != nullptr)
        otherIndicator->synced = false;
    }
  }
}

bool IndicatorEffect::isActive() const
{
  return indicatorActive;
}

void IndicatorEffect::syncWithOtherIndicator()
{
  if (otherIndicator == nullptr)
  {
    return;
  }

  activatedTime = otherIndicator->activatedTime;
  synced = true;
  otherIndicator->synced = true;
}

void IndicatorEffect::update(LEDStrip *strip)
{
  if (!indicatorActive && onTime == 0)
  {
    // Ensure fade factor remains 0 if not active.
    fadeFactor = 0.0f;
    return;
  }
  // Compute where we are within the blink cycle.
  uint64_t currentTime = millis();
  currentTime -= activatedTime;
  uint64_t timeInCycle = currentTime % blinkCycle;

  // For this design, the indicator is "on" only during the fade-in period.
  if (timeInCycle < (blinkCycle / 2))
  {
    // Fade factor increases linearly from 0 to 1 over fadeInTime.
    fadeFactor = (float)timeInCycle / fadeInTime;
    fadeFactor = constrain(fadeFactor, 0.0f, 1.0f);
  }
  else
  {
    // Turn indicator off for the remainder of the blink cycle.
    fadeFactor = 0.0f;
    if (blinkCycle != 1200)
    {
      blinkCycle = 1200;

      if (otherIndicator != nullptr && !synced && otherIndicator->isActive())
      {
        syncWithOtherIndicator();
      }
      else if (!synced)
      {
        activatedTime = millis() - 600;
      }
    }
  }
}

void IndicatorEffect::render(LEDStrip *strip, Color *buffer)
{
  // Do nothing if the indicator is inactive or the fade factor is 0.
  if (!indicatorActive && onTime == 0)
    return;

  if (millis() - onTime > blockTime)
  {
    onTime = 0;
  }

  uint16_t regionLength = 32;

  if (bigIndicator)
  {
    regionLength = (strip->getNumLEDs() / 2) - regionLength;
  }

  if (regionLength <= 1)
  {
    // Handle error or simply return
    return;
  }

  if (onTime > 0 && !indicatorActive)
  {
    for (uint16_t i = 0; i < regionLength; i++)
    {
      if (side == LEFT)
      {
        buffer[i] = Color(0, 0, 0);
      }
      else
      {
        buffer[strip->getNumLEDs() - i - 1] = Color(0, 0, 0);
      }
    }
    return;
  }

  // For the left indicator, the region covers indices 0 to regionLength-1.
  // We want the "inner" edge (the side facing the vehicle) to light first.
  // For the left indicator, that is index (regionLength-1).

  for (uint16_t i = 0; i < regionLength; i++)
  {
    // Compute normalized distance from the inner edge.
    // map i from [0, regionLength] to [0, 1]
    float d = static_cast<float>(regionLength - i) / regionLength;

    // Determine when LED i should begin lighting.
    // Here we use d directly as a threshold: the inner LED (d=0) lights up immediately,
    // while an outer LED (d close to 1) lights only when fadeFactor is nearly 1.
    float finalFactor = 0.0f;
    if (fadeFactor >= d)
    {
      // Check if the denominator is nearly zero to avoid division by zero.
      if (fabs(1.0f - d) < 1e-6)
        finalFactor = 1.0f;
      else
        finalFactor = (fadeFactor - d) / (1.0f - d);
    }

    finalFactor = constrain(finalFactor, 0.0f, 1.0f);

    // Compute final color for this LED.
    uint8_t r = baseR * finalFactor;
    uint8_t g = baseG * finalFactor;
    uint8_t b = baseB * finalFactor;

    // if (i == 0) // Debugging
    // {
    //   Serial.println("fadeFactor: " + String(fadeFactor) + " d: " + String(d) + " finalFactor: " + String(finalFactor));
    //   Serial.println("i: " + String(i) + " r: " + String(r) + " g: " + String(g) + " b: " + String(b));
    // }

    // Set the color in the buffer.
    // should fade in from the center edge
    if (!bigIndicator)
    {
      if (side == LEFT)
      {
        buffer[i] = Color(r, g, b);
      }
      else
      {
        buffer[strip->getNumLEDs() - i - 1] = Color(r, g, b);
      }
    }
    else
    {
      if (side == LEFT)
      {
        buffer[strip->getNumLEDs() / 2 - regionLength + i] = Color(r, g, b);
      }
      else
      {
        buffer[strip->getNumLEDs() / 2 + regionLength - i - 1] = Color(r, g, b);
      }
    }
  }
}

void IndicatorEffect::onDisable()
{
  indicatorActive = false;
}
========
==== IO/LED/Effects/IndicatorEffect.h: ====
#pragma once

#include "../Effects.h"
#include <stdint.h>

// Fancy, blink-based indicator effect that fades in from the center edge.
// The indicator region is defined as a quarter of the LED strip.
// The left indicator's inner edge is at index (regionLength-1) and the right indicator's
// inner edge is at index (numLEDs - regionLength).
class IndicatorEffect : public LEDEffect
{
public:
  enum Side
  {
    LEFT = 0,
    RIGHT = 1
  };

  // Constructs an indicator effect for a given LED strip.
  // All timing and color parameters are customizable.
  IndicatorEffect(Side side, uint8_t priority = 1, bool transparent = false);

  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;

  void setOtherIndicator(IndicatorEffect *otherIndicator);
  IndicatorEffect *getOtherIndicator() const;

  // Activate or deactivate the indicator.
  void setActive(bool active);
  bool isActive() const;

  void syncWithOtherIndicator();

  // Customizable parameters:
  unsigned long blinkCycle; // Total blink period in ms (default: 1000)
  unsigned long fadeInTime; // Duration of fade in (ms) during the on phase (default: 300)
  // Base color for the indicator (default: amber/yellow).
  uint8_t baseR;
  uint8_t baseG;
  uint8_t baseB;

private:
  Side side;
  bool indicatorActive;
  bool bigIndicator; // Whether the indicator is the big mode

  IndicatorEffect *otherIndicator; // Pointer to the other indicator effect.
  bool synced;                     // Whether the indicator has been synced with the other indicator.
  uint32_t onTime;
  uint32_t blockTime;

  uint64_t activatedTime; // Time when the indicator was last activated.

  // Computed fade factor (0.0 to 1.0) for the current blink cycle.
  // It increases linearly during the fade in period and then resets.
  float fadeFactor;
};
========
==== IO/LED/Effects/NightRiderEffect.cpp: ====
#include "NightRiderEffect.h"
#include <cmath>

NightRiderEffect::NightRiderEffect(uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      active(false),
      cycleTime(3.0f),
      tailLength(15.0f),
      progress(0.0f),
      forward(true),
      lastUpdateTime(0),
      syncEnabled(true) // Enable sync by default
{
}

void NightRiderEffect::setActive(bool _active)
{
  if (active == _active)
    return;

  active = _active;

  if (active)
  {
    // Reset the progress and direction.
    progress = 0.0f;
    forward = true;
    lastUpdateTime = SyncManager::syncMillis();
  }
  else
  {
  }
}

bool NightRiderEffect::isActive() const
{
  return active;
}

void NightRiderEffect::setSyncData(NightRiderSyncData syncData)
{
  active = syncData.active;
  cycleTime = syncData.cycleTime;
  tailLength = syncData.tailLength;
  progress = syncData.progress;
  forward = syncData.forward;
}

NightRiderSyncData NightRiderEffect::getSyncData()
{
  return NightRiderSyncData{
      .cycleTime = cycleTime,
      .tailLength = tailLength,
      .progress = progress,
      .forward = forward,
      .active = active,
  };
}

void NightRiderEffect::update(LEDStrip *strip)
{
  if (!active)
    return;

  unsigned long currentTime = SyncManager::syncMillis();
  if (lastUpdateTime == 0)
  {
    lastUpdateTime = currentTime;
    return;
  }

  // Calculate elapsed time in seconds.
  unsigned long dtMillis = currentTime - lastUpdateTime;
  float dtSeconds = dtMillis / 1000.0f;
  lastUpdateTime = currentTime;

  if (cycleTime <= 0.0f)
    return;

  // Calculate progress step per second (0.0 to 1.0 represents a full cycle).
  float progressPerSecond = 1.0f / cycleTime;
  // Calculate step size.
  float step = progressPerSecond * dtSeconds;

  // Update progress based on direction.
  if (forward)
  {
    progress += step;
    if (progress >= 1.0f)
    {
      // Overshoot correction and change direction.
      progress = 1.0f - (progress - 1.0f);
      forward = false;
    }
  }
  else
  {
    progress -= step;
    if (progress <= 0.0f)
    {
      // Overshoot correction and change direction.
      progress = -progress;
      forward = true;
    }
  }
}

void NightRiderEffect::render(LEDStrip *strip, Color *buffer)
{
  if (!active)
    return;

  uint16_t numLEDs = strip->getNumLEDs();
  if (numLEDs < 2)
    return;

  // Clear the buffer (turn off all LEDs).
  for (uint16_t i = 0; i < numLEDs; i++)
  {
    buffer[i] = Color(0, 0, 0);
  }

  // Map progress (0.0-1.0) to actual LED position (0 to numLEDs-1).
  float currentPos = progress * (numLEDs - 1);

  // Define the head color: bright red.
  const float headBrightness = 1.0f;
  const uint8_t red = 255;
  const uint8_t green = 0;
  const uint8_t blue = 0;

  // Draw the head (main bright LED).
  int headIndex = static_cast<int>(roundf(currentPos));
  if (headIndex >= 0 && headIndex < static_cast<int>(numLEDs))
  {
    buffer[headIndex] = Color(red, green, blue);
  }

  // Draw the tail with a fading brightness.
  for (int i = 0; i < static_cast<int>(numLEDs); i++)
  {
    // Skip the head LED.
    if (i == headIndex)
      continue;
    // Compute the distance from the head.
    float distance = fabs(i - currentPos);
    if (distance <= tailLength)
    {
      // Brightness diminishes linearly with distance.
      float brightness = headBrightness * (1.0f - (distance / tailLength));
      uint8_t tailRed = static_cast<uint8_t>(red * brightness);
      uint8_t tailGreen = static_cast<uint8_t>(green * brightness);
      uint8_t tailBlue = static_cast<uint8_t>(blue * brightness);

      // Set the LED if the computed brightness is greater than its current value.
      if (tailRed > buffer[i].r || tailGreen > buffer[i].g ||
          tailBlue > buffer[i].b)
      {
        buffer[i] = Color(tailRed, tailGreen, tailBlue);
      }
    }
  }
}

void NightRiderEffect::onDisable()
{
  active = false;
}========
==== IO/LED/Effects/NightRiderEffect.h: ====
#pragma once

#include "../Effects.h"

class NightRiderEffect : public LEDEffect
{
public:
  // Constructs the Night Rider effect.
  // speed: movement in LED positions per second.
  // tailLength: tail length in LED units (should be > 0).
  NightRiderEffect(uint8_t priority = 0, bool transparent = false);

  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;

  // Activate or disable the effect.
  void setActive(bool active);
  bool isActive() const;

  // Sync functionality
  void setSyncData(NightRiderSyncData syncData);
  NightRiderSyncData getSyncData();

  // Customizable parameters:
  float cycleTime;
  float tailLength; // Length of the fading tail in LED units.

private:
  bool active;
  // The current progress in the cycle (0.0 to 1.0).
  float progress;
  // Direction of movement: true = moving forward, false = moving backward.
  bool forward;
  // Last update time (in milliseconds).
  unsigned long lastUpdateTime;

  // Sync support
  bool syncEnabled;
};
========
==== IO/LED/Effects/PoliceEffect.cpp: ====
#include "PoliceEffect.h"
#include <Arduino.h>
#include <math.h>

// Helper function: Easing function for smoother transitions
static float easeInOut(float t)
{
  return 0.5f * (1.0f - cosf(t * PI));
}

PoliceEffect::PoliceEffect(uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      active(false),
      mode(PoliceMode::FAST),
      lastUpdateTime(0),
      flashProgress(0.0f),
      cycleProgress(0.0f),
      fastSpeed(0.5f),            // 0.5 seconds per full flash cycle in fast mode
      slowSpeed(1.0f),            // 1.0 seconds per full flash cycle in slow mode
      fastModeFlashesPerCycle(3), // 3 flashes per color cycle
      blueColor(Color(0, 0, 255)),
      redColor(Color(255, 0, 0)),
      currentFlash(0)
{
}

void PoliceEffect::setActive(bool a)
{
  if (active == a)
    return;

  active = a;
  if (active)
  {
    // Reset animation state when activating
    lastUpdateTime = millis();
    flashProgress = 0.0f;
    cycleProgress = 0.0f;
    currentFlash = 0;
  }
}

bool PoliceEffect::isActive() const
{
  return active;
}

void PoliceEffect::setSyncData(PoliceSyncData syncData)
{
  active = syncData.active;
  mode = syncData.mode;
  flashProgress = syncData.flashProgress;
  cycleProgress = syncData.cycleProgress;
  currentFlash = syncData.currentFlash;
}

PoliceSyncData PoliceEffect::getSyncData()
{
  return PoliceSyncData{
      .active = active,
      .mode = mode,
      .flashProgress = flashProgress,
      .cycleProgress = cycleProgress,
      .currentFlash = currentFlash};
}

void PoliceEffect::setMode(PoliceMode m)
{
  mode = m;
}

PoliceMode PoliceEffect::getMode() const
{
  return mode;
}

void PoliceEffect::update(LEDStrip *strip)
{
  if (!active)
    return;

  unsigned long currentTime = millis();

  // First update - initialize time
  if (lastUpdateTime == 0)
  {
    lastUpdateTime = currentTime;
    return;
  }

  // Calculate the elapsed time in seconds
  float deltaTime = (currentTime - lastUpdateTime) / 1000.0f;
  lastUpdateTime = currentTime;

  // Determine the speed based on the current mode
  float cycleDuration = (mode == PoliceMode::FAST) ? fastSpeed : slowSpeed;

  if (mode == PoliceMode::SLOW)
  {
    // In slow mode, simple toggle between colors
    cycleProgress += deltaTime / cycleDuration;
    if (cycleProgress >= 1.0f)
    {
      cycleProgress = 0.0f;
    }
  }
  else if (mode == PoliceMode::FAST)
  {
    // Update the flash progress (controls the on/off of each flash)
    // Each flash consists of an on state and an off state (complete cycle)
    flashProgress += deltaTime / (cycleDuration / fastModeFlashesPerCycle);
    if (flashProgress >= 1.0f)
    {
      flashProgress = 0.0f;

      // Move to the next flash
      currentFlash++;

      // After flashesPerCycle flashes, switch sides
      if (currentFlash >= fastModeFlashesPerCycle)
      {
        currentFlash = 0;
        cycleProgress = (cycleProgress < 0.5f) ? 0.5f : 0.0f;
      }
    }
  }
}

void PoliceEffect::render(LEDStrip *strip, Color *buffer)
{
  if (!active)
    return;

  uint16_t numLEDs = strip->getNumLEDs();
  uint16_t half = numLEDs / 2;

  if (mode == PoliceMode::SLOW)
  {
    // In SLOW mode: alternate between colors on each side with no fade
    bool isRed = cycleProgress < 0.5f;

    for (uint16_t i = 0; i < numLEDs; i++)
    {
      if (i < half) // Left side
      {
        buffer[i] = isRed ? redColor : Color();
      }
      else // Right side
      {
        buffer[i] = isRed ? Color() : blueColor;
      }
    }
  }
  else // FAST mode
  {
    // In FAST mode: flash one side for fastModeFlashesPerCycle times, then the other side
    bool isRedCycle = cycleProgress < 0.5f;

    // Flash intensity based on flash progress
    // 0-0.5: On, 0.5-1.0: Off
    float flashIntensity = (flashProgress < 0.5f) ? 1.0f : 0.0f;

    for (uint16_t i = 0; i < numLEDs; i++)
    {
      if (isRedCycle)
      {
        // Red on left side
        if (i < half)
        {
          buffer[i] = redColor * flashIntensity;
        }
        else
        {
          buffer[i] = Color(0, 0, 0); // Right side off during red cycle
        }
      }
      else
      {
        // Blue on right side
        if (i >= half)
        {
          buffer[i] = blueColor * flashIntensity;
        }
        else
        {
          buffer[i] = Color(0, 0, 0); // Left side off during blue cycle
        }
      }
    }
  }
}

void PoliceEffect::onDisable()
{
  active = false;
}========
==== IO/LED/Effects/PoliceEffect.h: ====
#pragma once

#include "../Effects.h"
#include <stdint.h>

class PoliceEffect : public LEDEffect
{
public:
  // Constructs the police light effect
  PoliceEffect(uint8_t priority = 0, bool transparent = false);

  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;

  // Activate or disable the effect
  void setActive(bool active);
  bool isActive() const;

  void setSyncData(PoliceSyncData syncData);
  PoliceSyncData getSyncData();

  // Set the speed mode (SLOW or FAST)
  void setMode(PoliceMode mode);
  PoliceMode getMode() const;

private:
  bool active;
  PoliceMode mode;

  // Animation parameters
  unsigned long lastUpdateTime;
  float flashProgress;   // Tracks the current position in the flash cycle (0-1)
  float cycleProgress;   // Tracks which color is currently displayed
  uint16_t currentFlash; // Tracks the current flash count in FAST mode

  // Configuration parameters
  float fastSpeed;                  // Flash cycle speed in seconds (fast mode)
  float slowSpeed;                  // Flash cycle speed in seconds (slow mode)
  uint16_t fastModeFlashesPerCycle; // Number of flashes per cycle

  // Colors
  Color blueColor;
  Color redColor;
};========
==== IO/LED/Effects/PulseWaveEffect.cpp: ====
#include "PulseWaveEffect.h"
#include <cmath>
#include "../LEDStrip.h"

PulseWaveEffect::PulseWaveEffect(uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      active(false),
      lastUpdateTime(0),
      phase(0.0f),
      colorPhase(0.0f),
      baseHue(140.0f),        // Start with a blue-green base
      hueRange(120.0f),       // Cover 120 degrees of the color wheel
      waveSpeed(0.5f),        // Half a cycle per second
      pulseFrequency(2.0f),   // Two wave peaks across the strip
      colorCycleSpeed(20.0f), // 20 degrees per second (full color cycle in 18 seconds)
      colorSaturation(1.0f),  // Full saturation
      intensity(1.0f)         // Full brightness
{
}

void PulseWaveEffect::setActive(bool _active)
{
  active = _active;
  if (active && lastUpdateTime == 0)
  {
    lastUpdateTime = millis();
  }
}

bool PulseWaveEffect::isActive() const
{
  return active;
}

float PulseWaveEffect::computeWave(float pos, float phase, float frequency)
{
  // Creates a smooth sinusoidal wave that varies from 0 to 1
  // pos: position along the strip [0, 1]
  // phase: current animation phase [0, 2π]
  // frequency: number of wave cycles across the strip

  // Calculate the wave pattern
  // Use negative phase to make waves move away from index 0 (or center in mirrored mode)
  float value = 0.5f * (1.0f + sinf(2.0f * PI * (frequency * pos - phase)));

  // Add a gentle fade toward the edges for a more natural look
  float edgeFade = 0.7f + 0.3f * (1.0f - powf(2.0f * (pos - 0.5f), 2));

  return value * edgeFade;
}

void PulseWaveEffect::update(LEDStrip *strip)
{
  if (!active)
    return;

  unsigned long currentTime = millis();
  if (lastUpdateTime == 0)
  {
    lastUpdateTime = currentTime;
    return;
  }

  // Calculate elapsed time in seconds
  unsigned long dtMillis = currentTime - lastUpdateTime;
  float dtSeconds = dtMillis / 1000.0f;
  lastUpdateTime = currentTime;

  // Update the animation phase
  // Positive phase increment makes waves appear to move away from index 0
  phase += waveSpeed * dtSeconds;
  if (phase > 1.0f)
  {
    phase -= 1.0f; // Keep phase in [0, 1) range
  }

  // Update the color cycle phase
  colorPhase += colorCycleSpeed * dtSeconds;
  while (colorPhase >= 360.0f)
  {
    colorPhase -= 360.0f; // Keep in [0, 360) range
  }
}

void PulseWaveEffect::render(LEDStrip *strip, Color *buffer)
{
  if (!active)
    return;

  uint16_t numLEDs = strip->getNumLEDs();
  bool isMirrored = false;

  if (strip->getType() == LEDStripType::TAILLIGHT)
  {
    isMirrored = true;
  }

  uint16_t midPoint = numLEDs / 2;

  for (uint16_t i = 0; i < numLEDs; i++)
  {
    float normalizedPos;

    if (isMirrored)
    {
      // Calculate position based on distance from center (0 at center, 1 at edges)
      normalizedPos = static_cast<float>(abs(static_cast<int>(i) - static_cast<int>(midPoint))) / midPoint;
    }
    else
    {
      // Normalized position [0, 1] along the strip
      normalizedPos = static_cast<float>(i) / (numLEDs - 1);
    }

    // Compute wave value at this position
    float waveVal = computeWave(normalizedPos, phase, pulseFrequency);

    // Calculate the hue based on position and current color phase
    float posHue = baseHue + colorPhase + (normalizedPos * hueRange);
    while (posHue >= 360.0f)
    {
      posHue -= 360.0f;
    }

    // Compute color with the calculated parameters
    Color color = Color::hsv2rgb(
        posHue,             // Hue varies by position and time
        colorSaturation,    // Full saturation
        waveVal * intensity // Brightness varies with the wave
    );

    // Apply to buffer
    buffer[i] = color;
  }
}

void PulseWaveEffect::onDisable()
{
  active = false;
}========
==== IO/LED/Effects/PulseWaveEffect.h: ====
#pragma once

#include "../Effects.h"
#include <stdint.h>

class PulseWaveEffect : public LEDEffect
{
public:
  // Constructs the Pulse Wave effect
  PulseWaveEffect(uint8_t priority = 0, bool transparent = false);

  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;

  // Activate or disable the effect
  void setActive(bool active);
  bool isActive() const;

  // Customizable parameters
  float waveSpeed;       // Speed of the wave in cycles per second
  float pulseFrequency;  // Frequency of the pulse waves
  float colorCycleSpeed; // Speed at which colors cycle in degrees per second
  float colorSaturation; // Color saturation (0.0-1.0)
  float intensity;       // Maximum brightness (0.0-1.0)

private:
  bool active;

  // Time tracking
  unsigned long lastUpdateTime;

  // Animation state
  float phase;      // Current phase of the wave animation
  float colorPhase; // Current phase of the color cycle

  // Color parameters
  float baseHue;  // Base hue for the effect (0-360)
  float hueRange; // Range of hue variation (0-360)

  // Creates smooth waves
  float computeWave(float pos, float phase, float frequency);
};========
==== IO/LED/Effects/RGBEffect.cpp: ====
#include "RGBEffect.h"
#include <cmath>

RGBEffect::RGBEffect(uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      active(false),
      baseHueCenter(1.0f), // Default center hue is red.
      baseHueEdge(270.0f), // Default edge hue is violet.
      speed(180.0f),       // Default speed: 60 degrees per second.
      hueOffset(0.0f),
      lastUpdateTime(0)
{
  // Initialize the animated hues to the base values.
  hueCenter = baseHueCenter;
  hueEdge = baseHueEdge;
}

void RGBEffect::setActive(bool _active)
{
  active = _active;
  if (_active && lastUpdateTime == 0)
  {
    lastUpdateTime = millis();
  }
}

bool RGBEffect::isActive() const
{
  return active;
}

void RGBEffect::setSyncData(RGBSyncData syncData)
{
  active = syncData.active;
  hueCenter = syncData.hueCenter;
  hueEdge = syncData.hueEdge;
  speed = syncData.speed;
  hueOffset = syncData.hueOffset;
}

RGBSyncData RGBEffect::getSyncData()
{
  RGBSyncData syncData = {
      .hueCenter = hueCenter,
      .hueEdge = hueEdge,
      .speed = speed,
      .hueOffset = hueOffset,
      .active = active};
  return syncData;
}
void RGBEffect::update(LEDStrip *strip)
{
  // Return if the effect is not active.
  if (!active)
    return;

  unsigned long currentTime = SyncManager::syncMillis();
  // Initialize last update if needed.
  if (lastUpdateTime == 0)
  {
    lastUpdateTime = currentTime;
    return;
  }

  // Calculate elapsed time in seconds.
  unsigned long dtMillis = currentTime - lastUpdateTime;
  float dtSeconds = dtMillis / 1000.0f;
  lastUpdateTime = currentTime;

  // Update the cumulative hue offset.
  // speed is in degrees per second.
  hueOffset += speed * dtSeconds;
  // Wrap hueOffset to the range [0, 360).
  hueOffset = fmod(hueOffset, 360.0f);

  // Adjust the animated hues based on the base values and the offset.
  hueCenter = baseHueCenter + hueOffset;
  hueEdge = baseHueEdge + hueOffset;

  // Wrap animated hues within the [0,360) range. use modulo operator to wrap the hue within [0,360).

  hueCenter = fmod(hueCenter, 360.0f);
  hueEdge = fmod(hueEdge, 360.0f);

  // log the hue values to the serial monitor.
  // Serial.print("Hue Center: ");
  // Serial.print(hueCenter);
  // Serial.print(" Hue Edge: ");
  // Serial.print(hueEdge);
  // Serial.print(" Hue Offset: ");
  // Serial.println(hueOffset);
}
void RGBEffect::render(LEDStrip *strip, Color *buffer)
{
  if (!active)
    return;

  uint16_t num = strip->getNumLEDs();
  uint16_t mid = num / 2;

  // For every LED, compute the normalized distance from the center.
  // At the center (distance = 0) use hueCenter; at the edges (distance = 1) use hueEdge.
  for (uint16_t i = 0; i < num; i++)
  {
    float normDist = (mid > 0)
                         ? fabs(static_cast<int>(i) - static_cast<int>(mid)) /
                               static_cast<float>(mid)
                         : 0.0f;

    // Compute the positive angular difference.
    float diff = hueEdge - hueCenter;
    if (diff < 0)
    {
      diff += 360.0f;
    }

    // Linearly interpolate along the positive direction.
    float hue = hueCenter - diff * normDist;

    // Normalize the hue to the [0, 360) range.
    hue = fmod(hue, 360.0f);
    if (hue < 0)
      hue += 360.0f;

    Color c = Color::hsv2rgb(hue, 1.0f, 1.0f);
    buffer[i] = c;
  }
}

void RGBEffect::onDisable()
{
  active = false;
}========
==== IO/LED/Effects/RGBEffect.h: ====
#pragma once

#include "../Effects.h"
#include <stdint.h>

class RGBEffect : public LEDEffect
{
public:
  // Constructs the RGB (rainbow) effect. The effect will map the hue from the center to the edges.
  RGBEffect(uint8_t priority = 0, bool transparent = false);

  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;

  // Activate or disable the effect.
  void setActive(bool active);
  bool isActive() const;

  void setSyncData(RGBSyncData syncData);
  RGBSyncData getSyncData();

  // Customizable parameters:
  // Base hue values defining the range, in degrees [0,360).
  float baseHueCenter; // Base hue at the center
  float baseHueEdge;   // Base hue at the edges

  // Speed at which the hue range moves (degrees per second)
  float speed;

private:
  bool active;

  // Currently computed hues (animated).
  float hueCenter;
  float hueEdge;
  // Tracks the cumulative hue offset (in degrees).
  float hueOffset;

  // Last update time for animation calculation.
  unsigned long lastUpdateTime;
};
========
==== IO/LED/Effects/ReverseLightEffect.cpp: ====
#include "ReverseLightEffect.h"
#include <Arduino.h>
#include <math.h>

// Ease in/out function using a cosine interpolation.
// t: input value between 0 and 1.
static float easeInOut(float t)
{
  return 0.5f * (1.0f - cosf(t * PI));
}

ReverseLightEffect::ReverseLightEffect(uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      active(false),
      animationSpeed(1.0f), // default 2 seconds for a full animation cycle
      startTime(0)
{
  progress = 0.0f;
}

void ReverseLightEffect::setActive(bool _active)
{
  if (active == _active)
    return;

  active = _active;

  if (active)
  {
    startTime = millis();
    // progress = 0.0f;
  }
  else
  {
    // progress = 1.0f;
  }
}

bool ReverseLightEffect::isActive() const
{
  return active;
}

bool ReverseLightEffect::isAnimating() const
{
  return active || progress > 0.0f;
}

void ReverseLightEffect::update(LEDStrip *strip)
{
  // Get the current time in milliseconds.
  unsigned long currentTime = millis();

  // Calculate elapsed time in seconds.
  float deltaTime = (currentTime - startTime) / 1000.0f;

  // Update startTime for the next update call.
  startTime = currentTime;

  // Determine how much progress to change.
  float deltaProgress = deltaTime / animationSpeed;

  // Increase or decrease progress based on whether the effect is active.
  if (active)
  {
    progress += deltaProgress;
    if (progress > 1.0f)
    {
      progress = 1.0f;
    }
  }
  else
  {
    progress -= deltaProgress;
    if (progress < 0.0f)
    {
      progress = 0.0f;
    }
  }
}

void ReverseLightEffect::render(LEDStrip *strip, Color *buffer)
{
  // If not active and progress is 0, do not modify the buffer.
  if (!active && progress <= 0.0f)
  {
    return;
  }

  uint16_t numLEDs = strip->getNumLEDs();
  // Compute the center index. This works for even or odd numbers,
  // though you might adjust if you need a more symmetrical behavior.
  float center = round(numLEDs / 2.0f);

  // Apply an easing function to the progress (for smoother animation)
  float p = easeInOut(progress);

  // For a hard threshold effect we interpret p as the normalized radius
  // (relative to the center) within which LEDs are fully lit.
  // When p==0, no LED is lit. When p==1, even the farthest LED is lit.
  for (uint16_t i = 0; i < numLEDs; i++)
  {
    float distance = fabs(center - i);
    // Compute normalized distance.
    float normalizedDistance = distance / center;

    // If the LED’s normalized distance is less than or equal to p,
    // then it is fully lit (brightness = 1), otherwise off (brightness = 0).
    float brightness = (normalizedDistance <= p) ? 1.0f : 0.0f;

    if (brightness * 255 > 0)
      buffer[i] = Color(255 * brightness,
                        255 * brightness,
                        255 * brightness);
  }
}

void ReverseLightEffect::onDisable()
{
  active = false;
}========
==== IO/LED/Effects/ReverseLightEffect.h: ====
#pragma once

#include "../Effects.h"
#include <stdint.h>

class ReverseLightEffect : public LEDEffect
{
public:
  // Constructs the reverse light effect.
  ReverseLightEffect(uint8_t priority = 0,
                     bool transparent = false);

  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;

  // Activate or disable the effect.
  void setActive(bool active);
  bool isActive() const;

  bool isAnimating() const;

private:
  bool active;
  uint64_t startTime;
  float animationSpeed; // in seconds for a full cycle (expand then contract)
  float progress;       // from 0 to 1
};
========
==== IO/LED/Effects/SolidColorEffect.cpp: ====
#include "SolidColorEffect.h"
#include <cmath>

SolidColorEffect::SolidColorEffect(uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      active(false),
      colorPreset(SolidColorPreset::WHITE),
      customColor(255, 255, 255)
{
}

void SolidColorEffect::setActive(bool _active)
{
  active = _active;
}

bool SolidColorEffect::isActive() const
{
  return active;
}

void SolidColorEffect::setColorPreset(SolidColorPreset preset)
{
  colorPreset = preset;
}

SolidColorPreset SolidColorEffect::getColorPreset() const
{
  return colorPreset;
}

void SolidColorEffect::setCustomColor(uint8_t r, uint8_t g, uint8_t b)
{
  customColor = Color(r, g, b);
}

void SolidColorEffect::getCustomColor(uint8_t &r, uint8_t &g, uint8_t &b) const
{
  r = customColor.r;
  g = customColor.g;
  b = customColor.b;
}

bool SolidColorEffect::isUsingCustomColor() const
{
  return colorPreset == SolidColorPreset::CUSTOM;
}

void SolidColorEffect::setSyncData(SolidColorSyncData syncData)
{
  active = syncData.active;
  colorPreset = syncData.colorPreset;
  customColor = Color(syncData.customR, syncData.customG, syncData.customB);
}

SolidColorSyncData SolidColorEffect::getSyncData()
{
  SolidColorSyncData syncData = {
      .active = active,
      .colorPreset = colorPreset,
      .customR = customColor.r,
      .customG = customColor.g,
      .customB = customColor.b};
  return syncData;
}

Color SolidColorEffect::getCurrentColor() const
{
  if (colorPreset == SolidColorPreset::CUSTOM)
  {
    return customColor;
  }
  else
  {
    return presetToColor(colorPreset);
  }
}

Color SolidColorEffect::presetToColor(SolidColorPreset preset) const
{
  switch (preset)
  {
  case SolidColorPreset::OFF:
    return Color(0, 0, 0);
  case SolidColorPreset::RED:
    return Color(255, 0, 0);
  case SolidColorPreset::GREEN:
    return Color(0, 255, 0);
  case SolidColorPreset::BLUE:
    return Color(0, 0, 255);
  case SolidColorPreset::WHITE:
    return Color(255, 255, 255);
  case SolidColorPreset::YELLOW:
    return Color(255, 255, 0);
  case SolidColorPreset::CYAN:
    return Color(0, 255, 255);
  case SolidColorPreset::MAGENTA:
    return Color(255, 0, 255);
  case SolidColorPreset::ORANGE:
    return Color(255, 40, 0);
  case SolidColorPreset::PURPLE:
    return Color(128, 0, 128);
  case SolidColorPreset::LIME:
    return Color(50, 205, 50);
  case SolidColorPreset::PINK:
    return Color(255, 0, 75);
  case SolidColorPreset::TEAL:
    return Color(0, 128, 128);
  case SolidColorPreset::INDIGO:
    return Color(75, 0, 130);
  case SolidColorPreset::GOLD:
    return Color(255, 215, 0);
  case SolidColorPreset::SILVER:
    return Color(192, 192, 192);
  case SolidColorPreset::CUSTOM:
    return customColor;
  default:
    return Color(255, 255, 255);
  }
}

void SolidColorEffect::update(LEDStrip *strip)
{
  // Solid color effect doesn't need complex updates - it's static
  // Just return if not active
  if (!active)
    return;
}

void SolidColorEffect::render(LEDStrip *strip, Color *buffer)
{
  if (!active)
    return;

  Color currentColor = getCurrentColor();
  uint16_t numLEDs = strip->getNumLEDs();

  // Fill all LEDs with the current color
  for (uint16_t i = 0; i < numLEDs; i++)
  {
    buffer[i] = currentColor;
  }
}

void SolidColorEffect::onDisable()
{
  active = false;
}========
==== IO/LED/Effects/SolidColorEffect.h: ====
#pragma once

#include "../Effects.h"
#include <stdint.h>

class SolidColorEffect : public LEDEffect
{
public:
  // Constructs the solid color effect
  SolidColorEffect(uint8_t priority = 0, bool transparent = false);

  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;

  // Activate or disable the effect
  void setActive(bool active);
  bool isActive() const;

  // Set color by preset
  void setColorPreset(SolidColorPreset preset);
  SolidColorPreset getColorPreset() const;

  // Set custom color (RGB values 0-255)
  void setCustomColor(uint8_t r, uint8_t g, uint8_t b);
  void getCustomColor(uint8_t &r, uint8_t &g, uint8_t &b) const;

  bool isUsingCustomColor() const;

  // Sync functionality
  void setSyncData(SolidColorSyncData syncData);
  SolidColorSyncData getSyncData();

  // Get the actual color being displayed
  Color getCurrentColor() const;

private:
  bool active;
  SolidColorPreset colorPreset;
  Color customColor;

  // Convert preset to Color
  Color presetToColor(SolidColorPreset preset) const;
};========
==== IO/LED/Effects/TaillightEffect.cpp: ====
#include "TaillightEffect.h"
#include <cmath>
#include <Arduino.h>

TaillightEffect::TaillightEffect(uint8_t priority, bool transparent)
    : LEDEffect(priority, transparent),
      mode(TaillightEffectMode::Off),
      previousMode(TaillightEffectMode::Off),
      phase(-1),
      phase_start(0),
      lastUpdate(0),
      split(false),
      // Startup timing (from TaillightStartupEffect)
      T_startup_dot(0.0f),
      T_startup_dash_out(0.6f),
      T_startup_dash_in(0.6f),
      T_startup_fill(0.6f),
      T_startup_delay(0.3f),
      T_startup_split(0.6f),
      // Transition timing
      T_mode_transition(0.5f),
      // Effect parameters
      startup_dash_length(15),
      startup_edge_stop(15),
      // Progress variables
      phase_progress(0.0f),
      startup_outward_progress(0.0f),
      startup_inward_progress(0.0f),
      startup_fill_progress(0.0f),
      startup_split_progress(0.0f),
      transition_progress(0.0f)
{
}

bool TaillightEffect::isActive()
{
  return mode != TaillightEffectMode::Off || phase != -1;
}

void TaillightEffect::setOff()
{
  if (mode == TaillightEffectMode::Off)
    return;

  previousMode = mode;
  mode = TaillightEffectMode::Off;
  phase = -1;
  phase_start = 0;
}

void TaillightEffect::setStartup()
{
  if (mode == TaillightEffectMode::Startup)
    return;

  previousMode = mode;
  mode = TaillightEffectMode::Startup;
  phase = 0;
  phase_start = millis();

  // Reset startup progress
  startup_outward_progress = 0.0f;
  startup_inward_progress = 0.0f;
  startup_fill_progress = 0.0f;
  startup_split_progress = 0.0f;
}

void TaillightEffect::setCarOn()
{
  if (mode == TaillightEffectMode::CarOn)
    return;

  previousMode = mode;
  mode = TaillightEffectMode::CarOn;
  phase = 10; // CarOn steady state
  phase_start = millis();
}

void TaillightEffect::setDim()
{
  if (mode == TaillightEffectMode::Dim)
    return;

  previousMode = mode;
  mode = TaillightEffectMode::Dim;
  phase = 20; // Dim steady state
  phase_start = millis();
}

void TaillightEffect::setMode(TaillightEffectMode newMode)
{
  switch (newMode)
  {
  case TaillightEffectMode::Off:
    setOff();
    break;
  case TaillightEffectMode::Startup:
    setStartup();
    break;
  case TaillightEffectMode::CarOn:
    setCarOn();
    break;
  case TaillightEffectMode::Dim:
    setDim();
    break;
  }
}

void TaillightEffect::setMode(int mode)
{
  if (mode == 0)
    setOff();
  else if (mode == 1)
    setStartup();
  else if (mode == 2)
    setCarOn();
  else if (mode == 3)
    setDim();
  else
    setOff();
}

TaillightEffectMode TaillightEffect::getMode()
{
  return mode;
}

void TaillightEffect::setSplit(bool split)
{
  this->split = split;
}

bool TaillightEffect::getSplit()
{
  return split;
}

bool TaillightEffect::isAnimating()
{
  return phase != -1 && mode == TaillightEffectMode::Startup;
}

void TaillightEffect::update(LEDStrip *strip)
{
  if (mode == TaillightEffectMode::Off && phase == -1)
    return;

  unsigned long now = millis();
  if (phase_start == 0)
    phase_start = now;

  unsigned long dtMillis = now - lastUpdate;
  float dtSeconds = dtMillis / 1000.0f;
  lastUpdate = now;

  float elapsed = (now - phase_start) / 1000.0f;

  // Handle mode-specific updates
  switch (mode)
  {
  case TaillightEffectMode::Startup:
    _updateStartupEffect(strip, elapsed);
    break;

  case TaillightEffectMode::CarOn:
  case TaillightEffectMode::Dim:
  case TaillightEffectMode::Off:
    // Steady states - no updates needed
    break;
  }
}

void TaillightEffect::_updateStartupEffect(LEDStrip *strip, float elapsed)
{
  if (phase == 0) // Red dot phase
  {
    if (elapsed >= T_startup_dot)
    {
      phase = 1;
      phase_start = millis();
    }
  }
  else if (phase == 1) // Dash outward
  {
    startup_outward_progress = std::min(elapsed / T_startup_dash_out, 1.0f);
    startup_outward_progress = _easeInOut(startup_outward_progress);

    if (startup_outward_progress >= 1.0f)
    {
      phase = 2;
      phase_start = millis();
    }
  }
  else if (phase == 2) // Dash inward
  {
    startup_inward_progress = std::min(elapsed / T_startup_dash_in, 1.0f);
    startup_inward_progress = _easeInOut(startup_inward_progress);

    if (startup_inward_progress >= 1.0f)
    {
      phase = 3;
      phase_start = millis();
    }
  }
  else if (phase == 3) // Fill sweep
  {
    startup_fill_progress = std::min(elapsed / T_startup_fill, 1.0f);

    if (startup_fill_progress >= 1.0f)
    {
      phase = 4;
      phase_start = millis();
    }
  }
  else if (phase == 4) // Delay with full red
  {
    if (elapsed >= T_startup_delay)
    {
      phase = 5;
      phase_start = millis();
    }
  }
  else if (phase == 5) // Split & fade
  {
    startup_split_progress = std::min(elapsed / T_startup_split, 1.0f);

    if (startup_split_progress >= 1.0f)
    {
      phase = 6; // Final steady state
      phase_start = millis();
    }
  }
}

void TaillightEffect::render(LEDStrip *strip, Color *buffer)
{
  if (mode == TaillightEffectMode::Off && phase == -1)
    return;

  uint16_t numLEDs = strip->getNumLEDs();

  // Handle normal mode rendering
  switch (mode)
  {
  case TaillightEffectMode::Startup:
    _renderStartupEffect(strip, buffer);
    break;

  case TaillightEffectMode::CarOn:
    // CarOn mode is all off by default (as requested)
    for (int i = 0; i < numLEDs; i++)
    {
      buffer[i] = Color(0, 0, 0);
    }
    break;

  case TaillightEffectMode::Dim:
    _renderDimEffect(strip, buffer);
    break;

  case TaillightEffectMode::Off:
  default:
    // All off
    for (int i = 0; i < numLEDs; i++)
    {
      buffer[i] = Color(0, 0, 0);
    }
    break;
  }
}

void TaillightEffect::_renderStartupEffect(LEDStrip *strip, Color *buffer)
{
  uint16_t numLEDs = strip->getNumLEDs();
  float center = numLEDs / 2.0f;
  Color color = _getTaillightColor();

  if (phase == 0) // Red dot at center
  {
    int idx = (int)round(center);
    if (idx >= 0 && idx < numLEDs)
      buffer[idx] = color;
  }
  else if (phase == 1 || phase == 2) // Dash phases
  {
    float progress = (phase == 1) ? startup_outward_progress : (1.0f - startup_inward_progress);

    float left_dash_pos = center - (progress * center);
    float right_dash_pos = center + (progress * center);

    int left_start = (int)round(left_dash_pos);
    int right_start = (int)round(right_dash_pos);

    int left_size = (int)std::min((float)startup_dash_length, center - left_start);
    int right_size = (int)std::min((float)startup_dash_length, right_start - center);

    // Adjust sizes if near the edges
    if (left_start < startup_dash_length)
    {
      left_size -= startup_dash_length - left_start;
      if (left_size < 2)
        left_size = 2;
    }
    if (right_start + startup_dash_length > numLEDs)
    {
      right_size -= (right_start + startup_dash_length) - numLEDs;
      if (right_size < 2)
        right_size = 2;
    }

    for (uint16_t i = 0; i < numLEDs; i++)
    {
      if (i >= left_start && i < left_start + left_size)
        buffer[i] = color;
      else if (i >= right_start - right_size && i < right_start)
        buffer[i] = color;
    }
  }
  else if (phase == 3) // Fill sweep
  {
    float p = startup_fill_progress;
    p = _easeInOut(p);

    float new_dash_length = (p <= 0.2f) ? (p * 5.0f * startup_dash_length) : startup_dash_length;
    p = (1 - ((float)new_dash_length / numLEDs)) * p + ((float)new_dash_length / numLEDs);

    for (int i = 0; i < numLEDs; i++)
    {
      if (i <= center)
      {
        if ((center - i) <= p * center)
          buffer[i] = color;
      }
      else
      {
        if ((i - center) <= p * (numLEDs - 1 - center))
          buffer[i] = color;
      }
    }
  }
  else if (phase == 4) // Full red
  {
    for (int i = 0; i < numLEDs; i++)
    {
      buffer[i] = color;
    }
  }
  else if (phase >= 5) // Split & fade
  {
    float p = startup_split_progress;
    p = _easeInOut(p);

    float left_cutoff = center - p * (center - startup_edge_stop);
    float right_cutoff = center + p * ((numLEDs - startup_edge_stop) - center);

    for (int i = 0; i < numLEDs; i++)
    {
      if (i < left_cutoff || i >= right_cutoff)
        buffer[i] = color;
      else
        buffer[i] = Color(0, 0, 0);
    }
  }
}

void TaillightEffect::_renderDimEffect(LEDStrip *strip, Color *buffer)
{
  uint16_t numLEDs = strip->getNumLEDs();

  // Dim red for all LEDs
  for (uint16_t i = 0; i < numLEDs; i++)
  {
    buffer[i] = Color(20, 0, 0); // Dim red
  }
}

Color TaillightEffect::_getTaillightColor()
{
  return Color(255, 0, 0); // Red for taillights
}

float TaillightEffect::_easeInOut(float t)
{
  return 3 * t * t - 2 * t * t * t;
}

void TaillightEffect::onDisable()
{
  phase = -1;
  mode = TaillightEffectMode::Off;
}========
==== IO/LED/Effects/TaillightEffect.h: ====
#pragma once

#include "../Effects.h"
#include <stdint.h>

enum class TaillightEffectMode
{
  Off,
  Startup,
  CarOn,
  Dim,
};

class TaillightEffect : public LEDEffect
{
public:
  TaillightEffect(uint8_t priority = 0, bool transparent = false);

  virtual void update(LEDStrip *strip) override;
  virtual void render(LEDStrip *strip, Color *buffer) override;
  virtual void onDisable() override;

  bool isActive();

  // Mode control methods
  void setOff();
  void setStartup();
  void setCarOn();
  void setDim();
  void setMode(TaillightEffectMode mode);
  void setMode(int mode);
  TaillightEffectMode getMode();

  void setSplit(bool split);
  bool getSplit();

  // State query methods
  bool isAnimating();

private:
  // Core state variables
  TaillightEffectMode mode;
  TaillightEffectMode previousMode;
  int phase;                 // Current animation phase
  unsigned long phase_start; // Timestamp when current phase started
  unsigned long lastUpdate;  // Last update timestamp

  bool split;

  // Timing parameters (in seconds)
  // Startup effect timing
  float T_startup_dot;      // Red dot duration
  float T_startup_dash_out; // Dash outward duration
  float T_startup_dash_in;  // Dash inward duration
  float T_startup_fill;     // Fill sweep duration
  float T_startup_delay;    // Full red hold duration
  float T_startup_split;    // Split & fade duration

  // Transition timing
  float T_mode_transition; // General mode transition duration

  // Effect parameters
  uint16_t startup_dash_length; // Startup dash length
  uint16_t startup_edge_stop;   // Final red region size at strip ends

  // Progress tracking variables
  float phase_progress; // General phase progress (0 to 1)

  // Startup specific progress
  float startup_outward_progress;
  float startup_inward_progress;
  float startup_fill_progress;
  float startup_split_progress;

  // Mode transition progress
  float transition_progress;

  // Helper methods
  Color _getTaillightColor();
  void _updateStartupEffect(LEDStrip *strip, float elapsed);
  void _updateModeTransition(LEDStrip *strip, float elapsed);

  void _renderStartupEffect(LEDStrip *strip, Color *buffer);
  void _renderDimEffect(LEDStrip *strip, Color *buffer);
  void _renderModeTransition(LEDStrip *strip, Color *buffer);

  // Easing functions
  float _easeInOut(float t);
};========
==== IO/LED/LEDStrip.cpp: ====
#include "LEDStrip.h"
#include <algorithm>

// Implementation of the Color structure.
// Range of h: [0, 360), s: [0, 1], v: [0, 1]
// Returns: RGB color with components in the range [0, 255].
Color Color::hsv2rgb(float h, float s, float v)
{
  float r, g, b;
  int i;
  float f, p, q, t;

  if (s == 0)
  {
    r = g = b = v;
    return Color(r * 255, g * 255, b * 255);
  }

  h /= 60; // sector 0 to 5
  i = floor(h);
  f = h - i;
  p = v * (1 - s);
  q = v * (1 - s * f);
  t = v * (1 - s * (1 - f));

  switch (i)
  {
  case 0:
    r = v;
    g = t;
    b = p;
    break;
  case 1:
    r = q;
    g = v;
    b = p;
    break;
  case 2:
    r = p;
    g = v;
    b = t;
    break;
  case 3:
    r = p;
    g = q;
    b = v;
    break;
  case 4:
    r = t;
    g = p;
    b = v;
    break;
  default: // case 5:
    r = v;
    g = p;
    b = q;
    break;
  }

  return Color(r * 255, g * 255, b * 255);
}

Color Color::rgb2hsv(uint8_t r, uint8_t g, uint8_t b)
{
  float h, s, v;
  float max = std::max(r, std::max(g, b));
  float min = std::min(r, std::min(g, b));

  v = max;
  s = max != 0 ? (max - min) / max : 0;

  if (s == 0)
  {
    h = 0;
  }
  else
  {
    h = 60 * (g - b) / (max - min);
  }

  return Color(h, s, v);
}

uint32_t Color::to32Bit() // wwrrggbb
{
  return (w << 24) | (r << 16) | (g << 8) | b;
}

const Color Color::WHITE = Color(255, 255, 255);
const Color Color::BLACK = Color(0, 0, 0);
const Color Color::RED = Color(255, 0, 0);
const Color Color::ORANGE = Color(255, 40, 0);
const Color Color::GREEN = Color(0, 255, 0);
const Color Color::BLUE = Color(0, 0, 255);
const Color Color::YELLOW = Color(255, 255, 0);
const Color Color::CYAN = Color(0, 255, 255);
const Color Color::MAGENTA = Color(255, 0, 255);

LEDStrip::LEDStrip(uint16_t numLEDs, uint8_t ledPin)
    : numLEDs(numLEDs),
      ledPin(ledPin),
      fliped(false),
      fps(100),
      brightness(255),
      taskHandle(nullptr),
      running(false)
{
  // Create task name based on pin
  taskName = "LED_P" + String(ledPin);

  // Create mutex for buffer access
  bufferMutex = xSemaphoreCreateMutex();

  leds = new CRGB[numLEDs];
  memset(leds, 0, numLEDs * sizeof(CRGB));
  ledBuffer = new Color[numLEDs];
  memset(ledBuffer, 0, numLEDs * sizeof(Color));
  switch (ledPin)
  {
  case 1:
    controller = &FastLED.addLeds<WS2812B, 1, GRB>(leds, numLEDs);
    break;
  case 2:
    controller = &FastLED.addLeds<WS2812B, 2, GRB>(leds, numLEDs);
    break;
  case 3:
    controller = &FastLED.addLeds<WS2812B, 3, GRB>(leds, numLEDs);
    break;
  case 4:
    controller = &FastLED.addLeds<WS2812B, 4, GRB>(leds, numLEDs);
    break;
  case 5:
    controller = &FastLED.addLeds<WS2812B, 5, GRB>(leds, numLEDs);
    break;
  case 6:
    controller = &FastLED.addLeds<WS2812B, 6, GRB>(leds, numLEDs);
    break;
  case 7:
    controller = &FastLED.addLeds<WS2812B, 7, GRB>(leds, numLEDs);
    break;
  case 8:
    controller = &FastLED.addLeds<WS2812B, 8, GRB>(leds, numLEDs);
    break;
  case 9:
    controller = &FastLED.addLeds<WS2812B, 9, GRB>(leds, numLEDs);
    break;
  case 10:
    controller = &FastLED.addLeds<WS2812B, 10, GRB>(leds, numLEDs);
    break;
  case 11:
    controller = &FastLED.addLeds<WS2812B, 11, GRB>(leds, numLEDs);
    break;
  case 12:
    controller = &FastLED.addLeds<WS2812B, 12, GRB>(leds, numLEDs);
    break;
  case 13:
    controller = &FastLED.addLeds<WS2812B, 13, GRB>(leds, numLEDs);
    break;
  case 14:
    controller = &FastLED.addLeds<WS2812B, 14, GRB>(leds, numLEDs);
    break;
  case 15:
    controller = &FastLED.addLeds<WS2812B, 15, GRB>(leds, numLEDs);
    break;
  case 16:
    controller = &FastLED.addLeds<WS2812B, 16, GRB>(leds, numLEDs);
    break;
  case 17:
    controller = &FastLED.addLeds<WS2812B, 17, GRB>(leds, numLEDs);
    break;
  case 18:
    controller = &FastLED.addLeds<WS2812B, 18, GRB>(leds, numLEDs);
    break;
  case 19:
    controller = &FastLED.addLeds<WS2812B, 19, GRB>(leds, numLEDs);
    break;
  case 20:
    controller = &FastLED.addLeds<WS2812B, 20, GRB>(leds, numLEDs);
    break;
  case 21:
    controller = &FastLED.addLeds<WS2812B, 21, GRB>(leds, numLEDs);
    break;
  }
}

LEDStrip::~LEDStrip()
{
  // Stop the task if it's running
  stop();

  // Clean up mutex
  if (bufferMutex != nullptr)
  {
    vSemaphoreDelete(bufferMutex);
  }

  for (auto effect : effects)
  {
    delete effect;
  }
  effects.clear();
  delete[] leds;
  delete[] ledBuffer;
}

void LEDStrip::addEffect(LEDEffect *effect)
{
  effects.push_back(effect);
  // Sort effects by priority so that lower priority effects are rendered first.
  std::sort(effects.begin(), effects.end(),
            [](const LEDEffect *a, const LEDEffect *b)
            {
              return a->getPriority() < b->getPriority();
            });
}

void LEDStrip::removeEffect(LEDEffect *effect)
{
  effects.erase(std::remove(effects.begin(), effects.end(), effect),
                effects.end());
}

void LEDStrip::updateEffects()
{
  // Take mutex before accessing buffer
  if (xSemaphoreTake(bufferMutex, portMAX_DELAY) == pdTRUE)
  {
    // Start timing the update effects
    String profilerKey = taskName + "_UpdateEffects";
    timeProfiler.start(profilerKey);

    // Clear the main LED buffer before applying effects.
    clearBufferUnsafe();

#ifdef USE_2_BUFFERS
    // Create a temporary buffer with the same size as the main LED buffer.
    // Using the default constructor for Color will initialize all pixels to black.
    Color *tempBuffer = new Color[numLEDs];
#endif

    // --- Update and render each effect ---
    for (auto effect : effects)
    {
      // Update the effect.
      effect->update(this);

#ifdef USE_2_BUFFERS
      // Clear temporary buffer to black before rendering this effect.
      for (auto &c : tempBuffer)
      {
        c = Color(0, 0, 0);
      }

      // Render the current effect into tempBuffer.
      effect->render(tempBuffer);
#else
      // Render the current effect directly into ledBuffer.
      effect->render(this, ledBuffer);
#endif

#ifdef USE_2_BUFFERS
      // Merge the rendered result from tempBuffer into ledBuffer.
      if (effect->isTransparent())
      {
        // For transparent effects, only copy pixels that are not black.
        for (size_t i = 0; i < ledBuffer.size(); i++)
        {
          if (tempBuffer[i].r != 0 && tempBuffer[i].g != 0 && tempBuffer[i].b != 0)
          {
            ledBuffer[i] = tempBuffer[i];
          }
        }
      }
      else
      {
        // For opaque effects, overwrite the entire ledBuffer.
        ledBuffer = tempBuffer;
      }
#endif
    }

    // Stop timing the update effects
    timeProfiler.stop(profilerKey);

    // Release mutex after buffer access
    xSemaphoreGive(bufferMutex);
  }
}

void LEDStrip::draw()
{
  if (xSemaphoreTake(bufferMutex, portMAX_DELAY) == pdTRUE)
  {
    if (!fliped)
    {
      for (uint16_t i = 0; i < numLEDs; i++)
        leds[i] = CRGB(ledBuffer[i].r, ledBuffer[i].g, ledBuffer[i].b);
    }
    else
    {
      for (uint16_t i = 0; i < numLEDs; i++)
        leds[numLEDs - 1 - i] = CRGB(ledBuffer[i].r, ledBuffer[i].g, ledBuffer[i].b);
    }
    xSemaphoreGive(bufferMutex);
  }
}

void LEDStrip::show()
{
  controller->showLeds(brightness);
  // FastLED.show();
}

CRGB *LEDStrip::getFastLEDBuffer() { return leds; }

Color *LEDStrip::getBuffer() { return ledBuffer; }

void LEDStrip::clearBuffer()
{
  if (xSemaphoreTake(bufferMutex, portMAX_DELAY) == pdTRUE)
  {
    for (uint16_t i = 0; i < numLEDs; i++)
    {
      ledBuffer[i].r = 0;
      ledBuffer[i].g = 0;
      ledBuffer[i].b = 0;
    }
    xSemaphoreGive(bufferMutex);
  }
}

void LEDStrip::clearBufferUnsafe()
{
  for (uint16_t i = 0; i < numLEDs; i++)
  {
    ledBuffer[i].r = 0;
    ledBuffer[i].g = 0;
    ledBuffer[i].b = 0;
  }
}

LEDStripType LEDStrip::getType() const { return type; }

uint16_t LEDStrip::getNumLEDs() const { return numLEDs; }

void LEDStrip::setFPS(uint16_t fps)
{
  this->fps = fps;
  // If task is running, restart it to apply new FPS
  if (running)
  {
    stop();
    start();
  }
}

uint16_t LEDStrip::getFPS() const { return fps; }

void LEDStrip::setFliped(bool _fliped)
{
  fliped = _fliped;
}

bool LEDStrip::getFliped() { return fliped; };

void LEDStrip::setBrightness(uint8_t brightness)
{
  this->brightness = brightness;
}

uint8_t LEDStrip::getBrightness() const
{
  return brightness;
}

// Task control functions
void LEDStrip::start()
{
  if (!running && taskHandle == nullptr)
  {
    running = true;
    xTaskCreatePinnedToCore(ledTask, taskName.c_str(), 4096, this, 1, &taskHandle, 0);
  }
}

void LEDStrip::stop()
{
  if (running && taskHandle != nullptr)
  {
    running = false;
    vTaskDelete(taskHandle);
    taskHandle = nullptr;
  }
}

bool LEDStrip::isRunning() const
{
  return running;
}

// Static task function
void LEDStrip::ledTask(void *parameter)
{
  LEDStrip *strip = static_cast<LEDStrip *>(parameter);
  strip->taskLoop();
}

// Task loop implementation
void LEDStrip::taskLoop()
{
  TickType_t lastWakeTime = xTaskGetTickCount();
  const TickType_t frameDelay = pdMS_TO_TICKS(1000 / fps);

  // Serial.println("LEDStrip::taskLoop: Starting task loop, delay: " + String(frameDelay) + " fps: " + String(fps));
  // vTaskDelay(1000 / portTICK_PERIOD_MS);

  while (running)
  {
    String frameProfilerKey = taskName + "_Frame";
    String drawProfilerKey = taskName + "_Draw";
    String showProfilerKey = taskName + "_Show";

    // Start timing the entire frame
    timeProfiler.start(frameProfilerKey);
    timeProfiler.increment(taskName + "_FPS");

    // Time the draw operation
    timeProfiler.start(drawProfilerKey);
    draw();
    timeProfiler.stop(drawProfilerKey);

    // Time the show operation
    timeProfiler.start(showProfilerKey);
    show();
    timeProfiler.stop(showProfilerKey);

    // Stop timing the entire frame
    timeProfiler.stop(frameProfilerKey);

    // Wait for next frame
    // vTaskDelayUntil(&lastWakeTime, frameDelay);
    vTaskDelay(frameDelay);
  }

  // Clean up task when stopping
  vTaskDelete(nullptr);
}
========
==== IO/LED/LEDStrip.h: ====
#pragma once

#include <stdint.h>
#include <vector>
#include "Effects.h"
#include <Arduino.h>
#include "FastLED.h"
#include "../TimeProfiler.h"

// ####################################
//  Uncomment this line to use double buffering for more complex transparent effects.
//  #define USE_2_BUFFERS
// ####################################

// Enum to identify different LED strip types
enum class LEDStripType
{
  NONE,
  HEADLIGHT,
  TAILLIGHT,
  UNDERGLOW,
  INTERIOR,
  // Add more types as needed
};
struct Color
{
  uint8_t r;
  uint8_t g;
  uint8_t b;
  uint8_t w;

  Color() : r(0), g(0), b(0), w(0) {}
  Color(uint8_t red, uint8_t green, uint8_t blue)
      : r(red), g(green), b(blue), w(0) {}
  Color(uint8_t red, uint8_t green, uint8_t blue, uint8_t white)
      : r(red), g(green), b(blue), w(white) {}

  static Color hsv2rgb(float h, float s, float v);
  static Color rgb2hsv(uint8_t r, uint8_t g, uint8_t b);

  uint32_t to32Bit();

  static const Color WHITE;
  static const Color BLACK;
  static const Color RED;
  static const Color ORANGE;
  static const Color GREEN;
  static const Color BLUE;
  static const Color YELLOW;
  static const Color CYAN;
  static const Color MAGENTA;

  bool operator==(const Color &other) const
  {
    return r == other.r && g == other.g && b == other.b && w == other.w;
  }

  bool operator!=(const Color &other) const
  {
    return !(*this == other);
  }

  /**
   * @brief Multiplies the color by a scalar value
   * @param scalar A floating-point value between 0 and 1
   * @return A new Color object with RGBW components scaled by the scalar value
   */
  Color operator*(float scalar) const
  {
    return Color(r * scalar, g * scalar, b * scalar, w * scalar);
  }
};

class LEDEffect; // Forward declaration of effect class

class LEDStrip
{

public:
  // Constructor that allocates an LED buffer based on the number of LEDs.
  LEDStrip(uint16_t numLEDs, uint8_t ledPin);
  virtual ~LEDStrip();

  // Add an effect to the manager.
  // Effects with higher priority override lower-priority ones.
  void addEffect(LEDEffect *effect);

  // Remove an effect.
  void removeEffect(LEDEffect *effect);

  // Update all effects (call update() and then render() for each effect)
  void updateEffects();

  // draw the LED buffer to the physical LED strip
  void draw();
  void show();

  // Access the internal FastLED buffer.
  CRGB *getFastLEDBuffer();

  // Access the internal LED buffer.
  Color *getBuffer();

  // Clear the LED buffer (set all LEDs to black/off)
  void clearBuffer();

  // Get the type of the LED strip.
  LEDStripType getType() const;

  // Get the total number of LEDs.
  uint16_t getNumLEDs() const;

  void setFPS(uint16_t fps);
  uint16_t getFPS() const;

  void setFliped(bool _fliped);
  bool getFliped();

  void setBrightness(uint8_t brightness);
  uint8_t getBrightness() const;

  // Task control functions
  void start();
  void stop();
  bool isRunning() const;

  // Public mutex for external buffer access
  SemaphoreHandle_t bufferMutex;

  CLEDController *controller;

private:
  friend class LEDStripConfig;
  LEDStripType type;
  uint16_t numLEDs;
  Color *ledBuffer;

  bool fliped;
  uint16_t fps;

  uint8_t ledPin;
  CRGB *leds;
  uint8_t brightness;

  std::vector<LEDEffect *> effects;

  // Task-related members
  TaskHandle_t taskHandle;
  bool running;
  String taskName;
  static void ledTask(void *parameter);
  void taskLoop();

  // Private buffer clear without mutex (for internal use)
  void clearBufferUnsafe();
};
========
==== IO/LED/LEDStripManager.cpp: ====
#include "LEDStripManager.h"
#include "LEDStrip.h" // Include this for full definitions
#include "../../config.h"
#include <Arduino.h>
#include <set> // Add include for std::set
#include <map>
#include "IO/TimeProfiler.h"

// Initialize static instance pointer
LEDStripManager *LEDStripManager::instance = nullptr;

LEDStripManager *LEDStripManager::getInstance()
{
  if (!instance)
  {
    instance = new LEDStripManager();
  }
  return instance;
}

LEDStripManager::LEDStripManager()
{
  // Store this instance in the static pointer for callbacks to use
  instance = this;
  drawFPS = 150;
  ledTaskHandle = NULL;
  taskRunning = false;
}

LEDStripManager::~LEDStripManager()
{
  // Clean up all LEDManager instances
  for (auto &pair : strips)
  {
    if (pair.second.strip)
    {
      delete pair.second.strip;
      pair.second.strip = nullptr;
    }
  }

  strips.clear();

  // Clear the static instance
  if (instance == this)
  {
    instance = nullptr;
  }
}

void LEDStripManager::begin()
{
  setBrightness(255);
}

LEDStrip *LEDStripManager::getStrip(LEDStripType type)
{
  if (strips.find(type) != strips.end())
  {
    return strips[type].strip;
  }
  return nullptr;
}

Color *LEDStripManager::getStripBuffer(LEDStripType type)
{
  if (strips.find(type) != strips.end() && strips[type].strip)
  {
    return strips[type].strip->getBuffer();
  }
  return nullptr;
}

uint16_t LEDStripManager::getStripLEDCount(LEDStripType type)
{
  if (strips.find(type) != strips.end())
  {
    return strips[type].strip ? strips[type].strip->getNumLEDs() : 0;
  }
  return 0;
}

bool LEDStripManager::isStripEnabled(LEDStripType type)
{
  return strips.count(type) > 0;
}

void LEDStripManager::addLEDStrip(const LEDStripConfig &config)
{

  if (strips.find(config.type) != strips.end())
  {
    Serial.println("LEDStripManager::addLEDStrip: LED strip already exists");
    return;
  }

  // Add to the map of strips
  strips[config.type] = config;
  // Serial.println("LEDStripManager::addLEDStrip: Setting FPS to " + String(drawFPS));
  strips[config.type].strip->setFPS(drawFPS);
  strips[config.type].strip->setBrightness(255);
  // strips[config.type].strip->start();
}

void LEDStripManager::setBrightness(uint8_t brightness)
{
  for (auto &pair : strips)
  {
    if (pair.second.strip)
      pair.second.strip->setBrightness(brightness);
  }
}

void LEDStripManager::updateEffects()
{

  for (auto &pair : strips)
  {
    if (pair.second.strip)
    {
      pair.second.strip->updateEffects();
    }
  }
}

void LEDStripManager::draw()
{
  timeProfiler.start("drawEffects", TimeUnit::MICROSECONDS);
  timeProfiler.increment("ledFps");

  // Draw all strips
  for (auto &pair : strips)
  {
    if (pair.second.strip)
    {
      pair.second.strip->draw();
      pair.second.strip->show();
    }
  }

  timeProfiler.stop("drawEffects");
}

// Task management functions
void LEDStripManager::startTask()
{
  if (taskRunning)
  {
    Serial.println("LEDStripManager: Task already running");
    return;
  }

  taskRunning = true;

  // Create the LED task with high priority for smooth LED updates
  xTaskCreatePinnedToCore(
      ledTask,        // Task function
      "LEDStripTask", // Task name
      4096,           // Stack size
      this,           // Parameter passed to task
      5,              // Priority (higher priority for LED updates)
      &ledTaskHandle, // Task handle
      0               // Core to run on
  );

  Serial.println("LEDStripManager: Task started");
}

void LEDStripManager::stopTask()
{
  if (!taskRunning)
  {
    Serial.println("LEDStripManager: Task not running");
    return;
  }

  taskRunning = false;

  if (ledTaskHandle != NULL)
  {
    vTaskDelete(ledTaskHandle);
    ledTaskHandle = NULL;
  }

  Serial.println("LEDStripManager: Task stopped");
}

bool LEDStripManager::isTaskRunning()
{
  return taskRunning;
}

// Static task function for FreeRTOS
void LEDStripManager::ledTask(void *parameter)
{
  LEDStripManager *manager = static_cast<LEDStripManager *>(parameter);

  // Calculate delay in ticks based on FPS
  const TickType_t delayTicks = pdMS_TO_TICKS(1000 / manager->drawFPS);

  Serial.println("LEDStripManager: Task loop started with FPS: " + String(manager->drawFPS));

  while (manager->taskRunning)
  {
    // Draw all strips
    manager->draw();

    // Delay to maintain FPS
    vTaskDelay(delayTicks);
  }

  // Clean up when task ends
  manager->ledTaskHandle = NULL;
  vTaskDelete(NULL);
}
========
==== IO/LED/LEDStripManager.h: ====
#pragma once

#include "LEDStrip.h"
// #include "FastLED.h"
#include <map>
#include <string>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

// Structure to store LED strip configuration
struct LEDStripConfig
{
  LEDStripType type;
  LEDStrip *strip;  // Pointer to the LEDManager for this strip
  std::string name; // Human-readable name for the strip

  // Default constructor
  LEDStripConfig() : type(LEDStripType::NONE), strip(nullptr), name("") {}

  LEDStripConfig(LEDStripType _type, LEDStrip *_strip, const std::string &_name) : type(_type),
                                                                                   strip(_strip),
                                                                                   name(_name)
  {
    _strip->type = type;
  }
};

class LEDStripManager
{
public:
  static LEDStripManager *instance;
  static LEDStripManager *getInstance();

  // Constructor
  LEDStripManager();

  // Destructor
  ~LEDStripManager();

  // Initialize the LED strip manager with the different strip configurations
  void begin();

  // Get a LEDManager instance by strip type
  LEDStrip *getStrip(LEDStripType type);

  // Get the LED buffer for a specific strip type
  Color *getStripBuffer(LEDStripType type);

  // Get the number of LEDs for a specific strip type
  uint16_t getStripLEDCount(LEDStripType type);

  // Check if a strip type is enabled
  bool isStripEnabled(LEDStripType type);

  // Add an LED strip configuration
  void addLEDStrip(const LEDStripConfig &config);

  // Set global brightness for all strips
  void setBrightness(uint8_t brightness);

  // update all effects
  void updateEffects();

  // draw all strips
  void draw();

  // Task management functions
  void startTask();
  void stopTask();
  bool isTaskRunning();

private:
  // Map of LED strip configurations by type
  std::map<LEDStripType, LEDStripConfig> strips;

  uint64_t lastDrawTime;
  uint16_t drawFPS;

  // Task-related members
  TaskHandle_t ledTaskHandle;
  bool taskRunning;

  // Static task function for FreeRTOS
  static void ledTask(void *parameter);
};========
==== IO/LED/Types.cpp: ====
#include "Types.h"
#include "Effects/SolidColorEffect.h"

String RGBSyncData::print()
{
  return String("Hue Center: " + String(hueCenter) + ", Hue Edge: " + String(hueEdge) + ", Speed: " + String(speed) + ", Hue Offset: " + String(hueOffset) + ", Active: " + String(active));
}

String NightRiderSyncData::print()
{
  return String("Cycle Time: " + String(cycleTime) + ", Tail Length: " + String(tailLength) + ", Progress: " + String(progress) + ", Forward: " + String(forward) + ", Active: " + String(active));
}

String PoliceSyncData::print()
{
  return String("Mode: " + String((int)mode) + ", Flash Progress: " + String(flashProgress) + ", Cycle Progress: " + String(cycleProgress) + ", Current Flash: " + String(currentFlash) + ", Active: " + String(active));
}

String SolidColorSyncData::print()
{
  return String("Color Preset: " + String((int)colorPreset) + ", RGB: (" + String(customR) + "," + String(customG) + "," + String(customB) + "), Active: " + String(active));
}

String ColorFadeSyncData::print()
{
  return String("Hold Time: " + String(holdTime) + ", Fade Time: " + String(fadeTime) + ", Progress: " + String(progress) + ", Current Color Index: " + String(currentColorIndex) + ", In Fade Phase: " + String(inFadePhase) + ", Active: " + String(active));
}

void EffectSyncState::print()
{
  Serial.println("RGB: " + rgbSyncData.print());
  Serial.println("Night Rider: " + nightRiderSyncData.print());
  Serial.println("Police: " + policeSyncData.print());
  Serial.println("Solid Color: " + solidColorSyncData.print());
  Serial.println("Color Fade: " + colorFadeSyncData.print());
}
========
==== IO/LED/Types.h: ====
#pragma once

#include <Arduino.h>

struct __attribute__((packed)) RGBSyncData
{
  float hueCenter;
  float hueEdge;
  float speed;
  float hueOffset;
  bool active;

  String print();
};
struct __attribute__((packed)) NightRiderSyncData
{
  float cycleTime;
  float tailLength;
  float progress;
  bool forward;
  bool active;

  String print();
};

enum class PoliceMode
{
  SLOW,
  FAST
};

struct __attribute__((packed)) PoliceSyncData
{
  bool active;
  PoliceMode mode;
  float flashProgress;
  float cycleProgress;
  uint16_t currentFlash;

  String print();
};

// Predefined colors enum
enum class SolidColorPreset
{
  OFF = 0,
  RED,
  GREEN,
  BLUE,
  WHITE,
  YELLOW,
  CYAN,
  MAGENTA,
  ORANGE,
  PURPLE,
  LIME,
  PINK,
  TEAL,
  INDIGO,
  GOLD,
  SILVER,
  CUSTOM
};

struct __attribute__((packed)) SolidColorSyncData
{
  bool active;
  SolidColorPreset colorPreset;
  uint8_t customR;
  uint8_t customG;
  uint8_t customB;

  String print();
};

struct __attribute__((packed)) ColorFadeSyncData
{
  bool active;
  float holdTime;            // Time to hold each color (seconds)
  float fadeTime;            // Time to fade between colors (seconds)
  float progress;            // Current progress through the cycle [0.0, 1.0]
  uint8_t currentColorIndex; // Index of the current color in the list
  bool inFadePhase;          // true if currently fading, false if holding

  String print();
};

struct __attribute__((packed)) EffectSyncState
{
  RGBSyncData rgbSyncData;
  NightRiderSyncData nightRiderSyncData;
  PoliceSyncData policeSyncData;
  SolidColorSyncData solidColorSyncData;
  ColorFadeSyncData colorFadeSyncData;

  void print();
};========
==== IO/LEDMenu.cpp: ====
#include "LEDMenu.h"
#include "esp_log.h"

static const char *TAG = "LEDMenu";

// default patterns - updated to use new pattern system
const LEDPattern LEDMenu::IDLE_PATTERN = LEDPattern(0x00ff00, 0x001100);
const LEDPattern LEDMenu::EDITING_PATTERN = LEDPattern::createAlternating(0xFF0000, 0x000000, 0x0000FF, 0x000000, 250);

std::map<ButtonEventType, String> buttonEventTypeStrings = {
    {ButtonEventType::SINGLE_CLICK, "SINGLE_CLICK"},
    {ButtonEventType::DOUBLE_CLICK, "DOUBLE_CLICK"},
    {ButtonEventType::TRIPLE_CLICK, "TRIPLE_CLICK"},
    {ButtonEventType::LONG_CLICK, "LONG_CLICK"},
    {ButtonEventType::DOUBLE_LONG_CLICK, "DOUBLE_LONG_CLICK"},
    {ButtonEventType::TRIPLE_LONG_CLICK, "TRIPLE_LONG_CLICK"},
};

std::map<ButtonType, String> buttonTypeStrings = {
    {ButtonType::BOOT, "BOOT"},
    {ButtonType::PREV, "PREV"},
    {ButtonType::SELECT, "SELECT"},
    {ButtonType::NEXT, "NEXT"},
};

// LEDMenuItem implementation
LEDMenuItem LEDMenuItem::createAction(const String &name,
                                      std::function<void()> cb,
                                      const LEDPattern &pattern,
                                      const LEDPattern &editPattern)
{
  LEDMenuItem i;
  i.name = name;
  i.type = LEDMenuItemType::ACTION;
  i.pattern = pattern;
  i.editingPattern = editPattern.type != LEDPatternType::SOLID || editPattern.led1Color != 0 || editPattern.led2Color != 0 ? editPattern : LEDMenu::EDITING_PATTERN;
  i.actionCallback = cb;
  return i;
}

LEDMenuItem LEDMenuItem::createToggle(const String &name,
                                      bool *ptr,
                                      const LEDPattern &pattern,
                                      const LEDPattern &editPattern)
{
  LEDMenuItem i;
  i.name = name;
  i.type = LEDMenuItemType::TOGGLE;
  i.pattern = pattern;
  i.editingPattern = editPattern.type != LEDPatternType::SOLID || editPattern.led1Color != 0 || editPattern.led2Color != 0 ? editPattern : LEDMenu::EDITING_PATTERN;
  i.toggleValuePtr = ptr;
  return i;
}

LEDMenuItem LEDMenuItem::createSelect(const String &name,
                                      int *ptr,
                                      int minV,
                                      int maxV,
                                      std::vector<String> *opts,
                                      const LEDPattern &pattern,
                                      const LEDPattern &editPattern,
                                      std::function<void()> onSave)
{
  LEDMenuItem i;
  i.name = name;
  i.type = LEDMenuItemType::SELECT;
  i.pattern = pattern;
  i.editingPattern = editPattern.type != LEDPatternType::SOLID || editPattern.led1Color != 0 || editPattern.led2Color != 0 ? editPattern : LEDMenu::EDITING_PATTERN;
  i.intValuePtr = ptr;
  i.minValue = minV;
  i.maxValue = maxV;
  i.options = opts;
  i.actionCallback = onSave;
  return i;
}

LEDMenuItem LEDMenuItem::createSubMenu(const String &name,
                                       std::vector<LEDMenuItem> *subItems,
                                       const LEDPattern &pattern)
{
  LEDMenuItem i;
  i.name = name;
  i.type = LEDMenuItemType::SUBMENU;
  i.pattern = pattern;
  i.subMenuItems = subItems;
  return i;
}

LEDMenuItem LEDMenuItem::createBack(const String &name,
                                    const LEDPattern &pattern)
{
  LEDMenuItem i;
  i.name = name;
  i.type = LEDMenuItemType::BACK;
  i.pattern = pattern.type != LEDPatternType::SOLID || pattern.led1Color != 0 || pattern.led2Color != 0 ? pattern : LEDPattern::createFlash(0xFFA500, 0xFFA500, 300, 1700);
  return i;
}

void LEDMenuItem::startEditing()
{
  state = LEDMenuItemState::EDITING;
  currentValue = getCurrentValue();
  valueModified = false;
}

void LEDMenuItem::stopEditing()
{
  state = LEDMenuItemState::NORMAL;
  valueModified = false;
}

void LEDMenuItem::incrementValue()
{
  if (type == LEDMenuItemType::TOGGLE)
  {
    currentValue = !currentValue;
    valueModified = true;
  }
  else if (type == LEDMenuItemType::SELECT && currentValue < maxValue)
  {
    currentValue++;
    valueModified = true;
  }
}

void LEDMenuItem::decrementValue()
{
  if (type == LEDMenuItemType::TOGGLE)
  {
    currentValue = !currentValue;
    valueModified = true;
  }
  else if (type == LEDMenuItemType::SELECT && currentValue > minValue)
  {
    currentValue--;
    valueModified = true;
  }
}

int LEDMenuItem::getCurrentValue() const
{
  if (type == LEDMenuItemType::TOGGLE)
    return toggleValuePtr && *toggleValuePtr ? 1 : 0;
  if (type == LEDMenuItemType::SELECT)
    return intValuePtr ? *intValuePtr : 0;
  return 0;
}

void LEDMenuItem::setCurrentValue(int v)
{
  if (type == LEDMenuItemType::TOGGLE && toggleValuePtr)
    *toggleValuePtr = (v != 0);
  if (type == LEDMenuItemType::SELECT && intValuePtr)
    *intValuePtr = constrain(v, minValue, maxValue);
}

void LEDMenuItem::saveValue()
{
  if (valueModified)
  {
    setCurrentValue(currentValue);
    if (actionCallback)
      actionCallback();
  }
  stopEditing();
}

void LEDMenuItem::cancelEdit()
{
  currentValue = getCurrentValue(); // Reset to original value
  stopEditing();
}

LEDPattern LEDMenuItem::getCurrentPattern() const
{
  return isEditing() ? editingPattern : pattern;
}

// LEDMenu implementation
LEDMenu::LEDMenu() {}
LEDMenu::~LEDMenu() { clearMenuItems(); }

void LEDMenu::begin()
{
  ESP_LOGI(TAG, "LEDMenu init");
  _patternStartTime = millis();
  _showPattern(IDLE_PATTERN);
}

void LEDMenu::setEnabled(bool ena)
{
  if (_enabled == ena)
    return;
  _enabled = ena;
  if (_enabled)
  {
    ESP_LOGI(TAG, "Menu enabled");
    _showPattern(IDLE_PATTERN);
  }
  else
  {
    ESP_LOGI(TAG, "Menu disabled");
    _exitMenu();
  }
}

bool LEDMenu::isEnabled() const { return _enabled; }

void LEDMenu::addMenuItem(const LEDMenuItem &item)
{
  _rootMenuItems.push_back(item);
  ESP_LOGD(TAG, "Added menu item '%s'", item.name.c_str());
}

void LEDMenu::clearMenuItems()
{
  _rootMenuItems.clear();
  _menuStack.clear();
}

void LEDMenu::enterSubMenu(std::vector<LEDMenuItem> *subItems)
{
  if (subItems && !subItems->empty())
  {
    _menuStack.push_back(MenuLevel(subItems, 0));
    _patternStartTime = millis();
    ESP_LOGI(TAG, "Entered submenu with %d items", subItems->size());
  }
}

void LEDMenu::exitSubMenu()
{
  if (_menuStack.size() > 1)
  {
    _menuStack.pop_back();
    _patternStartTime = millis();
    ESP_LOGI(TAG, "Exited submenu");
  }
  else
  {
    _exitMenu();
  }
}

void LEDMenu::update()
{
  if (!_enabled)
    return;
  _updateLEDs();
  if (_state != LEDMenuState::IDLE && _timedOut())
  {
    ESP_LOGI(TAG, "Auto-exit menu (timeout)");
    _exitMenu();
  }
}

void LEDMenu::handleButtonEvent(const ButtonEvent &ev)
{
  if (!_enabled)
    return;
  _resetActivity();

  // print event
  ESP_LOGI(TAG, "Button event: %s, %s", buttonTypeStrings[ev.button].c_str(), buttonEventTypeStrings[ev.type].c_str());

  if (_state == LEDMenuState::IDLE)
  {
    if (ev.button == ButtonType::SELECT && ev.type == ButtonEventType::LONG_CLICK)
    {
      _enterMenu();
    }
  }
  else
  {
    LEDMenuItem *currentItem = _getCurrentItem();
    if (currentItem && currentItem->isEditing())
    {
      _onEditingEvent(ev);
    }
    else
    {
      _onMenuEvent(ev);
    }
  }
}

void LEDMenu::exit()
{
  _exitMenu();
}

// — state transitions —

void LEDMenu::_enterMenu()
{
  if (_rootMenuItems.empty())
  {
    ESP_LOGW(TAG, "No items – cannot enter menu");
    return;
  }
  _state = LEDMenuState::ACTIVE;
  _menuStack.clear();
  _menuStack.push_back(MenuLevel(&_rootMenuItems, 0));
  _patternStartTime = millis();
  ESP_LOGI(TAG, "Entered menu");
}

void LEDMenu::_exitMenu()
{
  // Stop any editing
  LEDMenuItem *currentItem = _getCurrentItem();
  if (currentItem && currentItem->isEditing())
  {
    currentItem->stopEditing();
  }

  _state = LEDMenuState::IDLE;
  _menuStack.clear();
  _patternStartTime = millis();
  ESP_LOGI(TAG, "Exited menu");
}

// — event dispatch —

void LEDMenu::_onMenuEvent(const ButtonEvent &ev)
{
  if (ev.type != ButtonEventType::SINGLE_CLICK)
    return;

  switch (ev.button)
  {
  case ButtonType::BOOT:
    exitSubMenu();
    break;
  case ButtonType::NEXT:
    _incrementCurrentItem();
    break;
  case ButtonType::PREV:
    _decrementCurrentItem();
    break;
  case ButtonType::SELECT:
    _executeCurrentItem();
    break;
  }
}

void LEDMenu::_onEditingEvent(const ButtonEvent &ev)
{
  LEDMenuItem *currentItem = _getCurrentItem();
  if (!currentItem)
    return;

  // BOOT cancels edit
  if (ev.button == ButtonType::BOOT && ev.type == ButtonEventType::SINGLE_CLICK)
  {
    currentItem->cancelEdit();
    _patternStartTime = millis();
    return;
  }

  // SELECT saves & calls onSave
  if (ev.button == ButtonType::SELECT && ev.type == ButtonEventType::SINGLE_CLICK)
  {
    ESP_LOGI(TAG, "Saved value=%d", currentItem->currentValue);
    currentItem->saveValue();
    _patternStartTime = millis();
    return;
  }

  if (ev.type != ButtonEventType::SINGLE_CLICK)
    return;

  switch (ev.button)
  {
  case ButtonType::NEXT:
    currentItem->incrementValue();
    break;
  case ButtonType::PREV:
    currentItem->decrementValue();
    break;
  default:
    break;
  }
}

// — core logic —

void LEDMenu::_incrementCurrentItem()
{
  MenuLevel *level = _getCurrentLevel();
  if (!level || !level->items || level->items->empty())
    return;

  level->currentIndex = (level->currentIndex + 1) % level->items->size();
  _patternStartTime = millis();
  ESP_LOGD(TAG, "Menu idx=%d", level->currentIndex);
}

void LEDMenu::_decrementCurrentItem()
{
  MenuLevel *level = _getCurrentLevel();
  if (!level || !level->items || level->items->empty())
    return;

  if (level->currentIndex == 0)
    level->currentIndex = level->items->size() - 1;
  else
    level->currentIndex--;
  _patternStartTime = millis();
  ESP_LOGD(TAG, "Menu idx=%d", level->currentIndex);
}

void LEDMenu::_executeCurrentItem()
{
  LEDMenuItem *item = _getCurrentItem();
  if (!item)
    return;

  switch (item->type)
  {
  case LEDMenuItemType::ACTION:
    ESP_LOGI(TAG, "Action '%s'", item->name.c_str());
    if (item->actionCallback)
      item->actionCallback();
    break;

  case LEDMenuItemType::TOGGLE:
  case LEDMenuItemType::SELECT:
    item->startEditing();
    _patternStartTime = millis();
    ESP_LOGI(TAG, "Editing '%s'", item->name.c_str());
    break;

  case LEDMenuItemType::SUBMENU:
    if (item->subMenuItems)
    {
      enterSubMenu(item->subMenuItems);
      ESP_LOGI(TAG, "Entered submenu '%s'", item->name.c_str());
    }
    break;

  case LEDMenuItemType::BACK:
    exitSubMenu();
    ESP_LOGI(TAG, "Back from submenu");
    break;
  }
}

LEDMenuItem *LEDMenu::_getCurrentItem()
{
  MenuLevel *level = _getCurrentLevel();
  if (!level || !level->items || level->items->empty())
    return nullptr;

  if (level->currentIndex < 0 || level->currentIndex >= level->items->size())
    return nullptr;

  return &(*level->items)[level->currentIndex];
}

LEDMenu::MenuLevel *LEDMenu::_getCurrentLevel()
{
  if (_menuStack.empty())
    return nullptr;
  return &_menuStack.back();
}

// — LEDs & timing —

void LEDMenu::_resetActivity()
{
  _lastActivity = millis();
}

bool LEDMenu::_timedOut() const
{
  return (millis() - _lastActivity) >= AUTO_EXIT_TIMEOUT;
}

void LEDMenu::_updateLEDs()
{
  LEDPattern currentPattern;

  if (_state == LEDMenuState::IDLE)
  {
    currentPattern = IDLE_PATTERN;
  }
  else
  {
    LEDMenuItem *item = _getCurrentItem();
    if (item)
    {
      currentPattern = item->getCurrentPattern();
    }
    else
    {
      currentPattern = IDLE_PATTERN;
    }
  }

  _showPattern(currentPattern);
}

void LEDMenu::_showPattern(const LEDPattern &p)
{
  uint32_t now = millis();
  uint32_t elapsed = now - _patternStartTime;

  switch (p.type)
  {
  case LEDPatternType::SOLID:
  {
    statusLed1.setMode(RGB_MODE::Overide);
    statusLed1.setOverideColor(p.led1Color);
    statusLed2.setMode(RGB_MODE::Overide);
    statusLed2.setOverideColor(p.led2Color);
    break;
  }

  case LEDPatternType::BLINK:
  {
    uint32_t cycleTime = elapsed % p.period;
    bool isOn = cycleTime < p.onTime;

    // Handle blink count limit
    if (p.blinkCount > 0)
    {
      uint32_t completedCycles = elapsed / p.period;
      if (completedCycles >= p.blinkCount)
      {
        isOn = false; // Stay off after completing blink count
      }
    }

    statusLed1.setMode(RGB_MODE::Overide);
    statusLed2.setMode(RGB_MODE::Overide);

    if (isOn)
    {
      statusLed1.setOverideColor(p.led1Color);
      statusLed2.setOverideColor(p.led2Color);
    }
    else
    {
      statusLed1.setOverideColor(0x000000);
      statusLed2.setOverideColor(0x000000);
    }
    break;
  }

  case LEDPatternType::PULSE:
  {
    uint8_t brightness = _calculatePulseBrightness(elapsed, p.period, p.minBrightness, p.maxBrightness);

    statusLed1.setMode(RGB_MODE::Overide);
    statusLed2.setMode(RGB_MODE::Overide);
    statusLed1.setOverideColor(_modulateBrightness(p.led1Color, brightness));
    statusLed2.setOverideColor(_modulateBrightness(p.led2Color, brightness));
    break;
  }

  case LEDPatternType::ALTERNATE:
  {
    uint32_t cycleTime = elapsed % p.period;
    bool useAlternate = cycleTime >= p.onTime;

    statusLed1.setMode(RGB_MODE::Overide);
    statusLed2.setMode(RGB_MODE::Overide);

    if (useAlternate)
    {
      statusLed1.setOverideColor(p.led1AltColor);
      statusLed2.setOverideColor(p.led2AltColor);
    }
    else
    {
      statusLed1.setOverideColor(p.led1Color);
      statusLed2.setOverideColor(p.led2Color);
    }
    break;
  }

  case LEDPatternType::FLASH:
  {
    uint32_t cycleTime = elapsed % p.period;
    bool isFlashing = cycleTime < p.onTime;

    statusLed1.setMode(RGB_MODE::Overide);
    statusLed2.setMode(RGB_MODE::Overide);

    if (isFlashing)
    {
      statusLed1.setOverideColor(p.led1Color);
      statusLed2.setOverideColor(p.led2Color);
    }
    else
    {
      statusLed1.setOverideColor(0x000000);
      statusLed2.setOverideColor(0x000000);
    }
    break;
  }

  case LEDPatternType::CUSTOM:
  {
    if (p.customFunction)
    {
      p.customFunction(elapsed, p.led1Color, p.led2Color);
    }
    else
    {
      // Fallback to solid pattern if no custom function
      statusLed1.setMode(RGB_MODE::Overide);
      statusLed1.setOverideColor(p.led1Color);
      statusLed2.setMode(RGB_MODE::Overide);
      statusLed2.setOverideColor(p.led2Color);
    }
    break;
  }
  }
}

uint32_t LEDMenu::_modulateBrightness(uint32_t color, uint8_t brightness)
{
  if (color == 0)
    return 0;

  uint8_t r = (color >> 16) & 0xFF;
  uint8_t g = (color >> 8) & 0xFF;
  uint8_t b = color & 0xFF;

  r = (r * brightness) / 255;
  g = (g * brightness) / 255;
  b = (b * brightness) / 255;

  return (r << 16) | (g << 8) | b;
}

uint8_t LEDMenu::_calculatePulseBrightness(uint32_t time, uint16_t period, uint8_t minBright, uint8_t maxBright)
{
  float phase = (float)(time % period) / (float)period;
  float sinValue = sin(phase * 2 * PI);
  float normalizedSin = (sinValue + 1.0f) / 2.0f; // Normalize to 0-1

  return minBright + (uint8_t)((maxBright - minBright) * normalizedSin);
}

LEDMenu ledMenu;
========
==== IO/LEDMenu.h: ====
#pragma once

#include "StatusLed.h"
#include <vector>
#include <functional>
#include <Arduino.h>
#include <map>

enum class LEDMenuState
{
  IDLE,
  ACTIVE
};

enum class LEDMenuItemType
{
  ACTION,
  TOGGLE,
  SELECT,
  SUBMENU,
  BACK
};

enum class LEDMenuItemState
{
  NORMAL,
  EDITING
};

enum class ButtonEventType
{
  SINGLE_CLICK,
  DOUBLE_CLICK,
  TRIPLE_CLICK,
  LONG_CLICK,
  DOUBLE_LONG_CLICK,
  TRIPLE_LONG_CLICK,
};

enum class ButtonType
{
  BOOT,
  PREV,
  SELECT,
  NEXT,
};

struct ButtonEvent
{
  ButtonType button;
  ButtonEventType type;
};

// Enhanced pattern types
enum class LEDPatternType
{
  SOLID,     // Static colors
  BLINK,     // Simple blinking
  PULSE,     // Sine wave brightness modulation
  ALTERNATE, // Alternating between two states
  FLASH,     // Quick flash pattern
  CUSTOM     // Custom pattern function
};

// Enhanced LED pattern structure
struct LEDPattern
{
  LEDPatternType type = LEDPatternType::SOLID;

  // Colors for different states
  uint32_t led1Color = 0x000000;    // Primary color for LED1
  uint32_t led2Color = 0x000000;    // Primary color for LED2
  uint32_t led1AltColor = 0x000000; // Alternate color for LED1 (for ALTERNATE type)
  uint32_t led2AltColor = 0x000000; // Alternate color for LED2 (for ALTERNATE type)

  // Timing parameters
  uint16_t period = 1000;   // Pattern period in ms
  uint16_t onTime = 500;    // On time for blink/flash patterns (ms)
  uint16_t phaseOffset = 0; // Phase offset between LEDs (ms)
  uint8_t blinkCount = 0;   // Number of blinks (0 = continuous)

  // Pulse parameters
  uint8_t minBrightness = 50;  // Minimum brightness for pulse (0-255)
  uint8_t maxBrightness = 255; // Maximum brightness for pulse (0-255)

  // Custom pattern function
  std::function<void(uint32_t time, uint32_t led1Color, uint32_t led2Color)> customFunction;

  // Constructors for backward compatibility and new features
  LEDPattern() = default;

  // Simple solid color constructor
  LEDPattern(uint32_t led1, uint32_t led2)
      : type(LEDPatternType::SOLID), led1Color(led1), led2Color(led2) {}

  // Simple blink constructor (backward compatibility)
  LEDPattern(uint32_t led1, uint32_t led2, uint16_t blinkPeriod, uint8_t count = 0)
      : type(LEDPatternType::BLINK), led1Color(led1), led2Color(led2),
        period(blinkPeriod), onTime(blinkPeriod / 2), blinkCount(count) {}

  // Advanced constructor
  LEDPattern(LEDPatternType patternType, uint32_t led1, uint32_t led2,
             uint16_t patternPeriod = 1000, uint16_t onDuration = 500,
             uint32_t led1Alt = 0x000000, uint32_t led2Alt = 0x000000)
      : type(patternType), led1Color(led1), led2Color(led2),
        led1AltColor(led1Alt), led2AltColor(led2Alt),
        period(patternPeriod), onTime(onDuration) {}

  // Pulse pattern constructor
  static LEDPattern createPulse(uint32_t led1, uint32_t led2, uint16_t pulsePeriod = 1000,
                                uint8_t minBright = 50, uint8_t maxBright = 255)
  {
    LEDPattern p;
    p.type = LEDPatternType::PULSE;
    p.led1Color = led1;
    p.led2Color = led2;
    p.period = pulsePeriod;
    p.minBrightness = minBright;
    p.maxBrightness = maxBright;
    return p;
  }

  // Alternating pattern constructor
  static LEDPattern createAlternating(uint32_t led1Primary, uint32_t led1Alt,
                                      uint32_t led2Primary, uint32_t led2Alt,
                                      uint16_t switchPeriod = 500)
  {
    LEDPattern p;
    p.type = LEDPatternType::ALTERNATE;
    p.led1Color = led1Primary;
    p.led2Color = led2Primary;
    p.led1AltColor = led1Alt;
    p.led2AltColor = led2Alt;
    p.period = switchPeriod * 2; // Full cycle
    p.onTime = switchPeriod;
    return p;
  }

  // Flash pattern constructor
  static LEDPattern createFlash(uint32_t led1, uint32_t led2,
                                uint16_t flashPeriod = 200, uint16_t pausePeriod = 1800)
  {
    LEDPattern p;
    p.type = LEDPatternType::FLASH;
    p.led1Color = led1;
    p.led2Color = led2;
    p.period = flashPeriod + pausePeriod;
    p.onTime = flashPeriod;
    return p;
  }

  // Custom pattern constructor
  static LEDPattern createCustom(std::function<void(uint32_t, uint32_t, uint32_t)> func,
                                 uint32_t led1Base = 0x000000, uint32_t led2Base = 0x000000)
  {
    LEDPattern p;
    p.type = LEDPatternType::CUSTOM;
    p.led1Color = led1Base;
    p.led2Color = led2Base;
    p.customFunction = func;
    return p;
  }
};

// Forward declaration for recursive menu structure
class LEDMenu;

struct LEDMenuItem
{
  String name;
  LEDMenuItemType type;
  LEDPattern pattern;
  LEDPattern editingPattern;
  LEDMenuItemState state = LEDMenuItemState::NORMAL;

  // for TOGGLE
  bool *toggleValuePtr = nullptr;
  // for SELECT
  int *intValuePtr = nullptr;
  int currentValue = 0; // Current editing value
  bool valueModified = false;
  int minValue = 0, maxValue = 0;
  std::vector<String> *options = nullptr;

  // for ACTION and SELECT on-save
  std::function<void()> actionCallback;

  // for SUBMENU
  std::vector<LEDMenuItem> *subMenuItems = nullptr;
  LEDMenu *parentMenu = nullptr;

  // Static factory methods
  static LEDMenuItem createAction(const String &name,
                                  std::function<void()> cb,
                                  const LEDPattern &pattern,
                                  const LEDPattern &editPattern = LEDPattern());
  static LEDMenuItem createToggle(const String &name,
                                  bool *ptr,
                                  const LEDPattern &pattern,
                                  const LEDPattern &editPattern = LEDPattern());
  static LEDMenuItem createSelect(const String &name,
                                  int *ptr,
                                  int minV,
                                  int maxV,
                                  std::vector<String> *opts,
                                  const LEDPattern &pattern,
                                  const LEDPattern &editPattern = LEDPattern(),
                                  std::function<void()> onSave = nullptr);
  static LEDMenuItem createSubMenu(const String &name,
                                   std::vector<LEDMenuItem> *subItems,
                                   const LEDPattern &pattern);
  static LEDMenuItem createBack(const String &name = "Back",
                                const LEDPattern &pattern = LEDPattern());

  // State management
  void startEditing();
  void stopEditing();
  bool isEditing() const { return state == LEDMenuItemState::EDITING; }

  // Value management
  void incrementValue();
  void decrementValue();
  int getCurrentValue() const;
  void setCurrentValue(int v);
  void saveValue();
  void cancelEdit();

  // Pattern management
  LEDPattern getCurrentPattern() const;
};

class LEDMenu
{
public:
  LEDMenu();
  ~LEDMenu();

  void begin();
  void update(); // drive LEDs & auto-exit
  void setEnabled(bool ena);
  bool isEnabled() const;
  void exit();

  void addMenuItem(const LEDMenuItem &item);
  void clearMenuItems();

  // Sub-menu support
  void enterSubMenu(std::vector<LEDMenuItem> *subItems);
  void exitSubMenu();
  bool isInSubMenu() const { return _menuStack.size() > 1; }

  // feed all button events here:
  void handleButtonEvent(const ButtonEvent &ev);

  // default patterns
  static const LEDPattern IDLE_PATTERN;
  static const LEDPattern EDITING_PATTERN;

private:
  struct MenuLevel
  {
    std::vector<LEDMenuItem> *items;
    int currentIndex;

    MenuLevel(std::vector<LEDMenuItem> *menuItems, int index = 0)
        : items(menuItems), currentIndex(index) {}
  };

  bool _enabled = false;
  LEDMenuState _state = LEDMenuState::IDLE;
  std::vector<LEDMenuItem> _rootMenuItems;
  std::vector<MenuLevel> _menuStack;

  // pattern timing and state
  uint32_t _patternTimer = 0;
  uint32_t _patternStartTime = 0;
  bool _patternState = false;
  uint8_t _blinkCounter = 0;

  // auto-exit
  uint32_t _lastActivity = 0;
  static const uint32_t AUTO_EXIT_TIMEOUT = 10000;

  // state transitions
  void _enterMenu();
  void _exitMenu();

  // rendering
  void _updateLEDs();
  void _showPattern(const LEDPattern &p);

  // helper functions for complex patterns
  uint32_t _modulateBrightness(uint32_t color, uint8_t brightness);
  uint8_t _calculatePulseBrightness(uint32_t time, uint16_t period, uint8_t minBright, uint8_t maxBright);

  // menu logic
  void _incrementCurrentItem();
  void _decrementCurrentItem();
  void _executeCurrentItem();

  // Current item access
  LEDMenuItem *_getCurrentItem();
  MenuLevel *_getCurrentLevel();

  // activity/time
  void _resetActivity();
  bool _timedOut() const;

  // event dispatch
  void _onMenuEvent(const ButtonEvent &ev);
  void _onEditingEvent(const ButtonEvent &ev);
};

extern LEDMenu ledMenu;========
==== IO/Menu.cpp: ====
#include "Menu.h"

static const char *TAG = "Menu";

// ###### MenuItem ######

MenuItem::MenuItem(String _name)
{
  type = MenuItemType::None;
  name = _name;

  // textColor = TFT_WHITE;
  // activeTextColor = TFT_BLACK;
  // bgColor = TFT_WHITE;
}

void MenuItem::addFunc(int8_t _clicksToRun, std::function<void()> _func)
{
  if (_clicksToRun == 0)
    return;

  ActionFunction actionFunc;
  actionFunc.clicksToRun = _clicksToRun;
  actionFunc.func = _func;

  functions.push_back(actionFunc);
}

void MenuItem::setName(String _name)
{
  name = _name;
}

String MenuItem::getName()
{
  return name;
}

MenuItemType MenuItem::getType()
{
  return type;
}

void MenuItem::setHidden(bool _hidden)
{

  if (_hidden == hidden)
    return;

  hidden = _hidden;

  if (hidden && parent != nullptr)
    if (parent->items[parent->active] == this)
    {
      // If the current item is hidden and it's the active item, move to another visible item
      if (parent->active < parent->numItems)
      {
        // Try to find the next non-hidden item
        bool foundNext = false;
        for (uint8_t i = parent->active + 1; i < parent->numItems; i++)
        {
          if (!parent->items[i]->isHidden())
          {
            parent->active = i;
            foundNext = true;
            break;
          }
        }

        // If no next item found, try to find the previous non-hidden item
        if (!foundNext)
        {
          for (int i = parent->active - 1; i >= 0; i--)
          {
            if (!parent->items[i]->isHidden())
            {
              parent->active = i;
              break;
            }
          }
        }
      }
    }

  // recompute numItemsPerPage with the hidden items removed
  uint8_t visiableNumItems = parent->items.size();
  for (uint8_t i = 0; i < visiableNumItems; i++)
  {
    if (parent->items[i]->isHidden())
    {
      visiableNumItems--;
    }
  }
  parent->numItemsPerPage = visiableNumItems < parent->maxItemsPerPage ? visiableNumItems : parent->maxItemsPerPage;
}

void MenuItem::setTextColor(u16_t _color)
{
  textColor = _color;
}

void MenuItem::setActiveTextColor(u16_t _color)
{
  activeTextColor = _color;
}

void MenuItem::setBgColor(u16_t _color)
{
  bgColor = _color;
}

bool MenuItem::isHidden()
{
  return hidden;
}

void MenuItem::run()
{
  if (functions.size() == 0 || BtnSel.clicks == 0)
    return;

  ESP_LOGI(TAG, "Running %s", name.c_str());
  ESP_LOGI(TAG, "Functions: %d", functions.size());

  for (uint8_t i = 0; i < functions.size(); i++)
  {
    if (BtnSel.clicks == functions[i].clicksToRun)
    {
      functions[i].func();
      break;
    }
  }
}

void MenuItem::executeFunc()
{
  if (functions.size() > 0 && functions[0].clicksToRun == 1)
    functions[0].func();
}

void MenuItem::executeFunc(int8_t _clicks)
{
  for (ActionFunction &actionFunc : functions)
  {
    if (actionFunc.clicksToRun == _clicks)
    {
      actionFunc.func();
      break;
    }
  }
}

// ###### MenuItemAction ######

MenuItemAction::MenuItemAction(String _name, int8_t _clicksToRun, std::function<void()> _func) : MenuItem(_name)
{
  type = MenuItemType::Action;

  addFunc(_clicksToRun, _func);
}

// ###### MenuItemNavigate ######

MenuItemNavigate::MenuItemNavigate(String _name, const Screen2 *_target) : MenuItem(_name)
{
  type = MenuItemType::Navigate;
  target = _target;

  addFunc(MENU_DEFUALT_CLICKS, [this]()
          {
            screenManager.setScreen(target);
            //
          });
}

void MenuItemNavigate::addRoute(int8_t _clicksToRun, const Screen2 *_target)
{
  addFunc(_clicksToRun, [this, _target]()
          {
            screenManager.setScreen(_target);
            //
          });
}

// ###### MenuItemBack ######

MenuItemBack::MenuItemBack() : MenuItem("Back")
{
  type = MenuItemType::Back;

  addFunc(MENU_DEFUALT_CLICKS, [this]()
          { 
            // Check if we're in a submenu first
            if (parent && parent->getParentMenu())
            {
              parent->getParentMenu()->clearActiveSubmenu();
            }
            else
            {
              screenManager.back();
            } });
}

// ###### MenuItemToggle ######

MenuItemToggle::MenuItemToggle(String _name, bool *_value, bool _isMutable) : MenuItem(_name)
{
  type = MenuItemType::Toggle;
  value = _value;
  isMutable = _isMutable;

  addFunc(MENU_DEFUALT_CLICKS, [this]()
          {
            if (isMutable)
              *value = !*value;
            if (onChange != nullptr)
              onChange();
            //
          });
}

void MenuItemToggle::setOnChange(std::function<void()> _onChange)
{
  onChange = _onChange;
}

void MenuItemToggle::removeOnChange()
{
  onChange = nullptr;
}

void MenuItemToggle::set(bool _value)
{
  if (isMutable)
    *value = _value;
}

bool MenuItemToggle::get()
{
  return *value;
}

// ###### MenuItemString ######

MenuItemString::MenuItemString(String _name, String *_value) : MenuItem(_name)
{
  type = MenuItemType::String;
  value = _value;

  addFunc(MENU_DEFUALT_CLICKS, [this]()
          {
            //
          });
}

void MenuItemString::setValue(String _value)
{
  *value = _value;
}

String MenuItemString::getValue()
{
  return *value;
}

// ###### MenuItemNumberBase ######

MenuItemNumberBase::MenuItemNumberBase(String _name)
    : MenuItem(_name)
{
  type = MenuItemType::Number;
}

bool MenuItemNumberBase::isSelected() const
{
  return selected;
}

void MenuItemNumberBase::setFastUpdate(bool _fastUpdate)
{
  fastUpdate = _fastUpdate;
}

bool MenuItemNumberBase::isFastUpdate()
{
  return fastUpdate;
}

// ###### MenuItemNumber ######

template <typename T>
MenuItemNumber<T>::MenuItemNumber(String _name, T *_value, T _min, T _max)
    : MenuItemNumberBase(_name), value(_value), min(_min), max(_max)
{
  determineValueType();
  isMutable = true;

  addFunc(1, [this]()
          { toggleSelected(); });
}

template <typename T>
MenuItemNumber<T>::MenuItemNumber(String _name, T *_value, T _min, T _max, T _step)
    : MenuItemNumberBase(_name), value(_value), min(_min), max(_max), step(_step)
{
  determineValueType();
  isMutable = true;

  addFunc(1, [this]()
          { toggleSelected(); });
}

template <typename T>
MenuItemNumber<T>::MenuItemNumber(String _name, T *_value)
    : MenuItemNumberBase(_name), value(_value),
      min(std::numeric_limits<T>::lowest()), max(std::numeric_limits<T>::max())
{
  determineValueType();
  isMutable = false;
}

template <typename T>
void MenuItemNumber<T>::determineValueType()
{
  if (std::is_same<T, int>::value)
    valueType = NumberValueType::INT;
  else if (std::is_same<T, float>::value)
    valueType = NumberValueType::FLOAT;
  else if (std::is_same<T, long>::value)
    valueType = NumberValueType::LONG;
  else if (std::is_same<T, uint8_t>::value)
    valueType = NumberValueType::UINT8_T;
  else if (std::is_same<T, uint32_t>::value)
    valueType = NumberValueType::UINT32_T;
  else
    valueType = NumberValueType::UNKNOWN;
}

template <typename T>
NumberValueType MenuItemNumber<T>::getValueType() const
{
  return valueType;
}

template <typename T>
void MenuItemNumber<T>::setOnChange(std::function<void()> _onChange)
{
  onChange = _onChange;
}

template <typename T>
void MenuItemNumber<T>::removeOnChange()
{
  onChange = nullptr;
}

template <typename T>
void MenuItemNumber<T>::toggleSelected()
{
  if (isMutable)
  {
    selected = !selected;

    if (!selected && onChange != nullptr)
      onChange();
  }
  else
    selected = false;
}

template <typename T>
void MenuItemNumber<T>::increase()
{
  if (value)
  {
    int64_t newValue = static_cast<int64_t>(*value) + static_cast<int64_t>(step);
    if (newValue <= static_cast<int64_t>(max))
    {
      *value = static_cast<T>(newValue);
    }
    if (isFastUpdate() && onChange != nullptr)
      onChange();
  }
}

template <typename T>
void MenuItemNumber<T>::decrease()
{
  if (value)
  {
    int64_t newValue = static_cast<int64_t>(*value) - static_cast<int64_t>(step);
    if (newValue >= static_cast<int64_t>(min))
    {
      *value = static_cast<T>(newValue);
    }
    if (isFastUpdate() && onChange != nullptr)
      onChange();
  }
}

// ##############################
// Implementation for MenuItemSubmenu
// ##############################

MenuItemSubmenu::MenuItemSubmenu(String _name, Menu *_submenu)
    : MenuItem(_name), submenu(_submenu)
{
  type = MenuItemType::Submenu;

  addFunc(MENU_DEFUALT_CLICKS, [this]()
          { 
            if (parent && submenu)
            {
              parent->setActiveSubmenu(submenu);
            } });
}

void MenuItemSubmenu::run()
{
  if (parent && submenu)
  {
    parent->setActiveSubmenu(submenu);
  }
}

// ##############################
// Implementation for MenuItemSelect
// ##############################

MenuItemSelect::MenuItemSelect(String _name,
                               const std::vector<String> &_options,
                               int initialIndex)
    : MenuItem(_name), options(_options)
{
  type = MenuItemType::Select;
  if (initialIndex >= 0 && initialIndex < (int)options.size())
  {
    currentIndex = initialIndex;
  }
  else
  {
    currentIndex = 0;
  }

  // When pressed, toggle selection mode.
  addFunc(MENU_DEFUALT_CLICKS, [this]()
          { toggleSelected(); });
}

void MenuItemSelect::nextOption()
{
  if (options.empty())
    return;
  currentIndex = (currentIndex + 1) % options.size();
  if (onChange)
    onChange();
}

void MenuItemSelect::prevOption()
{
  if (options.empty())
    return;
  currentIndex = (currentIndex - 1 + options.size()) % options.size();
  if (onChange)
    onChange();
}

String MenuItemSelect::getSelectedOption() const
{
  if (options.empty())
    return "";
  return options[currentIndex];
}

void MenuItemSelect::setCurrentIndex(int _index)
{
  if (_index >= 0 && _index < (int)options.size())
  {
    currentIndex = _index;
  }
}

int MenuItemSelect::getCurrentIndex() const
{
  return currentIndex;
}

void MenuItemSelect::setOnChange(std::function<void()> callback)
{
  onChange = callback;
}

void MenuItemSelect::toggleSelected()
{
  if (options.empty())
    return;
  selected = !selected;

  if (!selected && onChange)
    onChange();
}

bool MenuItemSelect::isSelected() const
{
  return selected;
}

void MenuItemSelect::run()
{
  // When the item is clicked, we simply toggle editing mode.
  // (The encoder events should now change the option if selected.)
  toggleSelected();
}

// ###### Menu ######

Menu::Menu()
{
  // name = _name;
  active = 0;
  setMenuSize(MenuSize::Medium);
}

Menu::Menu(MenuSize _size)
{
  active = 0;
  setMenuSize(_size);
}

void Menu::setItemsPerPage(uint8_t _itemsPerPage)
{
  maxItemsPerPage = _itemsPerPage;
}

uint8_t Menu::getItemsPerPage()
{
  return maxItemsPerPage;
}

void Menu::setMenuSize(MenuSize _size)
{
  menuSize = _size;

  // Adjust default items per page based on size
  switch (_size)
  {
  case MenuSize::Small:
    maxItemsPerPage = 6;
    break;
  case MenuSize::Medium:
    maxItemsPerPage = 4;
    break;
  case MenuSize::Large:
    maxItemsPerPage = 3;
    break;
  default:
    maxItemsPerPage = 3;
    break;
  }

  numItems = items.size();
  numItemsPerPage = numItems < maxItemsPerPage ? numItems : maxItemsPerPage;
}

MenuSize Menu::getMenuSize() const
{
  return menuSize;
}

void Menu::setActive(uint8_t _active)
{
  active = _active;
}

uint8_t Menu::getActive()
{
  return active;
}

void Menu::nextItem()
{
  if (active < numItems - 1)
  {
    uint8_t startPosition = active;
    do
    {
      active++;
      // If we've checked all items and come back to where we started, break to prevent infinite loop
      if (active >= numItems)
      {
        active = startPosition; // Reset to original position
        break;
      }
    } while (items[active]->isHidden());
  }
}

void Menu::prevItem()
{
  if (active > 0)
  {
    uint8_t startPosition = active;
    do
    {
      active--;
      // If we've checked all items and come back to where we started, break to prevent infinite loop
      if (active >= numItems)
      {                         // This condition handles underflow when active becomes 255
        active = startPosition; // Reset to original position
        break;
      }
    } while (items[active]->isHidden());
  }
}

void Menu::setActiveSubmenu(Menu *submenu)
{
  activeSubmenu = submenu;
  if (submenu)
  {
    submenu->setParentMenu(this);
  }
}

void Menu::clearActiveSubmenu()
{
  activeSubmenu = nullptr;
}

Menu *Menu::getActiveSubmenu()
{
  return activeSubmenu;
}

void Menu::setParentMenu(Menu *parent)
{
  parentMenu = parent;
}

Menu *Menu::getParentMenu()
{
  return parentMenu;
}

void Menu::addMenuItem(MenuItem *_item)
{
  _item->parent = this;
  items.push_back(_item);

  numItems = items.size();
  numItemsPerPage = numItems < maxItemsPerPage ? numItems : maxItemsPerPage;
}
========
==== IO/Menu.h: ====
#pragma once

#include "config.h"
#include "Display.h"

#include <vector>

#define MENU_DEFUALT_CLICKS 1

class Menu;

enum class MenuItemType
{
  None,
  Action,
  Navigate,
  Back,
  Toggle,
  String,
  Number,
  Select,
  Submenu
};

enum class MenuSize
{
  Large,
  Medium,
  Small
};

struct ActionFunction
{
  std::function<void()> func;
  int8_t clicksToRun;
};

/**
 * @class MenuItem
 * @brief Represents a menu item.
 */
class MenuItem
{
  friend class Menu;

private:
  String name;

protected:
  Menu *parent;
  MenuItemType type;
  bool hidden = false;

  u16_t textColor;
  u16_t activeTextColor;
  u16_t bgColor;

public:
  std::vector<ActionFunction> functions;
  /**
   * @brief Constructs a MenuItem object with the specified name.
   * @param _name The name of the menu item.
   */
  MenuItem(String _name);

  /**
   * @brief Sets the action to be performed when the menu item is selected.
   *
   * @param _clicksToRun The number of clicks required to run the action.
   * @param _func The action to be performed.
   */
  void addFunc(int8_t _clicksToRun, std::function<void()> _func);

  /**
   * @brief Sets the name of the menu item.
   * @param _name The name of the menu item.
   */
  void setName(String _name);

  /**
   * @brief Gets the name of the menu item.
   * @return The name of the menu item.
   */
  String getName();

  /**
   * @brief Gets the type of the menu item.
   * @return The type of the menu item.
   */
  MenuItemType getType();

  /**
   * @brief Sets the text color of the menu item.
   * @param _color The text color.
   */
  void setTextColor(u16_t _color);

  /**
   * @brief Sets the active text color of the menu item.
   * @param _color The active text color.
   */
  void setActiveTextColor(u16_t _color);

  /**
   * @brief Sets the background color of the menu item.
   * @param _color The background color.
   */
  void setBgColor(u16_t _color);

  /**
   * @brief Sets the visibility of the menu item.
   * @param _hidden Indicates whether the menu item is hidden or not.
   */
  void setHidden(bool _hidden);

  /**
   * @brief Checks if the menu item is hidden.
   * @return true if the menu item is hidden, false otherwise.
   */
  bool isHidden();

  void executeFunc();
  void executeFunc(int8_t _clicks);

  /**
   * @brief Draws the menu item on the screen.
   * @param _x The x-coordinate of the menu item.
   * @param _y The y-coordinate of the menu item.
   * @param _active Indicates whether the menu item is active or not.
   */
  virtual void draw(uint8_t _x, uint8_t _y, bool _active);

  /**
   * @brief Runs the menu item.
   */
  virtual void run();
};

/**
 * @class MenuItemAction
 * @brief A class representing a menu item with an associated action.
 *
 * This class inherits from the base class MenuItem and adds a function pointer
 * to store the action to be performed when the menu item is selected.
 */
class MenuItemAction : public MenuItem
{
public:
  /**
   * @brief Constructs a MenuItemAction object with the specified name and action.
   *
   * @param _name The name of the menu item.
   * @param _clicksToRun The number of clicks required to run the action.
   * @param _func The action to be performed when the menu item is selected.
   */
  MenuItemAction(String _name, int8_t _clicksToRun, std::function<void()> _func);

  // void draw(u8 _x, u8 _y, bool _active) override;
};
class MenuItemNavigate : public MenuItem
{
private:
  // String target;
  const Screen2 *target;

public:
  /**
   * @brief Constructs a new MenuItemNavigate object.
   *
   * @param _name The name of the menu item.
   * @param _target The target of the navigation.
   */
  MenuItemNavigate(String _name, const Screen2 *_target);

  /**
   * Adds a new route to the menu.
   *
   * @param route The route to be added.
   */
  void addRoute(int8_t _clicksToRun, const Screen2 *_target);

  // void draw(u8 _x, u8 _y, bool _active) override;
};

/**
 * @brief Represents a menu item that allows the user to go back to the previous menu.
 */
class MenuItemBack : public MenuItem
{
public:
  /**
   * @brief Constructs a new MenuItemBack object.
   */
  MenuItemBack();

  // void draw(u8 _x, u8 _y, bool _active) override;
};

/**
 * @brief Represents a toggle menu item.
 *
 * This class inherits from the MenuItem class and provides functionality for a toggle menu item.
 * It allows the user to toggle a boolean value associated with the menu item.
 */
class MenuItemToggle : public MenuItem
{
private:
  bool *value;            ///< Pointer to the boolean value associated with the menu item.
  bool isMutable = false; ///< Flag indicating whether this menu item is currently selected.
  std::function<void()> onChange;

public:
  /**
   * @brief Constructs a new MenuItemToggle object.
   *
   * @param _name The name of the menu item.
   * @param _value A pointer to the boolean value associated with the menu item.
   */
  MenuItemToggle(String _name, bool *_value, bool _isMutable = true);

  void setOnChange(std::function<void()> _onChange);
  void removeOnChange();

  void set(bool _value);
  bool get();

  void draw(uint8_t _x, uint8_t _y, bool _active) override;
};

/**
 * @brief Represents a menu item for displaying a string.
 */
class MenuItemString : public MenuItem
{
private:
  String *value;

public:
  MenuItemString(String _name, String *_value);

  void draw(uint8_t _x, uint8_t _y, bool _active) override;
  void setValue(String _value);
  String getValue();
};

enum class NumberValueType
{
  INT,
  FLOAT,
  LONG,
  UINT8_T,
  UINT32_T,
  UNKNOWN
};

/**
 * @brief Abstract base class for MenuItemNumber to provide a common interface.
 */
class MenuItemNumberBase : public MenuItem
{
protected:
  bool selected = false; ///< Flag indicating whether this menu item is currently selected.

  bool isMutable = false; ///< Flag indicating whether this menu item is currently selected.
  bool fastUpdate = false;

public:
  MenuItemNumberBase(String _name);

  virtual ~MenuItemNumberBase() = default;

  // Pure virtual methods to be implemented by derived classes
  bool isSelected() const;
  virtual void increase() = 0;
  virtual void decrease() = 0;
  virtual NumberValueType getValueType() const = 0;

  void setFastUpdate(bool _fastUpdate);
  bool isFastUpdate();
};

/**
 * @brief Represents a menu item for selecting a number value.
 */
template <typename T>
class MenuItemNumber : public MenuItemNumberBase
{
private:
  T *value;   ///< Pointer to the value being controlled by this menu item.
  T min;      ///< The minimum value allowed.
  T max;      ///< The maximum value allowed.
  T step = 1; ///< The step size for increasing or decreasing the value.

  NumberValueType valueType; ///< The type of the value being controlled by this menu item.

  std::function<void()> onChange; ///< Optional callback when the value changes.

  void determineValueType();

public:
  // Constructors
  MenuItemNumber(String _name, T *_value, T _min, T _max);
  MenuItemNumber(String _name, T *_value, T _min, T _max, T _step);
  MenuItemNumber(String _name, T *_value);

  // Override virtual methods
  void toggleSelected();
  virtual void increase() override;
  virtual void decrease() override;
  virtual NumberValueType getValueType() const override;
  virtual void draw(uint8_t _x, uint8_t _y, bool _active) override;

  // Additional methods
  void setOnChange(std::function<void()> _onChange);
  void removeOnChange();
};

// /**
//  * @brief Represents a menu item for selecting a number value.
//  */
// template <typename T>
// class MenuItemNumber : public MenuItem
// {
// private:
//   T *value;   ///< Pointer to the value being controlled by this menu item.
//   T min;      ///< The minimum value allowed.
//   T max;      ///< The maximum value allowed.
//   T step = 1; ///< The step size for increasing or decreasing the value.

//   NumberValueType valueType; ///< The type of the value being controlled by this menu item.

//   bool isMutable = false; ///< Flag indicating whether this menu item is currently selected.

//   bool selected = false; ///< Flag indicating whether this menu item is currently selected.

//   std::function<void()> onChange;

// public:
//   /**
//    * @brief Constructs a new MenuItemNumber object.
//    *
//    * @param _name The name of the menu item.
//    * @param _value Pointer to the value being controlled by this menu item.
//    * @param _min The minimum value allowed.
//    * @param _max The maximum value allowed.
//    */
//   MenuItemNumber(String _name, T *_value, T _min, T _max);
//   MenuItemNumber(String _name, T *_value, T _min, T _max, T _step);

//   /**
//    * @brief Constructs a new MenuItemNumber object.
//    *
//    * @param _name The name of the menu item.
//    * @param _value Pointer to the value being controlled by this menu item.
//    */
//   MenuItemNumber(String _name, T *_value);

//   NumberValueType getValueType() const;

//   void setOnChange(std::function<void()> _onChange);
//   void removeOnChange();

//   /**
//    * @brief Checks if this menu item is currently selected.
//    *
//    * @return true if this menu item is selected, false otherwise.
//    */
//   bool isSelected();

//   /**
//    * @brief Increases the value by one.
//    */
//   void increase();

//   /**
//    * @brief Decreases the value by one.
//    */
//   void decrease();

//   void draw(uint8_t _x, uint8_t _y, bool _active) override;
// };

template class MenuItemNumber<int>;
template class MenuItemNumber<float>;
template class MenuItemNumber<long>;
template class MenuItemNumber<uint8_t>;
template class MenuItemNumber<uint16_t>;
template class MenuItemNumber<uint32_t>;
template class MenuItemNumber<uint64_t>;

// ##############################
// MenuItemSubmenu declaration
// ##############################
class MenuItemSubmenu : public MenuItem
{
private:
  Menu *submenu;

public:
  /**
   * @brief Constructs a MenuItemSubmenu.
   *
   * @param _name The display name of the submenu item.
   * @param _submenu Pointer to the submenu to display when clicked.
   */
  MenuItemSubmenu(String _name, Menu *_submenu);

  /// Override run to activate the submenu.
  virtual void run() override;
};

// ##############################
// New MenuItemSelect declaration
// ##############################
class MenuItemSelect : public MenuItem
{
private:
  std::vector<String> options;
  int currentIndex = 0;
  bool selected = false; // Indicates if the item is in "editing" mode

  // Optional callback: pass the new selection string
  std::function<void()> onChange;

public:
  /**
   * @brief Constructs a MenuItemSelect.
   *
   * @param _name The display name of the item.
   * @param _options A vector of available option strings.
   * @param initialIndex The initially selected index in _options.
   */
  MenuItemSelect(String _name, const std::vector<String> &_options, int initialIndex = 0);

  /// Cycle to the next option in the list.
  void nextOption();

  /// Cycle to the previous option in the list.
  void prevOption();

  /// Returns the currently selected option.
  String getSelectedOption() const;

  void setCurrentIndex(int _index);
  int getCurrentIndex() const;

  /// Set a callback to be notified when the selection changes.
  void setOnChange(std::function<void()> callback);

  /// Toggle the editing mode
  void toggleSelected();

  /// Returns whether the item is currently in editing mode.
  bool isSelected() const;

  /// Override run so that a click toggles between edit and normal mode.
  virtual void run() override;

  /// Draw the selection item. It draws the name and the currently selected option.
  virtual void draw(uint8_t _x, uint8_t _y, bool _active) override;
};

// ###### Menu ######
class Menu
{
  friend class MenuItem;

private:
  uint8_t active;

  uint8_t maxItemsPerPage = 0;

  uint8_t numItems;
  uint8_t numItemsPerPage;
  uint8_t offsetFromTop;
  uint8_t topItem = 0; // Persistent scroll position

  MenuSize menuSize = MenuSize::Large;
  Menu *activeSubmenu = nullptr; // Currently active submenu
  Menu *parentMenu = nullptr;    // Parent menu (for back navigation)

public:
  std::vector<MenuItem *> items;
  Menu();
  Menu(MenuSize _size);

  // String name;

  void setItemsPerPage(uint8_t _itemsPerPage);
  uint8_t getItemsPerPage();

  void setMenuSize(MenuSize _size);
  MenuSize getMenuSize() const;

  void setActive(uint8_t _active);
  uint8_t getActive();

  void nextItem();
  void prevItem();

  void setActiveSubmenu(Menu *submenu);
  void clearActiveSubmenu();
  Menu *getActiveSubmenu();
  void setParentMenu(Menu *parent);
  Menu *getParentMenu();

  void addMenuItem(MenuItem *_item);
  void draw();
  void update();
};
========
==== IO/MenuDraw.cpp: ====
#include "Menu.h"

static const char *TAG = "Menu";

// ###### MenuItem ######

void MenuItem::draw(uint8_t _x, uint8_t _y, bool _active)
{
  MenuSize size = parent ? parent->getMenuSize() : MenuSize::Large;

  if (size == MenuSize::Small)
  {
    display.u8g2.setFont(u8g2_font_6x10_tf);

    if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 9);
      display.u8g2.setDrawColor(0);
    }
    else
      display.u8g2.setDrawColor(1);
    display.u8g2.drawStr(_x + 1, _y + 8, getName().c_str());
  }
  else if (size == MenuSize::Medium)
  {
    display.u8g2.setFont(u8g2_font_doomalpha04_tr);

    if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 12);
      display.u8g2.setDrawColor(0);
    }
    else
      display.u8g2.setDrawColor(1);
    display.u8g2.drawStr(_x + 1, _y + 11, getName().c_str());
  }
  else
  {
    display.u8g2.setFont(u8g2_font_profont22_tf);

    if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 16);
      display.u8g2.setDrawColor(0);
    }
    else
      display.u8g2.setDrawColor(1);
    display.u8g2.drawStr(_x + 1, _y + 15, getName().c_str());
  }
}

// ###### MenuItemToggle ######

void MenuItemToggle::draw(uint8_t _x, uint8_t _y, bool _active)
{
  MenuSize size = parent ? parent->getMenuSize() : MenuSize::Large;

  if (size == MenuSize::Small)
  {
    display.u8g2.setFont(u8g2_font_6x10_tf);

    if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 9);
      display.u8g2.setDrawColor(0);
    }
    else
      display.u8g2.setDrawColor(1);
    display.u8g2.drawStr(_x + 1, _y + 8, getName().c_str());

    String valueStr = *value ? "ON" : "OFF";
    display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 8, valueStr.c_str());
  }
  else if (size == MenuSize::Medium)
  {
    display.u8g2.setFont(u8g2_font_doomalpha04_tr);

    if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 12);
      display.u8g2.setDrawColor(0);
    }
    else
      display.u8g2.setDrawColor(1);
    display.u8g2.drawStr(_x + 1, _y + 11, getName().c_str());

    String valueStr = *value ? "ON" : "OFF";
    display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 11, valueStr.c_str());
  }
  else
  {
    display.u8g2.setFont(u8g2_font_profont22_tf);

    if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 16);
      display.u8g2.setDrawColor(0);
    }
    else
      display.u8g2.setDrawColor(1);
    display.u8g2.drawStr(_x + 1, _y + 15, getName().c_str());

    String valueStr = *value ? "ON" : "OFF";
    display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 15, valueStr.c_str());
  }
}

// ###### MenuItemString ######

void MenuItemString::draw(uint8_t _x, uint8_t _y, bool _active)
{
  MenuSize size = parent ? parent->getMenuSize() : MenuSize::Large;

  if (size == MenuSize::Small)
  {
    display.u8g2.setFont(u8g2_font_6x10_tf);

    if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 9);
      display.u8g2.setDrawColor(0);
    }
    else
      display.u8g2.setDrawColor(1);

    display.u8g2.drawStr(_x + 1, _y + 8, getName().c_str());
    display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(getValue().c_str()) - 5, _y + 8, getValue().c_str());
  }
  else if (size == MenuSize::Medium)
  {
    display.u8g2.setFont(u8g2_font_doomalpha04_tr);

    if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 12);
      display.u8g2.setDrawColor(0);
    }
    else
      display.u8g2.setDrawColor(1);

    display.u8g2.drawStr(_x + 1, _y + 11, getName().c_str());
    display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(getValue().c_str()) - 5, _y + 11, getValue().c_str());
  }
  else
  {
    display.u8g2.setFont(u8g2_font_profont22_tf);

    if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 16);
      display.u8g2.setDrawColor(0);
    }
    else
      display.u8g2.setDrawColor(1);

    display.u8g2.drawStr(_x + 1, _y + 15, getName().c_str());
    display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(getValue().c_str()) - 5, _y + 15, getValue().c_str());
  }
}

// ###### MenuItemNumber ######

template <typename T>
void MenuItemNumber<T>::draw(uint8_t _x, uint8_t _y, bool _active)
{
  MenuSize size = parent ? parent->getMenuSize() : MenuSize::Large;

  if (size == MenuSize::Small)
  {
    display.u8g2.setFont(u8g2_font_6x10_tf);

    if (!_active && selected)
    {
      selected = false;
    }

    String valueStr = String(*value);

    if (_active && selected)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawFrame(_x, _y, DISPLAY_WIDTH - 4, 9);
      display.u8g2.drawStr(_x + 1, _y + 8, getName().c_str());
      display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 8, valueStr.c_str());
    }
    else if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 9);
      display.u8g2.setDrawColor(0);
      display.u8g2.drawStr(_x + 1, _y + 8, getName().c_str());
      display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 8, valueStr.c_str());
    }
    else
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawStr(_x + 1, _y + 8, getName().c_str());
      display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 8, valueStr.c_str());
    }
  }
  else if (size == MenuSize::Medium)
  {
    display.u8g2.setFont(u8g2_font_doomalpha04_tr);

    if (!_active && selected)
    {
      selected = false;
    }

    String valueStr = String(*value);

    if (_active && selected)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawFrame(_x, _y, DISPLAY_WIDTH - 4, 12);
      display.u8g2.drawStr(_x + 1, _y + 11, getName().c_str());
      display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 11, valueStr.c_str());
    }
    else if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 12);
      display.u8g2.setDrawColor(0);
      display.u8g2.drawStr(_x + 1, _y + 11, getName().c_str());
      display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 11, valueStr.c_str());
    }
    else
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawStr(_x + 1, _y + 11, getName().c_str());
      display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 11, valueStr.c_str());
    }
  }
  else
  {
    display.u8g2.setFont(u8g2_font_profont22_tf);

    if (!_active && selected)
    {
      selected = false;
    }

    String valueStr = String(*value);

    if (_active && selected)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawFrame(_x, _y, DISPLAY_WIDTH - 4, 16);
      display.u8g2.drawStr(_x + 1, _y + 15, getName().c_str());
      display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 15, valueStr.c_str());
    }
    else if (_active)
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 16);
      display.u8g2.setDrawColor(0);
      display.u8g2.drawStr(_x + 1, _y + 15, getName().c_str());
      display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 15, valueStr.c_str());
    }
    else
    {
      display.u8g2.setDrawColor(1);
      display.u8g2.drawStr(_x + 1, _y + 15, getName().c_str());
      display.u8g2.drawStr(DISPLAY_WIDTH - display.u8g2.getStrWidth(valueStr.c_str()) - 5, _y + 15, valueStr.c_str());
    }
  }
}

// ###### MenuItemSelect ######

void MenuItemSelect::draw(uint8_t _x, uint8_t _y, bool _active)
{
  MenuSize size = parent ? parent->getMenuSize() : MenuSize::Large;
  String dispText = getName();
  String optionText = getSelectedOption();

  if (size == MenuSize::Small)
  {
    display.u8g2.setFont(u8g2_font_6x10_tf);

    if (_active && selected)
    {
      // Editing mode: draw a frame around the option.
      display.u8g2.setDrawColor(1);
      display.u8g2.drawFrame(_x, _y, DISPLAY_WIDTH - 4, 9);
      display.u8g2.drawStr(_x + 1, _y + 8, dispText.c_str());
      display.u8g2.drawStr(
          DISPLAY_WIDTH - display.u8g2.getStrWidth(optionText.c_str()) - 5,
          _y + 8,
          optionText.c_str());
    }
    else if (_active)
    {
      // Active but not editing: draw with a filled background.
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 9);
      display.u8g2.setDrawColor(0);
      display.u8g2.drawStr(_x + 1, _y + 8, dispText.c_str());
      display.u8g2.drawStr(
          DISPLAY_WIDTH - display.u8g2.getStrWidth(optionText.c_str()) - 5,
          _y + 8,
          optionText.c_str());
    }
    else
    {
      // Inactive: normal drawing.
      display.u8g2.setDrawColor(1);
      display.u8g2.drawStr(_x + 1, _y + 8, dispText.c_str());
      display.u8g2.drawStr(
          DISPLAY_WIDTH - display.u8g2.getStrWidth(optionText.c_str()) - 5,
          _y + 8,
          optionText.c_str());
    }
  }
  else if (size == MenuSize::Medium)
  {
    display.u8g2.setFont(u8g2_font_doomalpha04_tr);

    if (_active && selected)
    {
      // Editing mode: draw a frame around the option.
      display.u8g2.setDrawColor(1);
      display.u8g2.drawFrame(_x, _y, DISPLAY_WIDTH - 4, 12);
      display.u8g2.drawStr(_x + 1, _y + 11, dispText.c_str());
      display.u8g2.drawStr(
          DISPLAY_WIDTH - display.u8g2.getStrWidth(optionText.c_str()) - 5,
          _y + 11,
          optionText.c_str());
    }
    else if (_active)
    {
      // Active but not editing: draw with a filled background.
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 12);
      display.u8g2.setDrawColor(0);
      display.u8g2.drawStr(_x + 1, _y + 11, dispText.c_str());
      display.u8g2.drawStr(
          DISPLAY_WIDTH - display.u8g2.getStrWidth(optionText.c_str()) - 5,
          _y + 11,
          optionText.c_str());
    }
    else
    {
      // Inactive: normal drawing.
      display.u8g2.setDrawColor(1);
      display.u8g2.drawStr(_x + 1, _y + 11, dispText.c_str());
      display.u8g2.drawStr(
          DISPLAY_WIDTH - display.u8g2.getStrWidth(optionText.c_str()) - 5,
          _y + 11,
          optionText.c_str());
    }
  }
  else
  {
    // Draw similar to other items.
    display.u8g2.setFont(u8g2_font_profont22_tf);

    if (_active && selected)
    {
      // Editing mode: draw a frame around the option.
      display.u8g2.setDrawColor(1);
      display.u8g2.drawFrame(_x, _y, DISPLAY_WIDTH - 4, 16);
      display.u8g2.drawStr(_x + 1, _y + 15, dispText.c_str());
      display.u8g2.drawStr(
          DISPLAY_WIDTH - display.u8g2.getStrWidth(optionText.c_str()) - 5,
          _y + 15,
          optionText.c_str());
    }
    else if (_active)
    {
      // Active but not editing: draw with a filled background.
      display.u8g2.setDrawColor(1);
      display.u8g2.drawBox(_x, _y, DISPLAY_WIDTH - 4, 16);
      display.u8g2.setDrawColor(0);
      display.u8g2.drawStr(_x + 1, _y + 15, dispText.c_str());
      display.u8g2.drawStr(
          DISPLAY_WIDTH - display.u8g2.getStrWidth(optionText.c_str()) - 5,
          _y + 15,
          optionText.c_str());
    }
    else
    {
      // Inactive: normal drawing.
      display.u8g2.setDrawColor(1);
      display.u8g2.drawStr(_x + 1, _y + 15, dispText.c_str());
      display.u8g2.drawStr(
          DISPLAY_WIDTH - display.u8g2.getStrWidth(optionText.c_str()) - 5,
          _y + 15,
          optionText.c_str());
    }
  }
}

// ###### Menu ######

void Menu::draw()
{
  // Delegate to active submenu if present
  if (activeSubmenu)
  {
    activeSubmenu->draw();
    return;
  }

  int lineHeight;
  int startY = 12;

  if (menuSize == MenuSize::Small)
  {
    lineHeight = 8;
    display.u8g2.setFont(u8g2_font_6x10_tf);
  }
  else if (menuSize == MenuSize::Medium)
  {
    lineHeight = 12;
    display.u8g2.setFont(u8g2_font_doomalpha04_tr);
  }
  else
  {
    lineHeight = 18;
    display.u8g2.setFont(u8g2_font_profont22_tf);
  }

  uint8_t itemMap[numItems];

  uint8_t numItemsVisible = 0;
  uint8_t numItemsHidden = 0;
  for (uint8_t i = 0; i < numItems; i++)
  {
    if (!items[i]->isHidden())
    {
      itemMap[numItemsVisible] = i;
      numItemsVisible++;
    }

    if (items[i]->isHidden() && active > i)
      numItemsHidden++;
  }

  uint8_t calcActive = active - numItemsHidden;

  // Check if we have any visible items to draw
  if (numItemsVisible == 0)
  {
    return;
  }

  uint8_t itemRelIdx = calcActive - topItem;

  // if first item on screen is selected and item is the first item in the list - update topItem
  if (itemRelIdx <= 0 && calcActive == 0)
    topItem = 0;

  // if first item on screen is selected and item is not the first item in the list - update topItem
  if (itemRelIdx <= 0 && calcActive > 0)
    topItem--;

  // if last item on screen is selected and item is not the last item in the list - update topItem
  if (itemRelIdx >= numItemsPerPage - 1 && calcActive < numItemsVisible - 1)
    topItem++;

  // if last item on screen is selected and item is the last item in the list - update topItem
  if (itemRelIdx >= numItemsPerPage - 1 && calcActive == numItemsVisible - 1)
    topItem = numItemsVisible - numItemsPerPage;

  for (uint8_t i = 0; i < numItemsPerPage; i++)
  {
    uint8_t itemIdx = i + topItem;

    // Add bounds checking to prevent crash
    if (itemIdx >= numItemsVisible)
    {
      break;
    }

    MenuItem *item = items[itemMap[itemIdx]];

    item->draw(0, startY + (i * lineHeight), active == itemMap[itemIdx]);
  }

  display.u8g2.setDrawColor(1);

  uint8_t scrollBarPosition = (DISPLAY_HEIGHT - 13) / (numItemsVisible < 1 ? 1 : numItemsVisible) * calcActive;
  uint8_t scrollBarHeight = (numItemsVisible < 1 ? 1 : numItemsVisible) - 1 == calcActive ? DISPLAY_HEIGHT - 12 - scrollBarPosition : (DISPLAY_HEIGHT - 13) / (numItemsVisible < 1 ? 1 : numItemsVisible);

  display.u8g2.drawLine(DISPLAY_WIDTH - 2, 12, DISPLAY_WIDTH - 2, DISPLAY_HEIGHT - 1);
  display.u8g2.drawBox(DISPLAY_WIDTH - 3, 12 + scrollBarPosition, 3, scrollBarHeight);
}

void Menu::update()
{
  // Delegate to active submenu if present
  if (activeSubmenu)
  {
    activeSubmenu->update();
    return;
  }

  if (numItems < 1)
  {
    if (BtnSel.clicks == 1)
    {
      BtnSel.clicks = 0;
      screenManager.back();
    }

    return;
  }

  if (BtnBoot.clicks == -1)
  {
    BtnBoot.clicks = 0;
    // check if the current menu has a back item and if it does, run it
    for (auto item : items)
    {
      if (item->getType() == MenuItemType::Back)
      {
        if (item->functions.size() > 0)
        {
          item->functions[0].func();
          return;
        }
      }
    }
    return;
  }

  if (BtnSel.clicks != 0)
  {
    ESP_LOGI(TAG, "Clicks: %d", BtnSel.clicks);
    items[active]->run();
    BtnSel.clicks = 0;
  }

  MenuItem *currentItem = items[active];

  if (BtnNext.clicks == 1)
  {
    switch (currentItem->getType())
    {
    case MenuItemType::Select:
    {
      MenuItemSelect *selectItem = (MenuItemSelect *)currentItem;

      if (selectItem && selectItem->isSelected())
        selectItem->nextOption();
      else
        nextItem();
    }
    break;

    case MenuItemType::Number:
    {
      MenuItemNumberBase *numberItem = (MenuItemNumberBase *)currentItem;

      if (numberItem && numberItem->isSelected())
        numberItem->increase();
      else
        nextItem();
    }
    break;

    default:
      nextItem();
      break;
    }

    BtnNext.clicks = 0;
  }
  else if (BtnPrev.clicks == 1)
  {
    switch (currentItem->getType())
    {
    case MenuItemType::Select:
    {
      MenuItemSelect *selectItem = (MenuItemSelect *)currentItem;

      if (selectItem && selectItem->isSelected())
        selectItem->prevOption();
      else
        prevItem();
    }
    break;

    case MenuItemType::Number:
    {
      MenuItemNumberBase *numberItem = (MenuItemNumberBase *)currentItem;

      if (numberItem && numberItem->isSelected())
        numberItem->decrease();
      else
        prevItem();
    }
    break;

    default:
      prevItem();
      break;
    }

    BtnPrev.clicks = 0;
  }
}========
==== IO/ScreenManager.cpp: ====
#include "ScreenManager.h"
#include "esp_log.h"

static const char *TAG = "SCREEN_MANAGER";

void ScreenManager::init(void)
{
  pendingScreen = nullptr;
  ESP_LOGI(TAG, "Initialized");
}

void ScreenManager::update(void)
{
  if (currentScreen && currentScreen->update)
    currentScreen->update();
  else
    ESP_LOGW(TAG, "No screen to update");

  if (applyPendingScreenChange())
    update();
}

void ScreenManager::draw(void)
{
  if (currentScreen && currentScreen->draw)
    currentScreen->draw();
  else
    ESP_LOGW(TAG, "No screen to draw");
}

const Screen2 *ScreenManager::getCurrentScreen(void)
{
  if (pendingScreen)
    return pendingScreen;
  return currentScreen;
}

bool ScreenManager::applyPendingScreenChange()
{
  if (pendingScreen != nullptr)
  {

    if (currentScreen)
      ESP_LOGI(TAG, "From: %s To: %s", currentScreen->name, pendingScreen->name);
    else
      ESP_LOGI(TAG, "To: %s", pendingScreen->name);

    if (currentScreen && currentScreen->onExit)
      currentScreen->onExit();

    currentScreen = pendingScreen;
    pendingScreen = nullptr;

    ESP_LOGI(TAG, ">> %s", currentScreen->name);

    updateHistory(currentScreen);

    if (currentScreen && currentScreen->onEnter)
      currentScreen->onEnter();

    return true;
  }

  return false;
}

void ScreenManager::setScreen(const Screen2 *screen)
{
  pendingScreen = screen;
}

void ScreenManager::back(void)
{
  ESP_LOGI(TAG, "Screen history:");
  for (size_t i = 0; i < screenHistory.size(); i++)
  {
    ESP_LOGI(TAG, "[%d] %s", i, screenHistory[i]->name);
  }

  if (screenHistory.size() > 1)
  {
    screenHistory.pop_back();
    pendingScreen = screenHistory.back();
    ESP_LOGI(TAG, "Going back to: %s", pendingScreen->name);
  }
  else
  {
    ESP_LOGI(TAG, "Cannot go back - no screen history available");
  }
}

void ScreenManager::clearHistory(void)
{
  ESP_LOGI(TAG, "Clearing screen history");

  const Screen2 *current = nullptr;
  if (screenHistory.size() > 0)
  {
    current = screenHistory.back();
  }

  screenHistory.clear();

  if (current != nullptr)
    screenHistory.push_back(current);
}

void ScreenManager::updateHistory(const Screen2 *screen)
{
  if (screen == nullptr)
  {
    ESP_LOGW(TAG, "Attempted to add null screen to history");
    return;
  }

  if (screenHistory.empty() || screenHistory.back() != screen)
  {
    ESP_LOGI(TAG, "Adding screen to history: %s", screen->name);
    screenHistory.push_back(screen);

    if (screenHistory.size() > 10)
      screenHistory.erase(screenHistory.begin());
  }
}

bool ScreenManager::goToHistoryIndex(size_t index)
{
  if (index < screenHistory.size())
  {
    ESP_LOGI(TAG, "Navigating to history index %d: %s",
             index, screenHistory[index]->name);

    if (index != screenHistory.size() - 1)
    {
      pendingScreen = screenHistory[index];
      screenHistory.resize(index + 1);

      return true;
    }

    ESP_LOGI(TAG, "Already at requested screen");
    return false;
  }

  ESP_LOGW(TAG, "Invalid history index: %d, max: %d",
           index, screenHistory.size() ? screenHistory.size() - 1 : 0);
  return false;
}

ScreenManager screenManager;
========
==== IO/ScreenManager.h: ====
#pragma once

#include "config.h"
#include "IO/GPIO.h"
#include "IO/Display.h"
#include <vector>

// class Screen;
class Screen2;

// screen architecture v2
class ScreenManager
{
private:
  const Screen2 *currentScreen = nullptr;
  const Screen2 *pendingScreen = nullptr;
  std::vector<const Screen2 *> screenHistory;

  void updateHistory(const Screen2 *screen);

public:
  void init(void);

  void update(void);
  void draw(void);

  const Screen2 *getCurrentScreen(void);

  void setScreen(const Screen2 *screen);
  bool applyPendingScreenChange();

  void back(void);
  void clearHistory(void);
  bool goToHistoryIndex(size_t index);
};

struct Screen2
{
  // Screen2(const char *name, void (*draw)(), void (*update)(), void (*onEnter)(), void (*onExit)());
  const String name;
  const String topBarText;
  void (*draw)();
  void (*update)();
  void (*onEnter)();
  void (*onExit)();
};

extern ScreenManager screenManager;========
==== IO/StatusLed.cpp: ====
#include "StatusLed.h"
#include "esp_log.h"

static const char *TAG = "StatusLed";

StatusLeds::StatusLeds()
{
  _initialized = false;
  _brightness = 255;
}

StatusLeds::~StatusLeds()
{
  // Nothing to clean up for now
}

void StatusLeds::begin()
{
#ifdef OUTPUT_STATUS_LED_PIN
  if (!_initialized)
  {
    // Initialize FastLED - you may need to adjust the LED type and pin
    _controller = &FastLED.addLeds<WS2812B, OUTPUT_STATUS_LED_PIN, GRB>(_leds, STATUS_LED_COUNT);
    memset(_leds, 0, sizeof(_leds));
    _initialized = true;

    show();
    ESP_LOGI(TAG, "StatusLeds initialized on pin %d with %d LEDs", OUTPUT_STATUS_LED_PIN, STATUS_LED_COUNT);
  }
#endif
}

void StatusLeds::show()
{
  if (_initialized)
  {
    _controller->showLeds(_brightness);
  }
  else
  {
    ESP_LOGE(TAG, "StatusLeds::show() called but not initialized");
  }
}

CRGB *StatusLeds::getLedPtr(uint8_t index)
{
  if (!_initialized)
  {
    ESP_LOGE(TAG, "StatusLeds::getLedPtr() called but not initialized");
    return nullptr;
  }

  if (index >= STATUS_LED_COUNT)
  {
    ESP_LOGE(TAG, "StatusLeds::getLedPtr() index %d out of range (max: %d)", index, STATUS_LED_COUNT - 1);
    return nullptr;
  }

  return &_leds[index];
}

void StatusLeds::setBrightness(uint8_t brightness)
{
  _brightness = brightness;
}

uint8_t StatusLeds::getBrightness() const
{
  return _brightness;
}

void StatusLeds::startShowTask()
{
  xTaskCreatePinnedToCore(_showTask, "StatusLedShowTask", 4096, this, 1, &_showTaskHandle, 0);
}

void StatusLeds::stopShowTask()
{
  vTaskDelete(_showTaskHandle);
  _showTaskHandle = NULL;
}

bool StatusLeds::isShowTaskRunning()
{
  return _showTaskHandle != NULL;
}

void StatusLeds::_showTask(void *pvParameters)
{
  StatusLeds *statusLeds = (StatusLeds *)pvParameters;
  while (true)
  {
    statusLeds->show();
    vTaskDelay(pdMS_TO_TICKS(1000 / 30)); // 50fps
  }
}

// ================================
// StatusLed
// ================================

StatusLed::StatusLed()
{
  _initialized = false;
  _mode = RGB_MODE::Manual;
  _maxModeHistory = 10;
  _ledPtr = nullptr;
  _controller = nullptr;
}

StatusLed::~StatusLed()
{
  // Stop all running tasks
  _stopRainbow();
  _stopPulsing();
  _stopBlink();
}

void StatusLed::begin(StatusLeds *controller, CRGB *ledPtr)
{
  if (controller && ledPtr)
  {
    _controller = controller;
    _ledPtr = ledPtr;
    _initialized = true;

    // Initialize task names
    uint8_t ledIndex = _ledPtr - _controller->getLedPtr(0) + 1;
    snprintf(_rainbowTaskName, sizeof(_rainbowTaskName), "Rainbow_%d", ledIndex);
    snprintf(_pulsingTaskName, sizeof(_pulsingTaskName), "Pulsing_%d", ledIndex);
    snprintf(_blinkTaskName, sizeof(_blinkTaskName), "Blink_%d", ledIndex);

    // Initialize LED to off
    *_ledPtr = CRGB(0, 0, 0);
    // _show();

    ESP_LOGI(TAG, "StatusLed initialized with controller");
  }
}

// ================================
// Private helper methods
// ================================

void StatusLed::_setColor(uint8_t r, uint8_t g, uint8_t b)
{
  if (!_initialized)
  {
    ESP_LOGE(TAG, "StatusLed::_setColor() called but not initialized");
    return;
  }

  if (!_ledPtr)
  {
    ESP_LOGE(TAG, "StatusLed::_setColor() called but LED pointer is null");
    return;
  }

  *_ledPtr = CRGB(r, g, b);
  // _show();
  ESP_LOGD(TAG, "Color set to %d %d %d", r, g, b);
}

void StatusLed::_setColor(uint32_t color)
{
  _setColor((color >> 16) & 0xFF, (color >> 8) & 0xFF, color & 0xFF);
}

void StatusLed::setOverideColor(uint8_t r, uint8_t g, uint8_t b)
{
  setOverideColor((r << 16) | (g << 8) | b);
}

void StatusLed::setOverideColor(uint32_t color)
{
  _overideColor = color;

  if (_mode == RGB_MODE::Overide)
  {
    _setColor((color >> 16) & 0xFF, (color >> 8) & 0xFF, color & 0xFF);
  }
}

// void StatusLed::_show()
// {
//   if (_controller)
//   {
//     _controller->show();
//   }
//   else
//   {
//     ESP_LOGE(TAG, "StatusLed::_show() called but controller is null");
//   }
// }

void StatusLed::_updateModeHistory(RGB_MODE oldMode)
{
  if (_modeHistory.size() >= _maxModeHistory)
    _modeHistory.erase(_modeHistory.begin());
  _modeHistory.push_back(oldMode);
}

void StatusLed::_setMode(RGB_MODE newMode)
{
  _mode = newMode;

  ESP_LOGI(TAG, "Mode changed to %d", (int)_mode);

  // Stop all animations first
  _stopRainbow();
  _stopPulsing();
  _stopBlink();

  // Start appropriate animation
  switch (_mode)
  {
  case RGB_MODE::Rainbow:
    _startRainbow();
    break;
  case RGB_MODE::Pulsing:
    _startPulsing();
    break;
  case RGB_MODE::Blink:
    _startBlink();
    break;
  case RGB_MODE::Overide:
    _setColor((_overideColor >> 16) & 0xFF, (_overideColor >> 8) & 0xFF, _overideColor & 0xFF);
    break;
  case RGB_MODE::Manual:
    _setColor(_prevManualColor);
    // _show();
    break;
  }
}

// ================================
// Rainbow animation
// ================================

void StatusLed::_startRainbow()
{
  if (_rainbowHandle == NULL)
  {
    xTaskCreate(_rainbowTask, _rainbowTaskName, 4096, this, 1, &_rainbowHandle);
  }
}

void StatusLed::_stopRainbow()
{
  if (_rainbowHandle != NULL)
  {
    vTaskDelete(_rainbowHandle);
    _rainbowHandle = NULL;
  }
}

void StatusLed::_rainbow()
{
  while (_mode == RGB_MODE::Rainbow)
  {
    // Red to Green
    for (uint8_t i = 0; i < 255 && _mode == RGB_MODE::Rainbow; i++)
    {
      _setColor(255 - i, i, 0);
      vTaskDelay(pdMS_TO_TICKS(_rainbowSpeed / 3 / 255));
    }

    // Green to Blue
    for (uint8_t i = 0; i < 255 && _mode == RGB_MODE::Rainbow; i++)
    {
      _setColor(0, 255 - i, i);
      vTaskDelay(pdMS_TO_TICKS(_rainbowSpeed / 3 / 255));
    }

    // Blue to Red
    for (uint8_t i = 0; i < 255 && _mode == RGB_MODE::Rainbow; i++)
    {
      _setColor(i, 0, 255 - i);
      vTaskDelay(pdMS_TO_TICKS(_rainbowSpeed / 3 / 255));
    }
    // _show();
  }
}

void StatusLed::_rainbowTask(void *pvParameters)
{
  StatusLed *statusLed = (StatusLed *)pvParameters;
  statusLed->_rainbow();
  statusLed->_rainbowHandle = NULL;
  vTaskDelete(NULL);
}

// ================================
// Pulsing animation
// ================================

void StatusLed::_startPulsing()
{
  if (_pulsingHandle == NULL)
  {
    xTaskCreate(_pulsingTask, _pulsingTaskName, 4096, this, 1, &_pulsingHandle);
  }
}

void StatusLed::_stopPulsing()
{
  if (_pulsingHandle != NULL)
  {
    vTaskDelete(_pulsingHandle);
    _pulsingHandle = NULL;
  }
}

void StatusLed::_pulsing()
{
  uint8_t r = (_pulsingColor >> 16) & 0xFF;
  uint8_t g = (_pulsingColor >> 8) & 0xFF;
  uint8_t b = _pulsingColor & 0xFF;

  while (_mode == RGB_MODE::Pulsing)
  {
    // Fade from the original color to black
    for (uint8_t i = 0; i < 255 && _mode == RGB_MODE::Pulsing; i++)
    {
      uint8_t red = r - (r * i / 255);
      uint8_t green = g - (g * i / 255);
      uint8_t blue = b - (b * i / 255);

      _setColor(red, green, blue);
      // _show();
      vTaskDelay(pdMS_TO_TICKS(_pulsingSpeed));
    }

    // Fade from black back to the original color
    for (uint8_t i = 0; i < 255 && _mode == RGB_MODE::Pulsing; i++)
    {
      uint8_t red = (r * i / 255);
      uint8_t green = (g * i / 255);
      uint8_t blue = (b * i / 255);

      _setColor(red, green, blue);
      // _show();
      vTaskDelay(pdMS_TO_TICKS(_pulsingSpeed));
    }
  }
}

void StatusLed::_pulsingTask(void *pvParameters)
{
  StatusLed *statusLed = (StatusLed *)pvParameters;
  statusLed->_pulsing();
  statusLed->_pulsingHandle = NULL;
  vTaskDelete(NULL);
}

// ================================
// Blink animation
// ================================

void StatusLed::_startBlink()
{
  if (_blinkHandle == NULL)
  {
    xTaskCreate(_blinkTask, _blinkTaskName, 4096, this, 1, &_blinkHandle);
  }
}

void StatusLed::_stopBlink()
{
  if (_blinkHandle != NULL)
  {
    vTaskDelete(_blinkHandle);
    _blinkHandle = NULL;
  }
}

void StatusLed::_blink()
{
  vTaskDelay(pdMS_TO_TICKS(5)); // Small delay before starting

  for (uint8_t i = 0; i < _blinkCount; i++)
  {
    _setColor(_blinkColor);
    // _show();
    vTaskDelay(pdMS_TO_TICKS(_blinkSpeed * 100)); // Convert to ms

    _setColor(0, 0, 0);
    // _show();
    vTaskDelay(pdMS_TO_TICKS(_blinkSpeed * 100));
  }

  // Return to previous mode
  setPrevMode();
}

void StatusLed::_blinkTask(void *pvParameters)
{
  StatusLed *statusLed = (StatusLed *)pvParameters;
  statusLed->_blink();
  statusLed->_blinkHandle = NULL;
  vTaskDelete(NULL);
}

// ================================
// Public API - Mode Management
// ================================

void StatusLed::setMode(RGB_MODE mode)
{
  if (!_initialized)
  {
    ESP_LOGE(TAG, "StatusLed::setMode() called but not initialized");
    return;
  }

  if (_mode == mode)
  {
    // ESP_LOGI(TAG, "SetMode() called with the same mode");
    return;
  }

  if (_mode == RGB_MODE::Blink)
  {
    ESP_LOGI(TAG, "Not changed because current mode is Blink");
    return;
  }

  ESP_LOGI(TAG, "Mode changed to %d", (int)mode);
  _updateModeHistory(_mode);
  _setMode(mode);
}

void StatusLed::setPrevMode()
{
  if (_modeHistory.size() == 0)
  {
    ESP_LOGI(TAG, "SetPrevMode() called with no history");
    _setMode(RGB_MODE::Manual);
    return;
  }

  ESP_LOGI(TAG, "[PREV] Mode changed to %d", (int)_modeHistory.back());

  _setMode(_modeHistory.back());
  _modeHistory.pop_back();
}

void StatusLed::goBackSteps(uint8_t steps)
{
  if (steps == 0)
  {
    ESP_LOGI(TAG, "goBackSteps() called with 0 steps");
    return;
  }

  if (_modeHistory.size() == 0)
  {
    ESP_LOGI(TAG, "goBackSteps() called with no history");
    _setMode(RGB_MODE::Manual);
    return;
  }

  // Limit steps to available history
  uint8_t actualSteps = (steps > _modeHistory.size()) ? _modeHistory.size() : steps;

  ESP_LOGI(TAG, "[HISTORY] Going back %d steps (requested %d)", actualSteps, steps);

  // Get the target mode (actualSteps back from the end)
  RGB_MODE targetMode = _modeHistory[_modeHistory.size() - actualSteps];

  // Remove the steps we're going back
  for (uint8_t i = 0; i < actualSteps; i++)
  {
    _modeHistory.pop_back();
  }

  _setMode(targetMode);
  // _show();
}

void StatusLed::clearHistory()
{
  ESP_LOGI(TAG, "History cleared (%d entries)", _modeHistory.size());
  _modeHistory.clear();
}

uint8_t StatusLed::getHistorySize()
{
  return _modeHistory.size();
}

RGB_MODE StatusLed::getHistoryAt(uint8_t index)
{
  if (index >= _modeHistory.size())
  {
    ESP_LOGW(TAG, "getHistoryAt() index %d out of range (size: %d)", index, _modeHistory.size());
    return RGB_MODE::Manual; // Default fallback
  }

  // Index 0 = most recent, so we need to reverse the indexing
  return _modeHistory[_modeHistory.size() - 1 - index];
}

std::vector<RGB_MODE> StatusLed::getFullHistory()
{
  // Return a copy of the history (most recent first)
  std::vector<RGB_MODE> reversedHistory;
  for (int i = _modeHistory.size() - 1; i >= 0; i--)
  {
    reversedHistory.push_back(_modeHistory[i]);
  }
  return reversedHistory;
}

RGB_MODE StatusLed::getMode()
{
  return _mode;
}

// ================================
// Public API - Manual Mode Controls
// ================================

void StatusLed::setColor(uint8_t r, uint8_t g, uint8_t b)
{
  if (!_initialized)
  {
    ESP_LOGE(TAG, "StatusLed::setColor() called but not initialized");
    return;
  }

  _prevManualColor = (r << 16) | (g << 8) | b;

  if (_mode != RGB_MODE::Manual)
  {
    ESP_LOGD(TAG, "SetColor() called while not in Manual mode");
    return;
  }

  ESP_LOGD(TAG, "Color set to %d %d %d", r, g, b);
  _setColor(r, g, b);
}

void StatusLed::setColor(uint32_t color)
{
  setColor((color >> 16) & 0xFF, (color >> 8) & 0xFF, color & 0xFF);
}

void StatusLed::setColor565(uint16_t color)
{
  setColor((color >> 8) & 0xF8, (color >> 3) & 0xFC, (color << 3) & 0xF8);
}

void StatusLed::setPrevColor(uint8_t r, uint8_t g, uint8_t b)
{
  _prevManualColor = (r << 16) | (g << 8) | b;
}

void StatusLed::off()
{
  if (!_initialized)
  {
    ESP_LOGE(TAG, "StatusLed::off() called but not initialized");
    return;
  }

  _prevManualColor = 0;

  if (_mode != RGB_MODE::Manual)
  {
    ESP_LOGD(TAG, "Off() called while not in Manual mode");
    return;
  }

  _setColor(0, 0, 0);
}

// ================================
// Public API - Animation Controls
// ================================

void StatusLed::setPulsingColor(uint32_t color)
{
  _pulsingColor = color;
}

void StatusLed::setPulsingColor(uint8_t _r, uint8_t _g, uint8_t _b)
{
  _pulsingColor = (_r << 16) | (_g << 8) | _b;
}

void StatusLed::blink(uint32_t color, uint8_t speed, uint8_t count)
{
  if (!_initialized)
  {
    ESP_LOGE(TAG, "StatusLed::blink() called but not initialized");
    return;
  }

  if (_mode == RGB_MODE::Blink)
  {
    ESP_LOGI(TAG, "Blink() called while already in Blink mode");
    return;
  }

  _blinkColor = color;
  _blinkSpeed = speed;
  _blinkCount = count;

  _updateModeHistory(_mode);
  _setMode(RGB_MODE::Blink);
}

// ================================
// Global instances
// ================================

StatusLeds statusLeds;
StatusLed statusLed1;
StatusLed statusLed2;========
==== IO/StatusLed.h: ====
#pragma once

#include "config.h"
#include "FastLED.h"
#include <vector>

#define STATUS_LED_COUNT 2

enum class RGB_MODE
{
  Manual,
  Overide,
  Rainbow,
  Pulsing,
  Blink
};

class StatusLeds;

class StatusLed
{
public:
  StatusLed();
  ~StatusLed();

  void begin(StatusLeds *controller, CRGB *ledPtr);

  // Mode-based functionality
  void setMode(RGB_MODE mode);
  void setPrevMode();
  void goBackSteps(uint8_t steps);
  void clearHistory();
  uint8_t getHistorySize();
  RGB_MODE getHistoryAt(uint8_t index); // 0 = most recent
  std::vector<RGB_MODE> getFullHistory();
  RGB_MODE getMode();

  // Manual mode controls
  void off();
  void setColor(uint8_t r, uint8_t g, uint8_t b);
  void setColor(uint32_t color);
  void setColor565(uint16_t color);

  void setPrevColor(uint8_t r, uint8_t g, uint8_t b);

  void setOverideColor(uint8_t r, uint8_t g, uint8_t b);
  void setOverideColor(uint32_t color);

  // Animation controls
  void setPulsingColor(uint32_t color);
  void setPulsingColor(uint8_t _r, uint8_t _g, uint8_t _b);
  void blink(uint32_t color, uint8_t speed, uint8_t count);

  // Speed controls
  void setRainbowSpeed(uint8_t speed) { _rainbowSpeed = speed; }
  void setPulsingSpeed(uint8_t speed) { _pulsingSpeed = speed; }

private:
  bool _initialized;
  CRGB *_ledPtr;
  StatusLeds *_controller;

  // Mode management
  RGB_MODE _mode = RGB_MODE::Manual;
  uint8_t _maxModeHistory = 10;
  std::vector<RGB_MODE> _modeHistory;
  uint32_t _prevManualColor = 0;
  uint32_t _overideColor = 0;

  // Task names
  char _rainbowTaskName[32];
  char _pulsingTaskName[32];
  char _blinkTaskName[32];

  // Animation task handles
  TaskHandle_t _rainbowHandle = NULL;
  uint16_t _rainbowSpeed = 2000;

  TaskHandle_t _pulsingHandle = NULL;
  uint8_t _pulsingSpeed = 2;
  uint32_t _pulsingColor = 0;

  TaskHandle_t _blinkHandle = NULL;
  uint8_t _blinkSpeed = 2;
  uint8_t _blinkCount = 0;
  uint32_t _blinkColor = 0;

  // Private helper methods
  void _setColor(uint8_t r, uint8_t g, uint8_t b);
  void _setColor(uint32_t color);
  void _updateModeHistory(RGB_MODE oldMode);
  void _setMode(RGB_MODE newMode);
  // void _show();

  // Animation methods
  void _startRainbow();
  void _stopRainbow();
  void _rainbow();

  void _startPulsing();
  void _stopPulsing();
  void _pulsing();

  void _startBlink();
  void _stopBlink();
  void _blink();

  // Static task wrapper functions
  static void _rainbowTask(void *pvParameters);
  static void _pulsingTask(void *pvParameters);
  static void _blinkTask(void *pvParameters);
};

class StatusLeds
{
public:
  StatusLeds();
  ~StatusLeds();

  void begin();
  // void show();
  CRGB *getLedPtr(uint8_t index);
  void setBrightness(uint8_t brightness);
  uint8_t getBrightness() const;

  void startShowTask();
  void stopShowTask();
  bool isShowTaskRunning();
  void show();

private:
  bool _initialized;
  CRGB _leds[STATUS_LED_COUNT];
  CLEDController *_controller;
  uint8_t _brightness = 255;

  xTaskHandle _showTaskHandle;
  static void _showTask(void *pvParameters);
};

extern StatusLeds statusLeds;
extern StatusLed statusLed1;
extern StatusLed statusLed2;========
==== IO/TimeProfiler.cpp: ====
#include "TimeProfiler.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include <set>

// Static task handle
static TaskHandle_t callCounterResetTaskHandle = NULL;

// Static task function for call counter resets
static void callCounterResetTask(void *parameter)
{
  TimeProfiler *profiler = (TimeProfiler *)parameter;

  for (;;)
  {
    vTaskDelay(1000 / portTICK_PERIOD_MS); // Wait 1 second
    profiler->resetCallCounters();
  }
}

TimeProfiler::TimeProfiler()
{
  // Constructor - maps are automatically initialized
  // Initialize mutexes
  timingMutex = xSemaphoreCreateMutex();
  callCountMutex = xSemaphoreCreateMutex();
}

void TimeProfiler::begin()
{
  // Create FreeRTOS task to reset call counters every second
  xTaskCreate(
      callCounterResetTask,       // Task function
      "TimeProfilerCallReset",    // Task name
      2048,                       // Stack size (bytes)
      this,                       // Parameter passed to task
      1,                          // Task priority (low priority)
      &callCounterResetTaskHandle // Task handle
  );
}

void TimeProfiler::start(const String &key, TimeUnit unit)
{
  if (xSemaphoreTake(timingMutex, portMAX_DELAY) == pdTRUE)
  {
    if (unit == TimeUnit::MICROSECONDS)
    {
      startTimes[key] = micros();
    }
    else
    {
      startTimes[key] = millis();
    }
    startUnits[key] = unit;
    xSemaphoreGive(timingMutex);
  }
}

void TimeProfiler::stop(const String &key)
{
  if (xSemaphoreTake(timingMutex, portMAX_DELAY) == pdTRUE)
  {
    if (startTimes.find(key) != startTimes.end() && startUnits.find(key) != startUnits.end())
    {
      TimingData data;
      data.unit = startUnits[key];

      if (data.unit == TimeUnit::MICROSECONDS)
      {
        data.time = micros() - startTimes[key];
      }
      else
      {
        data.time = millis() - startTimes[key];
      }

      elapsedTimes[key] = data;
      startTimes.erase(key); // Remove from start times to free memory
      startUnits.erase(key); // Remove from start units to free memory
    }
    xSemaphoreGive(timingMutex);
  }
}

uint32_t TimeProfiler::getTime(const String &key)
{
  uint32_t result = 0;
  if (xSemaphoreTake(timingMutex, portMAX_DELAY) == pdTRUE)
  {
    auto it = elapsedTimes.find(key);
    if (it != elapsedTimes.end())
    {
      result = it->second.time;
    }
    xSemaphoreGive(timingMutex);
  }
  return result;
}

TimeUnit TimeProfiler::getTimeUnit(const String &key)
{
  TimeUnit result = TimeUnit::MICROSECONDS; // Default fallback
  if (xSemaphoreTake(timingMutex, portMAX_DELAY) == pdTRUE)
  {
    auto it = elapsedTimes.find(key);
    if (it != elapsedTimes.end())
    {
      result = it->second.unit;
    }
    xSemaphoreGive(timingMutex);
  }
  return result;
}

uint32_t TimeProfiler::getTimeUs(const String &key)
{
  uint32_t result = 0;
  if (xSemaphoreTake(timingMutex, portMAX_DELAY) == pdTRUE)
  {
    auto it = elapsedTimes.find(key);
    if (it != elapsedTimes.end())
    {
      if (it->second.unit == TimeUnit::MICROSECONDS)
      {
        result = it->second.time;
      }
      else
      {
        result = it->second.time * 1000; // Convert ms to us
      }
    }
    xSemaphoreGive(timingMutex);
  }
  return result;
}

float TimeProfiler::getTimeMs(const String &key)
{
  float result = 0.0f;
  if (xSemaphoreTake(timingMutex, portMAX_DELAY) == pdTRUE)
  {
    auto it = elapsedTimes.find(key);
    if (it != elapsedTimes.end())
    {
      if (it->second.unit == TimeUnit::MILLISECONDS)
      {
        result = (float)it->second.time;
      }
      else
      {
        result = it->second.time / 1000.0f; // Convert us to ms
      }
    }
    xSemaphoreGive(timingMutex);
  }
  return result;
}

// === CALL COUNTING SYSTEM METHODS ===
void TimeProfiler::increment(const String &key)
{
  if (xSemaphoreTake(callCountMutex, portMAX_DELAY) == pdTRUE)
  {
    callCounts[key]++;
    xSemaphoreGive(callCountMutex);
  }
}

uint32_t TimeProfiler::getCallsPerSecond(const String &key)
{
  uint32_t result = 0;
  if (xSemaphoreTake(callCountMutex, portMAX_DELAY) == pdTRUE)
  {
    auto it = callsPerSecond.find(key);
    if (it != callsPerSecond.end())
    {
      result = it->second;
    }
    xSemaphoreGive(callCountMutex);
  }
  return result;
}

uint32_t TimeProfiler::getCurrentCallCount(const String &key)
{
  uint32_t result = 0;
  if (xSemaphoreTake(callCountMutex, portMAX_DELAY) == pdTRUE)
  {
    auto it = callCounts.find(key);
    if (it != callCounts.end())
    {
      result = it->second;
    }
    xSemaphoreGive(callCountMutex);
  }
  return result;
}

void TimeProfiler::resetCallCounters()
{
  if (xSemaphoreTake(callCountMutex, portMAX_DELAY) == pdTRUE)
  {
    // Copy current call counts to calls per second
    for (const auto &pair : callCounts)
    {
      callsPerSecond[pair.first] = pair.second;
    }

    // Reset call counters for next second
    callCounts.clear();
    xSemaphoreGive(callCountMutex);
  }
}

// === SHARED UTILITIES ===
bool TimeProfiler::hasKey(const String &key)
{
  bool result = false;

  // Check timing data
  if (xSemaphoreTake(timingMutex, portMAX_DELAY) == pdTRUE)
  {
    result = elapsedTimes.find(key) != elapsedTimes.end();
    xSemaphoreGive(timingMutex);
  }

  // If not found in timing data, check call count data
  if (!result && xSemaphoreTake(callCountMutex, portMAX_DELAY) == pdTRUE)
  {
    result = callsPerSecond.find(key) != callsPerSecond.end() ||
             callCounts.find(key) != callCounts.end();
    xSemaphoreGive(callCountMutex);
  }

  return result;
}

void TimeProfiler::clear()
{
  // Clear timing data
  if (xSemaphoreTake(timingMutex, portMAX_DELAY) == pdTRUE)
  {
    startTimes.clear();
    startUnits.clear();
    elapsedTimes.clear();
    xSemaphoreGive(timingMutex);
  }

  // Clear call count data
  if (xSemaphoreTake(callCountMutex, portMAX_DELAY) == pdTRUE)
  {
    callCounts.clear();
    callsPerSecond.clear();
    xSemaphoreGive(callCountMutex);
  }
}

void TimeProfiler::remove(const String &key)
{
  // Remove from timing data
  if (xSemaphoreTake(timingMutex, portMAX_DELAY) == pdTRUE)
  {
    startTimes.erase(key);
    startUnits.erase(key);
    elapsedTimes.erase(key);
    xSemaphoreGive(timingMutex);
  }

  // Remove from call count data
  if (xSemaphoreTake(callCountMutex, portMAX_DELAY) == pdTRUE)
  {
    callCounts.erase(key);
    callsPerSecond.erase(key);
    xSemaphoreGive(callCountMutex);
  }
}

void TimeProfiler::printAll()
{
  Serial.println("=== TimeProfiler Results ===");

  // Collect all unique keys from both systems
  std::set<String> allKeys;

  // Collect keys from timing system
  if (xSemaphoreTake(timingMutex, portMAX_DELAY) == pdTRUE)
  {
    for (const auto &pair : elapsedTimes)
    {
      allKeys.insert(pair.first);
    }
    xSemaphoreGive(timingMutex);
  }

  // Collect keys from call count system
  if (xSemaphoreTake(callCountMutex, portMAX_DELAY) == pdTRUE)
  {
    for (const auto &pair : callsPerSecond)
    {
      allKeys.insert(pair.first);
    }
    for (const auto &pair : callCounts)
    {
      allKeys.insert(pair.first);
    }
    xSemaphoreGive(callCountMutex);
  }

  for (const String &key : allKeys)
  {
    Serial.print(key);
    Serial.print(": ");

    // Print timing data if available
    bool hasTimingData = false;
    if (xSemaphoreTake(timingMutex, portMAX_DELAY) == pdTRUE)
    {
      auto timingIt = elapsedTimes.find(key);
      if (timingIt != elapsedTimes.end())
      {
        hasTimingData = true;
        Serial.print(timingIt->second.time);
        if (timingIt->second.unit == TimeUnit::MICROSECONDS)
        {
          Serial.print(" μs (");
          Serial.print(timingIt->second.time / 1000.0f);
          Serial.print(" ms)");
        }
        else
        {
          Serial.print(" ms (");
          Serial.print(timingIt->second.time * 1000);
          Serial.print(" μs)");
        }
      }
      xSemaphoreGive(timingMutex);
    }

    if (!hasTimingData)
    {
      Serial.print("no timing data");
    }

    // Print call data if available
    if (xSemaphoreTake(callCountMutex, portMAX_DELAY) == pdTRUE)
    {
      auto cpsIt = callsPerSecond.find(key);
      if (cpsIt != callsPerSecond.end())
      {
        Serial.print(" - ");
        Serial.print(cpsIt->second);
        Serial.print(" calls/sec");
      }

      auto currentIt = callCounts.find(key);
      if (currentIt != callCounts.end())
      {
        Serial.print(" (current: ");
        Serial.print(currentIt->second);
        Serial.print(")");
      }
      xSemaphoreGive(callCountMutex);
    }

    Serial.println();
  }
  Serial.println("=============================");
}

// Global instance
TimeProfiler timeProfiler;========
==== IO/TimeProfiler.h: ====
#pragma once

#include <Arduino.h>
#include <map>
#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"

enum class TimeUnit
{
  MICROSECONDS,
  MILLISECONDS
};

struct TimingData
{
  uint32_t time;
  TimeUnit unit;
};

class TimeProfiler
{
private:
  std::map<String, uint32_t> startTimes;
  std::map<String, TimeUnit> startUnits;
  std::map<String, TimingData> elapsedTimes;

  // Separate call counting system
  std::map<String, uint32_t> callCounts;
  std::map<String, uint32_t> callsPerSecond;

  // Mutexes for thread safety
  SemaphoreHandle_t timingMutex;
  SemaphoreHandle_t callCountMutex;

public:
  TimeProfiler();

  // Initialize the FreeRTOS task for call counter resets
  void begin();

  // === TIMING SYSTEM ===
  // Start timing for a given key (defaults to microseconds)
  void start(const String &key, TimeUnit unit = TimeUnit::MICROSECONDS);

  // Stop timing for a given key and store the elapsed time in the original unit
  void stop(const String &key);

  // Get the elapsed time for a key in its original recorded unit
  uint32_t getTime(const String &key);

  // Get the time unit that was used for recording
  TimeUnit getTimeUnit(const String &key);

  // Get time converted to microseconds (regardless of original unit)
  uint32_t getTimeUs(const String &key);

  // Get time converted to milliseconds (regardless of original unit)
  float getTimeMs(const String &key);

  // === CALL COUNTING SYSTEM (independent of timing) ===
  // Increment the call counter for a given key
  void increment(const String &key);

  // Get the number of calls per second for a key
  uint32_t getCallsPerSecond(const String &key);

  // Get the current call count for a key (since last reset)
  uint32_t getCurrentCallCount(const String &key);

  // === SHARED UTILITIES ===
  // Check if a key exists in timing or call data
  bool hasKey(const String &key);

  // Clear all timing and call data
  void clear();

  // Remove a specific key from both systems
  void remove(const String &key);

  // Print all timing and call statistics
  void printAll();

  // Internal method called by FreeRTOS task to reset call counters
  void resetCallCounters();
};

// Global instance
extern TimeProfiler timeProfiler;
========
==== IO/Wireless.cpp: ====
#include "Wireless.h"
#include "esp_now.h"
#include "WiFi.h"
#include "IO/TimeProfiler.h"

uint8_t BROADCAST_MAC[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

Wireless::Wireless()
{
}

void Wireless::setup()
{
#ifndef ESPNOW_NO_DISABLE_WIFI
  WiFi.disconnect();
  WiFi.mode(WIFI_STA);
#endif

#ifndef ESPNOW_NO_DISABLE_WIFI
  // Set WiFi channel using promiscuous mode (temporarily enabled)
  esp_wifi_set_promiscuous(true);
  esp_wifi_set_channel(ESP_NOW_CHANNEL, WIFI_SECOND_CHAN_NONE);
  esp_wifi_set_promiscuous(false);
#endif

  if (esp_now_init() != ESP_OK)
  {
    Serial.println("Error initializing ESP-NOW");
    return;
  }

  // Note: Using the global 'wireless' instance for callbacks.
  esp_now_register_send_cb([](const uint8_t *mac_addr,
                              esp_now_send_status_t status)
                           { wireless.sendCallback(mac_addr, status); });

  esp_now_register_recv_cb([](const uint8_t *mac_addr,
                              const uint8_t *data,
                              int len)
                           { wireless.recvCallback(mac_addr, data, len); });

  setupDone = true;
}

void Wireless::unSetup()
{
  setupDone = false;
  esp_now_deinit();
  esp_now_unregister_recv_cb();
  esp_now_unregister_send_cb();
}

void Wireless::loop()
{
  if (!setupDone)
    return;
}

bool Wireless::isSetupDone()
{
  return setupDone;
}

void Wireless::sendCallback(const uint8_t *mac_addr,
                            esp_now_send_status_t status)
{
  char macStr[18];
  snprintf(macStr, sizeof(macStr),
           "%02x:%02x:%02x:%02x:%02x:%02x",
           mac_addr[0], mac_addr[1], mac_addr[2],
           mac_addr[3], mac_addr[4], mac_addr[5]);

#ifdef DEBUG_ESP_NOW
  Serial.println("########### Sent Packet ###########");
  Serial.printf("Sent to: %s\n", macStr);
  Serial.printf("Send Status: %s\n",
                status == ESP_NOW_SEND_SUCCESS ? "Delivery Success" : "Delivery Fail");
  Serial.println("###################################");
#endif

  lastStatus = status;
}

void Wireless::recvCallback(const uint8_t *mac_addr, const uint8_t *data,
                            int len)
{
  timeProfiler.increment("packetPps");
  char macStr[18];
  snprintf(macStr, sizeof(macStr),
           "%02x:%02x:%02x:%02x:%02x:%02x",
           mac_addr[0], mac_addr[1], mac_addr[2],
           mac_addr[3], mac_addr[4], mac_addr[5]);

  data_packet *p = (data_packet *)data;

#ifdef DEBUG_ESP_NOW
  Serial.println("########### Received Packet ###########");
  Serial.printf("Recv from: %s\n", macStr);
  Serial.printf("Type: %d\n", p->type);
  Serial.printf("Len: %d\n", p->len);

  // Build the data string using pointer arithmetic for speed.
  char dataStr[256];
  int pos = 0;
  for (int i = 0; i < p->len && pos < (int)sizeof(dataStr); i++)
  {
    pos += snprintf(dataStr + pos, sizeof(dataStr) - pos, "%02X ", p->data[i]);
  }
  Serial.printf("Data: %s\n", dataStr);
  Serial.println("#######################################");
#endif

  fullPacket fp;
  memcpy(fp.mac, mac_addr, ESP_NOW_ETH_ALEN);
  fp.direction = PacketDirection::RECV;
  memcpy(&fp.p, p, sizeof(data_packet));

  // Call a type-specific callback if available, otherwise the generic one
  auto it = onReceiveForCallbacks.find(fp.p.type);
  if (it != onReceiveForCallbacks.end())
  {
    it->second(&fp);
  }
  else if (onReceiveOtherCb)
  {
    onReceiveOtherCb(&fp);
  }
}

void Wireless::setOnReceiveOther(std::function<void(fullPacket *fp)> cb)
{
  onReceiveOtherCb = cb;
}

void Wireless::addOnReceiveFor(uint8_t type,
                               std::function<void(fullPacket *fp)> cb)
{
  onReceiveForCallbacks[type] = cb;
}

void Wireless::removeOnReceiveFor(uint8_t type)
{
  onReceiveForCallbacks.erase(type);
}

int Wireless::send(data_packet *p, uint8_t *peer_addr)
{
  return send((uint8_t *)p, sizeof(data_packet), peer_addr);
}

int Wireless::send(uint8_t *data, size_t len, uint8_t *peer_addr)
{
  if (!setupDone)
  {
    Serial.println("ESP-NOW not initialized");
    return -1;
  }

  esp_now_peer_info_t peerInfo;
  memset(&peerInfo, 0, sizeof(peerInfo));
  memcpy(peerInfo.peer_addr, peer_addr, ESP_NOW_ETH_ALEN);
  peerInfo.channel = ESP_NOW_CHANNEL;
  peerInfo.encrypt = false;
  // Explicitly select the WiFi interface (typically WIFI_IF_STA)
  peerInfo.ifidx = WIFI_IF_STA;

#ifdef DEBUG_ESP_NOW
  Serial.println("######################");
  char peerStr[32];
  int pos = 0;
  for (int i = 0; i < ESP_NOW_ETH_ALEN; i++)
  {
    pos += snprintf(peerStr + pos, sizeof(peerStr) - pos, "%02X ",
                    peerInfo.peer_addr[i]);
  }
  Serial.printf("Peer info: %s\n", peerStr);
  Serial.printf("Channel: %d\n", peerInfo.channel);
  Serial.printf("Encrypt: %d\n", peerInfo.encrypt);
  uint8_t dataLen = data[1];
  Serial.printf("Data:\n");
  for (int i = 0; i < dataLen + 2; i++)
  {
    Serial.printf("%02X ", data[i]);
  }
  Serial.println("\n######################");
#endif

  esp_err_t err = esp_now_add_peer(&peerInfo);
  if (err != ESP_OK)
  {
    Serial.printf("Failed to add peer, error: %d\n", err);
    return -1;
  }
#ifdef DEBUG_ESP_NOW
  Serial.println("Peer added");
#endif

  err = esp_now_send(peerInfo.peer_addr, data, len);
  if (err != ESP_OK)
  {
    Serial.printf("Failed to send data, error: %d\n", err);
    // Attempt to clean up even if sending fails.
    esp_now_del_peer(peer_addr);
    return -1;
  }
#ifdef DEBUG_ESP_NOW
  Serial.println("Data sent");
#endif

  err = esp_now_del_peer(peer_addr);
  if (err != ESP_OK)
  {
    Serial.printf("Failed to delete peer, error: %d\n", err);
    return -1;
  }
#ifdef DEBUG_ESP_NOW
  Serial.println("Peer deleted");
  Serial.println("######################");
#endif

  return 0;
}

int Wireless::send(fullPacket *fp)
{
  if (fp->direction == PacketDirection::SEND)
  {
    return send(&fp->p, fp->mac);
  }
  else
  {
    Serial.println("Cannot send a receive packet");
    return -1;
  }
}

Wireless wireless;========
==== IO/Wireless.h: ====
#pragma once

#include "config.h"
#include <functional>
#include <map>

struct __attribute__((packed)) data_packet
{
  uint8_t type;
  uint8_t len;
  uint8_t data[200];
};

enum class PacketDirection
{
  SEND,
  RECV
};

struct fullPacket
{
  uint8_t mac[6];
  PacketDirection direction;
  data_packet p;
};

extern uint8_t BROADCAST_MAC[6];

class Wireless
{
private:
  bool setupDone = false;

  std::function<void(fullPacket *fp)> onReceiveOtherCb;
  std::map<uint8_t, std::function<void(fullPacket *fp)>> onReceiveForCallbacks;

public:
  esp_now_send_status_t lastStatus = ESP_NOW_SEND_FAIL;

  Wireless();
  void setup();
  void unSetup();
  void loop();

  bool isSetupDone();

  void sendCallback(const uint8_t *mac_addr,
                    esp_now_send_status_t status);
  void recvCallback(const uint8_t *mac_addr, const uint8_t *data, int len);

  // Set the generic "other" callback.
  void setOnReceiveOther(std::function<void(fullPacket *fp)> cb);
  // Register a type-specific callback.
  void addOnReceiveFor(uint8_t type,
                       std::function<void(fullPacket *fp)> cb);
  // Remove a type-specific callback.
  void removeOnReceiveFor(uint8_t type);

  int send(data_packet *p, u8_t *peer_addr);
  int send(u8_t *data, size_t len, u8_t *peer_addr);

  int send(fullPacket *fp);
};

extern Wireless wireless;
========
==== Screens/ApplicationScreen.cpp: ====
#include "ApplicationScreen.h"
#include "IO/Display.h"
#include "IO/GPIO.h"
#include "IO/Menu.h"
#include "Application.h"
#include "IO/LED/LEDStripManager.h"
#include "IO/StatusLed.h"
#include "IO/ScreenManager.h"

namespace ApplicationScreenNamespace
{
  // Application state variables
  static Application *app;

  // Effect states
  static bool leftIndicatorActive = false;
  static bool rightIndicatorActive = false;

  static int headlightMode = 0;
  static bool headlightSplit = false;
  static bool headlightR = false;
  static bool headlightG = false;
  static bool headlightB = false;

  static int taillightMode = 0;
  static bool taillightSplit = false;

  static bool rgbEffectActive = false;
  static bool nightriderEffectActive = false;
  static bool policeEffectActive = false;
  static PoliceMode policeMode = PoliceMode::SLOW;
  static bool pulseWaveEffectActive = false;
  static bool auroraEffectActive = false;
  static bool solidColorEffectActive = false;
  static SolidColorPreset solidColorPreset = SolidColorPreset::OFF;
  static uint8_t solidColorR = 255;
  static uint8_t solidColorG = 255;
  static uint8_t solidColorB = 255;

  // Test mode input overrides
  static bool accOnOverride = false;
  static bool indicatorLeftOverride = false;
  static bool indicatorRightOverride = false;
  static bool headlightOverride = false;
  static bool brakeOverride = false;
  static bool reverseOverride = false;

  // Menu instance
  static Menu menu = Menu(MenuSize::Medium);

  // Menu items
  static MenuItemBack backItem;

  // Mode control
  static std::vector<String> modeItems = {"Normal", "Test", "Remote", "Off"};
  static MenuItemSelect modeSelectItem = MenuItemSelect("Mode", modeItems, 0);

  // Effects control
  static MenuItemToggle leftIndicatorItem = MenuItemToggle("Left Ind", &leftIndicatorActive, true);
  static MenuItemToggle rightIndicatorItem = MenuItemToggle("Right Ind", &rightIndicatorActive, true);

  // Headlight controls
  static std::vector<String> headlightModeItems = {"Off", "Startup", "On"};
  static MenuItemSelect headlightModeItem = MenuItemSelect("H.Mode", headlightModeItems, 0);
  static MenuItemToggle headlightSplitItem = MenuItemToggle("H.Split", &headlightSplit, true);
  static MenuItemToggle headlightRItem = MenuItemToggle("H.R", &headlightR, true);
  static MenuItemToggle headlightGItem = MenuItemToggle("H.G", &headlightG, true);
  static MenuItemToggle headlightBItem = MenuItemToggle("H.B", &headlightB, true);

  // Taillight controls
  static std::vector<String> taillightModeItems = {"Off", "Startup", "On", "Dim"};
  static MenuItemSelect taillightModeItem = MenuItemSelect("T.Mode", taillightModeItems, 0);
  static MenuItemToggle taillightSplitItem = MenuItemToggle("T.Split", &taillightSplit, true);

  // Additional effects
  static MenuItemToggle rgbEffectItem = MenuItemToggle("RGB", &rgbEffectActive, true);
  static MenuItemToggle nightriderEffectItem = MenuItemToggle("N.Rider", &nightriderEffectActive, true);
  static MenuItemToggle policeEffectItem = MenuItemToggle("Police", &policeEffectActive, true);
  static std::vector<String> policeModeItems = {"Slow", "Fast"};
  static MenuItemSelect policeModeItem = MenuItemSelect("P.Mode", policeModeItems, 0);
  static MenuItemToggle pulseWaveEffectItem = MenuItemToggle("Pulse", &pulseWaveEffectActive, true);
  static MenuItemToggle auroraEffectItem = MenuItemToggle("Aurora", &auroraEffectActive, true);
  static MenuItemToggle solidColorEffectItem = MenuItemToggle("Solid", &solidColorEffectActive, true);

  // Solid color controls
  static std::vector<String> solidColorPresetItems = {"Off", "Red", "Green", "Blue", "White", "Yellow", "Cyan", "Magenta", "Orange", "Purple", "Lime", "Pink", "Teal", "Indigo", "Gold", "Silver", "Custom"};
  static MenuItemSelect solidColorPresetItem = MenuItemSelect("SC Col", solidColorPresetItems, 0);
  static MenuItemNumber<uint8_t> solidColorRItem = MenuItemNumber<uint8_t>("SC R", &solidColorR, 0, 255, 5);
  static MenuItemNumber<uint8_t> solidColorGItem = MenuItemNumber<uint8_t>("SC G", &solidColorG, 0, 255, 5);
  static MenuItemNumber<uint8_t> solidColorBItem = MenuItemNumber<uint8_t>("SC B", &solidColorB, 0, 255, 5);

  // Test inputs (for test mode)
  static MenuItemToggle accOnItem = MenuItemToggle("ACC", &accOnOverride, true);
  static MenuItemToggle indicatorLeftItem = MenuItemToggle("Ind L", &indicatorLeftOverride, true);
  static MenuItemToggle indicatorRightItem = MenuItemToggle("Ind R", &indicatorRightOverride, true);
  static MenuItemToggle headlightItem = MenuItemToggle("H.Light", &headlightOverride, true);
  static MenuItemToggle brakeItem = MenuItemToggle("Brake", &brakeOverride, true);
  static MenuItemToggle reverseItem = MenuItemToggle("Reverse", &reverseOverride, true);

  // Forward declare sequence functions
  void triggerUnlockSequence();
  void triggerLockSequence();
  void triggerRGBSequence();
  void triggerNightRiderSequence();

  // Sequence triggers
  static MenuItemAction unlockSequenceItem = MenuItemAction("Unlock Seq", 1, []()
                                                            { triggerUnlockSequence(); });
  static MenuItemAction lockSequenceItem = MenuItemAction("Lock Seq", 1, []()
                                                          { triggerLockSequence(); });
  static MenuItemAction rgbSequenceItem = MenuItemAction("RGB Seq", 1, []()
                                                         { triggerRGBSequence(); });
  static MenuItemAction nightRiderSequenceItem = MenuItemAction("NR Seq", 1, []()
                                                                { triggerNightRiderSequence(); });

  // Helper method forward declarations
  void updateEffectsFromApplication();
  void applyEffectsToApplication();
  void updateModeDisplay();

  // Helper method implementations
  void triggerUnlockSequence()
  {
    // Trigger unlock sequence
    display.showNotification("Unlock sequence triggered", 1500);
  }

  void triggerLockSequence()
  {
    // Trigger lock sequence
    display.showNotification("Lock sequence triggered", 1500);
  }

  void triggerRGBSequence()
  {
    // Trigger RGB sequence
    display.showNotification("RGB sequence triggered", 1500);
  }

  void triggerNightRiderSequence()
  {
    // Trigger Night Rider sequence
    display.showNotification("Night Rider sequence triggered", 1500);
  }

  // onEnter function
  void applicationScreenOnEnter()
  {
    // Setup menu structure
    menu.addMenuItem(&backItem);
    menu.addMenuItem(&modeSelectItem);

    // Effects
    menu.addMenuItem(&leftIndicatorItem);
    menu.addMenuItem(&rightIndicatorItem);

    // Headlight controls
    menu.addMenuItem(&headlightModeItem);
    menu.addMenuItem(&headlightSplitItem);
    menu.addMenuItem(&headlightRItem);
    menu.addMenuItem(&headlightGItem);
    menu.addMenuItem(&headlightBItem);

    // Taillight controls
    menu.addMenuItem(&taillightModeItem);
    menu.addMenuItem(&taillightSplitItem);

    // Additional effects
    menu.addMenuItem(&rgbEffectItem);
    menu.addMenuItem(&nightriderEffectItem);
    menu.addMenuItem(&policeEffectItem);
    menu.addMenuItem(&policeModeItem);
    menu.addMenuItem(&pulseWaveEffectItem);
    menu.addMenuItem(&auroraEffectItem);
    menu.addMenuItem(&solidColorEffectItem);
    menu.addMenuItem(&solidColorPresetItem);
    menu.addMenuItem(&solidColorRItem);
    menu.addMenuItem(&solidColorGItem);
    menu.addMenuItem(&solidColorBItem);

    // Test mode inputs
    menu.addMenuItem(&accOnItem);
    menu.addMenuItem(&indicatorLeftItem);
    menu.addMenuItem(&indicatorRightItem);
    menu.addMenuItem(&headlightItem);
    menu.addMenuItem(&brakeItem);
    menu.addMenuItem(&reverseItem);

    // Sequences
    menu.addMenuItem(&unlockSequenceItem);
    menu.addMenuItem(&lockSequenceItem);
    menu.addMenuItem(&rgbSequenceItem);
    menu.addMenuItem(&nightRiderSequenceItem);

    // Set up callbacks
    modeSelectItem.setOnChange([]()
                               {
      int mode = modeSelectItem.getCurrentIndex();
      switch (mode)
      {
      case 0:
        app->enableNormalMode();
        break;
      case 1:
        app->enableTestMode();
        break;
      case 2:
        app->enableRemoteMode();
        break;
      case 3:
        app->enableOffMode();
        break;
      }
      updateModeDisplay(); });

    // Effect callbacks
    leftIndicatorItem.setOnChange([]()
                                  { applyEffectsToApplication(); });
    rightIndicatorItem.setOnChange([]()
                                   { applyEffectsToApplication(); });
    rgbEffectItem.setOnChange([]()
                              { applyEffectsToApplication(); });
    nightriderEffectItem.setOnChange([]()
                                     { applyEffectsToApplication(); });
    policeEffectItem.setOnChange([]()
                                 { applyEffectsToApplication(); });
    pulseWaveEffectItem.setOnChange([]()
                                    { applyEffectsToApplication(); });
    auroraEffectItem.setOnChange([]()
                                 { applyEffectsToApplication(); });
    solidColorEffectItem.setOnChange([]()
                                     { applyEffectsToApplication(); });

    // Mode change callbacks
    headlightModeItem.setOnChange([]()
                                  {
      headlightMode = headlightModeItem.getCurrentIndex();
      applyEffectsToApplication(); });
    taillightModeItem.setOnChange([]()
                                  {
      taillightMode = taillightModeItem.getCurrentIndex();
      applyEffectsToApplication(); });
    policeModeItem.setOnChange([]()
                               {
      policeMode = static_cast<PoliceMode>(policeModeItem.getCurrentIndex());
      applyEffectsToApplication(); });
    solidColorPresetItem.setOnChange([]()
                                     {
      solidColorPreset = static_cast<SolidColorPreset>(solidColorPresetItem.getCurrentIndex());
      applyEffectsToApplication(); });

    // Split and color callbacks
    headlightSplitItem.setOnChange([]()
                                   { applyEffectsToApplication(); });
    taillightSplitItem.setOnChange([]()
                                   { applyEffectsToApplication(); });
    headlightRItem.setOnChange([]()
                               { applyEffectsToApplication(); });
    headlightGItem.setOnChange([]()
                               { applyEffectsToApplication(); });
    headlightBItem.setOnChange([]()
                               { applyEffectsToApplication(); });

    // Solid color RGB callbacks
    solidColorRItem.setOnChange([]()
                                { applyEffectsToApplication(); });
    solidColorGItem.setOnChange([]()
                                { applyEffectsToApplication(); });
    solidColorBItem.setOnChange([]()
                                { applyEffectsToApplication(); });

    // Test input callbacks
    accOnItem.setOnChange([]()
                          { applyEffectsToApplication(); });
    indicatorLeftItem.setOnChange([]()
                                  { applyEffectsToApplication(); });
    indicatorRightItem.setOnChange([]()
                                   { applyEffectsToApplication(); });
    headlightItem.setOnChange([]()
                              { applyEffectsToApplication(); });
    brakeItem.setOnChange([]()
                          { applyEffectsToApplication(); });
    reverseItem.setOnChange([]()
                            { applyEffectsToApplication(); });

    // Enable fast update for color sliders
    solidColorRItem.setFastUpdate(true);
    solidColorGItem.setFastUpdate(true);
    solidColorBItem.setFastUpdate(true);

    // Initialize application
    app = Application::getInstance();
    updateEffectsFromApplication();
    updateModeDisplay();
  }

  // onExit function
  void applicationScreenOnExit()
  {
    // Clean up allocated memory
  }

  // draw function
  void applicationScreenDraw()
  {
    updateModeDisplay();

    // Hide/show controls based on current mode
    ApplicationMode currentMode = static_cast<ApplicationMode>(modeSelectItem.getCurrentIndex());

    bool isTestMode = (currentMode == ApplicationMode::TEST);
    bool isOffMode = (currentMode == ApplicationMode::OFF);

    // Hide most effects in OFF mode
    leftIndicatorItem.setHidden(isOffMode);
    rightIndicatorItem.setHidden(isOffMode);
    headlightModeItem.setHidden(isOffMode);
    headlightSplitItem.setHidden(isOffMode);
    headlightRItem.setHidden(isOffMode);
    headlightGItem.setHidden(isOffMode);
    headlightBItem.setHidden(isOffMode);
    taillightModeItem.setHidden(isOffMode);
    taillightSplitItem.setHidden(isOffMode);
    rgbEffectItem.setHidden(isOffMode);
    nightriderEffectItem.setHidden(isOffMode);
    policeEffectItem.setHidden(isOffMode);
    policeModeItem.setHidden(isOffMode);
    pulseWaveEffectItem.setHidden(isOffMode);
    auroraEffectItem.setHidden(isOffMode);
    solidColorEffectItem.setHidden(isOffMode);
    solidColorPresetItem.setHidden(isOffMode);
    solidColorRItem.setHidden(isOffMode);
    solidColorGItem.setHidden(isOffMode);
    solidColorBItem.setHidden(isOffMode);

    // Show test inputs only in test mode
    accOnItem.setHidden(!isTestMode);
    indicatorLeftItem.setHidden(!isTestMode);
    indicatorRightItem.setHidden(!isTestMode);
    headlightItem.setHidden(!isTestMode);
    brakeItem.setHidden(!isTestMode);
    reverseItem.setHidden(!isTestMode);

    // Show sequences in normal mode only
    unlockSequenceItem.setHidden(isTestMode || isOffMode);
    lockSequenceItem.setHidden(isTestMode || isOffMode);
    rgbSequenceItem.setHidden(isTestMode || isOffMode);
    nightRiderSequenceItem.setHidden(isTestMode || isOffMode);

    menu.draw();
  }

  // update function
  void applicationScreenUpdate()
  {
    updateEffectsFromApplication();
    menu.update();
  }

  // Helper method implementations
  void updateEffectsFromApplication()
  {
    // This would update the UI from the current application state
    // Implementation depends on how the Application class exposes its state
    // For now, we'll keep track of state internally and apply changes
  }

  void applyEffectsToApplication()
  {
    if (!app)
      return;

    LEDStripManager *ledManager = LEDStripManager::getInstance();

    // Apply effects based on current application state
    // This is a simplified version - you may need to adjust based on
    // how the Application class actually manages effects

    // For test mode, apply input overrides
    ApplicationMode currentMode = static_cast<ApplicationMode>(modeSelectItem.getCurrentIndex());
    if (currentMode == ApplicationMode::TEST)
    {
      // Apply test input overrides
      // This would require access to the Application's input system
      // Implementation depends on how inputs are exposed
    }
  }

  void updateModeDisplay()
  {
    // Update mode display based on current application mode
    // This should reflect the actual application state
  }

} // namespace ApplicationScreenNamespace

// Define the ApplicationScreen Screen2 instance
const Screen2 ApplicationScreen = {
    F("Application"),
    F("Application"),
    ApplicationScreenNamespace::applicationScreenDraw,
    ApplicationScreenNamespace::applicationScreenUpdate,
    ApplicationScreenNamespace::applicationScreenOnEnter,
    ApplicationScreenNamespace::applicationScreenOnExit};========
==== Screens/ApplicationScreen.h: ====
#pragma once

#include "config.h"
#include "IO/ScreenManager.h"

extern const Screen2 ApplicationScreen;========
==== Screens/Debug/Battery.cpp: ====
#include "Battery.h"
#include "IO/Display.h"
#include "IO/GPIO.h"
#include "IO/Battery.h"
#include "IO/ScreenManager.h"

namespace BatteryScreenNamespace
{
  // onEnter function
  void batteryScreenOnEnter()
  {
    // Called when screen is entered
  }

  // onExit function
  void batteryScreenOnExit()
  {
    // Clean up allocated memory
  }

  // draw function
  void batteryScreenDraw()
  {
    display.u8g2.setFont(u8g2_font_logisoso16_tf);
    display.u8g2.setDrawColor(1);

    char buffer[32];
    sprintf(buffer, "%.2fV. %d%", batteryGetVoltage(), batteryGetPercentage());
    display.u8g2.drawStr(0, 28, buffer);

    sprintf(buffer, "%.2fV. %d%", batteryGetVoltageSmooth(), batteryGetPercentageSmooth());
    display.u8g2.drawStr(0, 46, buffer);
  }

  // update function
  void batteryScreenUpdate()
  {
    if (BtnSel.clicks != 0)
    {
      screenManager.back();
    }
  }

} // namespace BatteryScreenNamespace

// Define the BatteryScreen Screen2 instance
const Screen2 BatteryScreen = {
    F("Battery"),
    F("Battery"),
    BatteryScreenNamespace::batteryScreenDraw,
    BatteryScreenNamespace::batteryScreenUpdate,
    BatteryScreenNamespace::batteryScreenOnEnter,
    BatteryScreenNamespace::batteryScreenOnExit};========
==== Screens/Debug/Battery.h: ====
#pragma once

#include "config.h"
#include "IO/ScreenManager.h"

extern const Screen2 BatteryScreen;========
==== Screens/Debug/Debug.cpp: ====
#include "Debug.h"
#include "IO/Display.h"
#include "IO/GPIO.h"
#include "IO/Menu.h"
#include "IO/ScreenManager.h"
#include "IO/TimeProfiler.h"

#include "Screens/Debug/IOTest.h"
#include "Screens/Debug/Battery.h"

namespace DebugScreenNamespace
{
  // State variables
  static long bootCount;
  static bool ledState = false;
  static bool otaSetupTmp = false;

  static uint64_t totalMem = 0;
  static uint64_t freeMem = 0;
  static uint64_t usedMem = 0;

  static String totalMemStr = "0";
  static String freeMemStr = "0";
  static String usedMemStr = "0";

  // TimeProfiler timing variables
  static uint32_t clearBufferTime = 0;
  static uint32_t screenManagerDrawTime = 0;
  static uint32_t drawTopBarTime = 0;
  static uint32_t sendBufferTime = 0;
  static uint32_t screenUpdateTime = 0;
  static uint32_t updateInputsTime = 0;
  static uint32_t updateModeTime = 0;
  static uint32_t updateSyncTime = 0;
  static uint32_t updateEffectsTime = 0;
  static uint32_t drawEffectsTime = 0;
  static uint32_t syncManagerLoopTime = 0;
  static uint32_t handleSyncPacketTime = 0;

  // Calls per second variables
  static uint32_t ledFps = 0;
  static uint32_t displayFps = 0;
  static uint32_t packetPps = 0;
  static uint32_t appFps = 0;
  static uint32_t mainLoopFps = 0;

  // Menu instance
  static Menu menu = Menu(MenuSize::Medium);

  // Menu items
  static MenuItemBack backItem;
  static MenuItemNavigate ioTestItem = MenuItemNavigate("IO Test", &IOTestScreen);
  static MenuItemNavigate batteryItem = MenuItemNavigate("Battery", &BatteryScreen);
  static MenuItemNumber<long> bootCountItem = MenuItemNumber<long>("Boot", &bootCount);
  static MenuItemString totalMemItem = MenuItemString("tmem", &totalMemStr);
  static MenuItemString freeMemItem = MenuItemString("fmem", &freeMemStr);
  static MenuItemString usedMemItem = MenuItemString("umem", &usedMemStr);

  // Display timing items
  static MenuItem displayTimingItem = MenuItem("OLED Timing");
  static MenuItemNumber<uint32_t> clearBufferTimeItem = MenuItemNumber<uint32_t>("clrb", &clearBufferTime);
  static MenuItemNumber<uint32_t> screenManagerDrawTimeItem = MenuItemNumber<uint32_t>("smdraw", &screenManagerDrawTime);
  static MenuItemNumber<uint32_t> drawTopBarTimeItem = MenuItemNumber<uint32_t>("dtb", &drawTopBarTime);
  static MenuItemNumber<uint32_t> sendBufferTimeItem = MenuItemNumber<uint32_t>("sendb", &sendBufferTime);
  static MenuItemNumber<uint32_t> screenUpdateTimeItem = MenuItemNumber<uint32_t>("su", &screenUpdateTime);

  // Application timing items
  static MenuItem applicationTimingItem = MenuItem("App Timing");
  static MenuItemNumber<uint32_t> updateInputsTimeItem = MenuItemNumber<uint32_t>("uinput", &updateInputsTime);
  static MenuItemNumber<uint32_t> updateModeTimeItem = MenuItemNumber<uint32_t>("ummode", &updateModeTime);
  static MenuItemNumber<uint32_t> updateSyncTimeItem = MenuItemNumber<uint32_t>("usync", &updateSyncTime);
  static MenuItemNumber<uint32_t> updateEffectsTimeItem = MenuItemNumber<uint32_t>("ueeffect", &updateEffectsTime);
  static MenuItemNumber<uint32_t> drawEffectsTimeItem = MenuItemNumber<uint32_t>("deffect", &drawEffectsTime);

  // Fps items
  static MenuItem fpsItem = MenuItem("FPS");
  static MenuItemNumber<uint32_t> ledFpsItem = MenuItemNumber<uint32_t>("led", &ledFps);
  static MenuItemNumber<uint32_t> displayFpsItem = MenuItemNumber<uint32_t>("dis", &displayFps);
  static MenuItemNumber<uint32_t> packetPpsItem = MenuItemNumber<uint32_t>("pkt", &packetPps);
  static MenuItemNumber<uint32_t> appFpsItem = MenuItemNumber<uint32_t>("app", &appFps);
  static MenuItemNumber<uint32_t> mainLoopFpsItem = MenuItemNumber<uint32_t>("ml", &mainLoopFps);

    // onEnter function
  void debugScreenOnEnter()
  {
    bootCount = preferences.getLong("bootCount", 0);

    // Setup menu
    menu.addMenuItem(&backItem);
    menu.addMenuItem(&ioTestItem);
    menu.addMenuItem(&batteryItem);
    menu.addMenuItem(&bootCountItem);
    menu.addMenuItem(&totalMemItem);
    menu.addMenuItem(&freeMemItem);
    menu.addMenuItem(&usedMemItem);

    // Display timing items
    menu.addMenuItem(&displayTimingItem);
    menu.addMenuItem(&clearBufferTimeItem);
    menu.addMenuItem(&screenManagerDrawTimeItem);
    menu.addMenuItem(&drawTopBarTimeItem);
    menu.addMenuItem(&sendBufferTimeItem);
    menu.addMenuItem(&screenUpdateTimeItem);

    // Application timing items
    menu.addMenuItem(&applicationTimingItem);
    menu.addMenuItem(&updateInputsTimeItem);
    menu.addMenuItem(&updateModeTimeItem);
    menu.addMenuItem(&updateSyncTimeItem);
    menu.addMenuItem(&updateEffectsTimeItem);
    menu.addMenuItem(&drawEffectsTimeItem);

    // FPS items
    menu.addMenuItem(&fpsItem);
    menu.addMenuItem(&ledFpsItem);
    menu.addMenuItem(&displayFpsItem);
    menu.addMenuItem(&packetPpsItem);
    menu.addMenuItem(&appFpsItem);
    menu.addMenuItem(&mainLoopFpsItem);
  }

  // onExit function
  void debugScreenOnExit()
  {
    // Clean up allocated memory
  }

  // draw function
  void debugScreenDraw()
  {
    menu.draw();
  }

  // update function
  void debugScreenUpdate()
  {
    menu.update();

    totalMem = ESP.getHeapSize();
    freeMem = ESP.getFreeHeap();
    usedMem = totalMem - freeMem;

    totalMemStr = formatBytes(totalMem, true);
    freeMemStr = formatBytes(freeMem, true);
    usedMemStr = formatBytes(usedMem, true);

    // Update timing data from TimeProfiler
    clearBufferTime = timeProfiler.getTimeUs("clearBuffer");
    screenManagerDrawTime = timeProfiler.getTimeUs("screenManagerDraw");
    drawTopBarTime = timeProfiler.getTimeUs("drawTopBar");
    sendBufferTime = timeProfiler.getTimeMs("sendBuffer");
    screenUpdateTime = timeProfiler.getTimeUs("screenUpdate");
    updateInputsTime = timeProfiler.getTimeUs("updateInputs");
    updateModeTime = timeProfiler.getTimeUs("updateMode");
    updateSyncTime = timeProfiler.getTimeUs("updateSync");
    updateEffectsTime = timeProfiler.getTimeUs("updateEffects");
    drawEffectsTime = timeProfiler.getTimeUs("drawEffects");
    syncManagerLoopTime = timeProfiler.getTimeUs("syncManagerLoop");
    handleSyncPacketTime = timeProfiler.getTimeUs("handleSyncPacket");

    // Update calls per second data from TimeProfiler
    ledFps = timeProfiler.getCallsPerSecond("ledFps");
    displayFps = timeProfiler.getCallsPerSecond("displayFps");
    packetPps = timeProfiler.getCallsPerSecond("packetPps");
    appFps = timeProfiler.getCallsPerSecond("appFps");
    mainLoopFps = timeProfiler.getCallsPerSecond("mainLoopFps");
  }

} // namespace DebugScreenNamespace

// Define the DebugScreen Screen2 instance
const Screen2 DebugScreen = {
    F("Debug"),
    F("Debug"),
    DebugScreenNamespace::debugScreenDraw,
    DebugScreenNamespace::debugScreenUpdate,
    DebugScreenNamespace::debugScreenOnEnter,
    DebugScreenNamespace::debugScreenOnExit};========
==== Screens/Debug/Debug.h: ====
#pragma once

#include "config.h"
#include "IO/ScreenManager.h"

extern const Screen2 DebugScreen;========
==== Screens/Debug/IOTest.cpp: ====
#include "IOTest.h"
#include "IO/Display.h"
#include "IO/GPIO.h"
#include "IO/ScreenManager.h"

namespace IOTestScreenNamespace
{
  // State variables
  static int lastButtonClicks = 0;

  // onEnter function
  void ioTestScreenOnEnter()
  {
    lastButtonClicks = 0;
  }

  // onExit function
  void ioTestScreenOnExit()
  {
    // Clean up allocated memory
  }

  // draw function
  void ioTestScreenDraw()
  {
    // Update button states
    BtnSel.Update();
    BtnPrev.Update();
    BtnNext.Update();
    BtnBoot.Update();

    if (BtnSel.clicks != 0)
    {
      lastButtonClicks = BtnSel.clicks;
    }

    display.u8g2.setFont(u8g2_font_logisoso16_tf);
    display.u8g2.setDrawColor(1);

    // Display button states
    char buffer[64];
    sprintf(buffer, "Sel: %d : %d", BtnSel.depressed ? 1 : 0, lastButtonClicks);
    display.u8g2.drawStr(0, 20, buffer);

    sprintf(buffer, "Prev: %d", BtnPrev.depressed ? 1 : 0);
    display.u8g2.drawStr(0, 38, buffer);

    sprintf(buffer, "Next: %d", BtnNext.depressed ? 1 : 0);
    display.u8g2.drawStr(0, 56, buffer);

    sprintf(buffer, "Boot: %d", BtnBoot.depressed ? 1 : 0);
    display.u8g2.drawStr(0, 74, buffer);

#ifdef ENABLE_HV_INPUTS
    // Display voltage inputs
    sprintf(buffer, "V: %.2fV", (float)voltage.analogRead() * 3.3f / 4095.0f);
    display.u8g2.drawStr(0, 92, buffer);

    sprintf(buffer, "In1: %d In2: %d", input1.read() ? 1 : 0, input2.read() ? 1 : 0);
    display.u8g2.drawStr(0, 110, buffer);
#endif
  }

  // update function
  void ioTestScreenUpdate()
  {
    // Update all buttons
    BtnSel.Update();
    BtnPrev.Update();
    BtnNext.Update();
    BtnBoot.Update();

    // Single click on SEL button to go back
    if (BtnSel.clicks == 1)
    {
      screenManager.back();
    }

    // Triple click to reset button click counter
    if (BtnSel.clicks == 3)
    {
      lastButtonClicks = 0;
    }
  }

} // namespace IOTestScreenNamespace

// Define the IOTestScreen Screen2 instance
const Screen2 IOTestScreen = {
    F("IO Test"),
    F("IO Test"),
    IOTestScreenNamespace::ioTestScreenDraw,
    IOTestScreenNamespace::ioTestScreenUpdate,
    IOTestScreenNamespace::ioTestScreenOnEnter,
    IOTestScreenNamespace::ioTestScreenOnExit};========
==== Screens/Debug/IOTest.h: ====
#pragma once

#include "config.h"
#include "IO/ScreenManager.h"

extern const Screen2 IOTestScreen;========
==== Screens/Home.cpp: ====
#include "Home.h"

#include "IO/Display.h"
#include "IO/ScreenManager.h"

#include "IO/Menu.h"

#include "IO/GPIO.h"

#include "Screens/ApplicationScreen.h"
#include "Screens/SyncScreen.h"
#include "Screens/SettingsScreen.h"
#include "Screens/Debug/Debug.h"

namespace HomeScreenNamespace
{
  // Menu instance
  Menu menu = Menu(MenuSize::Medium);

  // Menu items
  MenuItemNavigate applicationMenuItem = MenuItemNavigate("Application", &ApplicationScreen);
  MenuItemNavigate syncMenuItem = MenuItemNavigate("Sync Manager", &SyncScreen);
  MenuItemNavigate settingsMenuItem = MenuItemNavigate("Settings", &SettingsScreen);

  MenuItemAction disableScreenItem = MenuItemAction(
      "Disable Screen", 1, []()
      {
        deviceInfo.oledEnabled = false;
        saveDeviceInfo();
        display.u8g2.clearBuffer();
        display.u8g2.sendBuffer();
        Serial.println("[INFO] [SCREEN] Screen disabled via menu"); });

  MenuItemAction powerOffItem = MenuItemAction(
      "Power Off", -1, []()
      {
        // Navigate to shutdown screen - assuming there's a shutdown screen
        // This will need to be adapted based on your actual screen setup
        // screenManager.setScreen("Shutdown");
      });

  // onEnter function
  void homeScreenOnEnter()
  {
    // Initialize the menu with menu items
    menu.addMenuItem(&applicationMenuItem);
    menu.addMenuItem(&syncMenuItem);
    menu.addMenuItem(&settingsMenuItem);
    menu.addMenuItem(&disableScreenItem);
    menu.addMenuItem(&powerOffItem);

    // Add route for settings as in the original code
    settingsMenuItem.addRoute(2, &DebugScreen);
  }

  // onExit function
  void homeScreenOnExit()
  {
    // Clean up allocated memory
  }

  // draw function
  void homeScreenDraw()
  {
    menu.draw();
  }

  // update function
  void homeScreenUpdate()
  {
    menu.update();
  }

} // namespace HomeScreenNamespace

// Define the HomeScreen Screen2 instance
const Screen2 HomeScreen = {
    F("Home"),
    F("Home"),
    HomeScreenNamespace::homeScreenDraw,
    HomeScreenNamespace::homeScreenUpdate,
    HomeScreenNamespace::homeScreenOnEnter,
    HomeScreenNamespace::homeScreenOnExit};========
==== Screens/Home.h: ====
#pragma once

#include "config.h"
#include "IO/ScreenManager.h"

extern const Screen2 HomeScreen;========
==== Screens/ProvisioningRequired.cpp: ====
#include "ProvisioningRequired.h"
#include "IO/Display.h"
#include "IO/GPIO.h"

namespace ProvisioningRequiredScreenNamespace
{
  // onEnter function
  void provisioningRequiredScreenOnEnter()
  {
    // Called when screen is entered
  }

  // onExit function
  void provisioningRequiredScreenOnExit()
  {
    // Clean up allocated memory
  }

  // draw function
  void provisioningRequiredScreenDraw()
  {
    display.noTopBar();

    display.u8g2.setFont(u8g2_font_logisoso16_tr);
    display.u8g2.setDrawColor(1);

    display.drawCenteredText(20, "Provisioning");
    display.drawCenteredText(40, "Required");

    // display.u8g2.setFont(u8g2_font_6x10_tf);
    // display.drawCenteredText(58, "Device must be provisioned");
  }

  // update function
  void provisioningRequiredScreenUpdate()
  {
    // No button handling - no way to leave this screen
    // The screen is intentionally locked until provisioning is complete
  }

} // namespace ProvisioningRequiredScreenNamespace

// Define the ProvisioningRequiredScreen Screen2 instance
const Screen2 ProvisioningRequiredScreen = {
    F("Provisioning Required"),
    F("Provisioning Required"),
    ProvisioningRequiredScreenNamespace::provisioningRequiredScreenDraw,
    ProvisioningRequiredScreenNamespace::provisioningRequiredScreenUpdate,
    ProvisioningRequiredScreenNamespace::provisioningRequiredScreenOnEnter,
    ProvisioningRequiredScreenNamespace::provisioningRequiredScreenOnExit};========
==== Screens/ProvisioningRequired.h: ====
#pragma once

#include "config.h"
#include "IO/ScreenManager.h"

extern const Screen2 ProvisioningRequiredScreen;========
==== Screens/SettingsScreen.cpp: ====
#include "SettingsScreen.h"
#include "IO/Display.h"
#include "IO/GPIO.h"
#include "IO/Menu.h"
#include "IO/LED/LEDStripManager.h"
#include "IO/StatusLed.h"
#include "IO/ScreenManager.h"

namespace SettingsScreenNamespace
{
  // Helper method forward declarations
  void updateDeviceInfo();
  void updateSystemStatus();
  void updateInputStatus();
  void updatePowerStatus();
  void performReboot();
  String formatUptime(uint32_t uptimeMs);
  String formatVoltage(float voltage);

  // Settings state variables
  static bool debugModeEnabled = false;
  static uint16_t headlightLedCount = 0;
  static uint16_t taillightLedCount = 0;
  static uint16_t underglowLedCount = 0;
  static uint16_t interiorLedCount = 0;

  // Timing for updates
  static uint64_t lastInfoUpdate = 0;

  // Menu instances
  static Menu menu = Menu(MenuSize::Medium);
  static Menu deviceInfoMenu = Menu(MenuSize::Small);
  static Menu systemSettingsMenu = Menu(MenuSize::Small);
  static Menu ledSettingsMenu = Menu(MenuSize::Small);
  static Menu inputSettingsMenu = Menu(MenuSize::Small);
  static Menu powerSettingsMenu = Menu(MenuSize::Small);

  // Main menu items
  static MenuItemBack backItem;
  static MenuItemSubmenu deviceInfoUIItem = MenuItemSubmenu("Device Info", &deviceInfoMenu);
  static MenuItemSubmenu systemSettingsUIItem = MenuItemSubmenu("System", &systemSettingsMenu);
  static MenuItemSubmenu ledSettingsUIItem = MenuItemSubmenu("LED Config", &ledSettingsMenu);
  static MenuItemSubmenu inputSettingsUIItem = MenuItemSubmenu("Inputs", &inputSettingsMenu);
  static MenuItemSubmenu powerSettingsUIItem = MenuItemSubmenu("Power", &powerSettingsMenu);

  // Device Info submenu items
  static MenuItemBack deviceInfoBackItem;
  static MenuItem deviceIdItem = MenuItem("ID: ---");
  static MenuItem deviceMacItem = MenuItem("MAC: ---");
  static MenuItem serialNumberItem = MenuItem("Serial: ---");
  static MenuItem hardwareVersionItem = MenuItem("HW Ver: ---");
  static MenuItem firmwareVersionItem = MenuItem("FW Ver: v1.0.0");
  static MenuItem uptimeItem = MenuItem("Uptime: ---");
  static MenuItem freeHeapItem = MenuItem("Free Heap: ---");

  // System Settings submenu items
  static MenuItemBack systemSettingsBackItem;
  static MenuItemToggle debugModeItem = MenuItemToggle("Debug Mode", &debugModeEnabled, true);
  static MenuItemAction rebootItem = MenuItemAction("Reboot", 1, []()
                                                    { performReboot(); });

  // LED Settings submenu items
  static MenuItemBack ledSettingsBackItem;
  static MenuItemNumber<uint16_t> headlightCountItem = MenuItemNumber<uint16_t>("H.Count", &headlightLedCount, 1, 300, 1);
  static MenuItemNumber<uint16_t> taillightCountItem = MenuItemNumber<uint16_t>("T.Count", &taillightLedCount, 1, 300, 1);
  static MenuItemNumber<uint16_t> underglowCountItem = MenuItemNumber<uint16_t>("U.Count", &underglowLedCount, 1, 300, 1);
  static MenuItemNumber<uint16_t> interiorCountItem = MenuItemNumber<uint16_t>("I.Count", &interiorLedCount, 1, 300, 1);

  // Input Settings submenu items
  static MenuItemBack inputSettingsBackItem;
  static MenuItem voltageItem = MenuItem("Voltage: ---");
  static MenuItem input1StatusItem = MenuItem("Input 1: ---");
  static MenuItem input2StatusItem = MenuItem("Input 2: ---");
  static MenuItem input3StatusItem = MenuItem("Input 3: ---");
  static MenuItem input4StatusItem = MenuItem("Input 4: ---");
  static MenuItem input5StatusItem = MenuItem("Input 5: ---");
  static MenuItem input6StatusItem = MenuItem("Input 6: ---");
  static MenuItem input7StatusItem = MenuItem("Input 7: ---");
  static MenuItem input8StatusItem = MenuItem("Input 8: ---");

  // Power Settings submenu items
  static MenuItemBack powerSettingsBackItem;
  static MenuItem batteryVoltageItem = MenuItem("Bat Volt: ---");

  // onEnter function
  void settingsScreenOnEnter()
  {
    // Setup main settings menu
    menu.addMenuItem(&backItem);
    menu.addMenuItem(&deviceInfoUIItem);
    menu.addMenuItem(&systemSettingsUIItem);
    menu.addMenuItem(&ledSettingsUIItem);
    menu.addMenuItem(&inputSettingsUIItem);
    menu.addMenuItem(&powerSettingsUIItem);

    // Setup Device Info submenu
    deviceInfoMenu.addMenuItem(&deviceInfoBackItem);
    deviceInfoMenu.addMenuItem(&deviceIdItem);
    deviceInfoMenu.addMenuItem(&deviceMacItem);
    deviceInfoMenu.addMenuItem(&serialNumberItem);
    deviceInfoMenu.addMenuItem(&hardwareVersionItem);
    deviceInfoMenu.addMenuItem(&firmwareVersionItem);
    deviceInfoMenu.addMenuItem(&uptimeItem);
    deviceInfoMenu.addMenuItem(&freeHeapItem);
    deviceInfoMenu.setParentMenu(&menu);

    // Setup System Settings submenu
    systemSettingsMenu.addMenuItem(&systemSettingsBackItem);
    systemSettingsMenu.addMenuItem(&debugModeItem);
    systemSettingsMenu.addMenuItem(&rebootItem);
    systemSettingsMenu.setParentMenu(&menu);

    // Setup LED Settings submenu
    ledSettingsMenu.addMenuItem(&ledSettingsBackItem);
    ledSettingsMenu.addMenuItem(&headlightCountItem);
    ledSettingsMenu.addMenuItem(&taillightCountItem);
    ledSettingsMenu.addMenuItem(&underglowCountItem);
    ledSettingsMenu.addMenuItem(&interiorCountItem);
    ledSettingsMenu.setParentMenu(&menu);

    // Setup Input Settings submenu
    inputSettingsMenu.addMenuItem(&inputSettingsBackItem);
    inputSettingsMenu.addMenuItem(&voltageItem);
    inputSettingsMenu.addMenuItem(&input1StatusItem);
    inputSettingsMenu.addMenuItem(&input2StatusItem);
    inputSettingsMenu.addMenuItem(&input3StatusItem);
    inputSettingsMenu.addMenuItem(&input4StatusItem);
    inputSettingsMenu.addMenuItem(&input5StatusItem);
    inputSettingsMenu.addMenuItem(&input6StatusItem);
    inputSettingsMenu.addMenuItem(&input7StatusItem);
    inputSettingsMenu.addMenuItem(&input8StatusItem);
    inputSettingsMenu.setParentMenu(&menu);

    // Setup Power Settings submenu
    powerSettingsMenu.addMenuItem(&powerSettingsBackItem);
    powerSettingsMenu.addMenuItem(&batteryVoltageItem);
    powerSettingsMenu.setParentMenu(&menu);

    // Set up callbacks for entering submenus
    deviceInfoUIItem.addFunc(1, []()
                             { updateDeviceInfo(); });
    systemSettingsUIItem.addFunc(1, []()
                                 { updateSystemStatus(); });
    inputSettingsUIItem.addFunc(1, []()
                                { updateInputStatus(); });
    powerSettingsUIItem.addFunc(1, []()
                                { updatePowerStatus(); });

    // Set up change callbacks
    debugModeItem.setOnChange([]()
                              {
      deviceInfo.debugEnabled = debugModeEnabled;
      saveDeviceInfo();
      display.showNotification("Debug mode updated", 1000); });

    // Initialize data
    updateDeviceInfo();
    updateSystemStatus();
  }

  // onExit function
  void settingsScreenOnExit()
  {
    // Clean up allocated memory
  }

  // draw function
  void settingsScreenDraw()
  {
    menu.draw();
  }

  // update function
  void settingsScreenUpdate()
  {
    menu.update();

    // Update info periodically
    if (millis() - lastInfoUpdate > 1000)
    {
      lastInfoUpdate = millis();

      // Update dynamic info if we're in the relevant submenus
      Menu *currentMenu = menu.getActiveSubmenu();
      if (currentMenu == &deviceInfoMenu)
      {
        updateDeviceInfo();
      }
      else if (currentMenu == &inputSettingsMenu)
      {
        updateInputStatus();
      }
      else if (currentMenu == &powerSettingsMenu)
      {
        updatePowerStatus();
      }
    }
  }

  // Helper method implementations
  void updateDeviceInfo()
  {
    deviceIdItem.setName("ID: " + String(deviceInfo.serialNumber));

    String macStr = "";
    for (int i = 0; i < 6; i++)
    {
      if (deviceInfo.macAddress[i] < 16)
        macStr += "0";
      macStr += String(deviceInfo.macAddress[i], HEX);
      if (i < 5)
        macStr += ":";
    }
    macStr.toUpperCase();
    deviceMacItem.setName("MAC: " + macStr);

    serialNumberItem.setName("Serial: " + String(deviceInfo.serialNumber));
    hardwareVersionItem.setName("HW Ver: " + String(deviceInfo.hardwareVersion));
    uptimeItem.setName("Uptime: " + formatUptime(millis()));
    freeHeapItem.setName("Free Heap: " + formatBytes(ESP.getFreeHeap(), true));
  }

  void updateSystemStatus()
  {
    debugModeEnabled = deviceInfo.debugEnabled;
  }

  void updateInputStatus()
  {
    voltageItem.setName("Voltage: " + formatVoltage(batteryGetVoltage()));

#ifdef ENABLE_HV_INPUTS
    input1StatusItem.setName("Input 1: " + String(input1.read() ? "HIGH" : "LOW"));
    input2StatusItem.setName("Input 2: " + String(input2.read() ? "HIGH" : "LOW"));
    input3StatusItem.setName("Input 3: " + String(input3.read() ? "HIGH" : "LOW"));
    input4StatusItem.setName("Input 4: " + String(input4.read() ? "HIGH" : "LOW"));
    input5StatusItem.setName("Input 5: " + String(input5.read() ? "HIGH" : "LOW"));
    input6StatusItem.setName("Input 6: " + String(input6.read() ? "HIGH" : "LOW"));
#else
    input1StatusItem.setHidden(true);
    input2StatusItem.setHidden(true);
    input3StatusItem.setHidden(true);
    input4StatusItem.setHidden(true);
    input5StatusItem.setHidden(true);
    input6StatusItem.setHidden(true);
    input7StatusItem.setHidden(true);
    input8StatusItem.setHidden(true);
#endif
  }

  void updatePowerStatus()
  {
    batteryVoltageItem.setName("Bat Volt: " + formatVoltage(batteryGetVoltage()));
  }

  void performReboot()
  {
    display.showNotification("Rebooting...", 2000);
    delay(1500);
    restart();
  }

  String formatUptime(uint32_t uptimeMs)
  {
    uint32_t seconds = uptimeMs / 1000;
    uint32_t minutes = seconds / 60;
    uint32_t hours = minutes / 60;
    uint32_t days = hours / 24;

    if (days > 0)
    {
      return String(days) + "d " + String(hours % 24) + "h";
    }
    else if (hours > 0)
    {
      return String(hours) + "h " + String(minutes % 60) + "m";
    }
    else if (minutes > 0)
    {
      return String(minutes) + "m " + String(seconds % 60) + "s";
    }
    else
    {
      return String(seconds) + "s";
    }
  }

  String formatVoltage(float voltage)
  {
    // Voltage is float in volts
    char buffer[16];
    sprintf(buffer, "%.2fV", voltage);
    return String(buffer);
  }

} // namespace SettingsScreenNamespace

// Define the SettingsScreen Screen2 instance
const Screen2 SettingsScreen = {
    F("Settings"),
    F("Settings"),
    SettingsScreenNamespace::settingsScreenDraw,
    SettingsScreenNamespace::settingsScreenUpdate,
    SettingsScreenNamespace::settingsScreenOnEnter,
    SettingsScreenNamespace::settingsScreenOnExit};========
==== Screens/SettingsScreen.h: ====
#pragma once

#include "config.h"
#include "IO/ScreenManager.h"

extern const Screen2 SettingsScreen;========
==== Screens/Shutdown.cpp: ====
#include "Shutdown.h"
#include "IO/Display.h"
#include "IO/GPIO.h"
#include "IO/ScreenManager.h"

namespace ShutdownScreenNamespace
{
  // State variables
  static ShutdownState state;
  static unsigned long startTime = 0;
  static long countdown = 1500;
  static uint8_t progress;

  // onEnter function
  void shutdownScreenOnEnter()
  {
    state = ShutdownState::Countdown;
    startTime = millis();
  }

  // onExit function
  void shutdownScreenOnExit()
  {
    // Clean up allocated memory
  }

  // draw function
  void shutdownScreenDraw()
  {
    display.noTopBar();

    switch (state)
    {
    case ShutdownState::Countdown:

      display.u8g2.setFont(u8g2_font_logisoso16_tr);
      display.drawCenteredText(20, "Shutting down");

      display.u8g2.setFont(u8g2_font_koleeko_tf);
      display.drawCenteredText(44, "Press to cancel");

      progress = map(millis() - startTime, 0, countdown, 100, 0);
      progress = constrain(progress, 0, 100);

      display.u8g2.drawFrame(0, 48, 127, 16);
      display.u8g2.drawBox(2, 50, map(progress, 0, 100, 0, 123), 12);

      break;

    case ShutdownState::Shutdown_Warning:
      display.u8g2.setFont(u8g2_font_logisoso16_tr);
      display.u8g2.setDrawColor(1);

      display.drawCenteredText(30, "Shutting down");

      break;

    case ShutdownState::Shutdown:
      display.u8g2.setFont(u8g2_font_logisoso16_tr);
      display.u8g2.setDrawColor(1);

      display.drawCenteredText(30, "Shutting down");

      break;

    default:
      break;
    }
  }

  // update function
  void shutdownScreenUpdate()
  {
    if (BtnSel.clicks != 0)
    {
      screenManager.back();
    }
    if (state == ShutdownState::Countdown)
    {
      if (millis() - startTime > countdown)
      {
        state = ShutdownState::Shutdown_Warning;
      }
    }

    if (state == ShutdownState::Shutdown_Warning)
    {
      if (millis() - startTime > countdown + 500)
      {
        state = ShutdownState::Shutdown;
      }
    }

    if (state == ShutdownState::Shutdown)
    {
      // Shutdown
      Serial.println("Shutting down...");
    }
  }

  // Helper functions
  void setState(ShutdownState _state)
  {
    state = _state;
  }

  ShutdownState getState()
  {
    return state;
  }

} // namespace ShutdownScreenNamespace

// Define the ShutdownScreen Screen2 instance
const Screen2 ShutdownScreen = {
    F("Shutdown"),
    F("Shutdown"),
    ShutdownScreenNamespace::shutdownScreenDraw,
    ShutdownScreenNamespace::shutdownScreenUpdate,
    ShutdownScreenNamespace::shutdownScreenOnEnter,
    ShutdownScreenNamespace::shutdownScreenOnExit};========
==== Screens/Shutdown.h: ====
#pragma once

#include "config.h"
#include "IO/ScreenManager.h"

enum ShutdownState
{
  Countdown,
  Shutdown_Warning,
  Shutdown
};

extern const Screen2 ShutdownScreen;========
==== Screens/StartUp.cpp: ====
#include "StartUp.h"
#include "IO/Display.h"
#include "IO/GPIO.h"

namespace StartUpScreenNamespace
{
  // State variables
  static StartUpState state;
  static int stage;

  // onEnter function
  void startUpScreenOnEnter()
  {
    state = StartUpState::StartUp;
    stage = 0;
  }

  // onExit function
  void startUpScreenOnExit()
  {
    // Clean up allocated memory
  }

  // draw function
  void startUpScreenDraw()
  {
    display.noTopBar();

    switch (state)
    {
    case StartUpState::StartUp:
      display.u8g2.setFont(u8g2_font_logisoso16_tr);
      display.u8g2.setDrawColor(1);

      display.drawCenteredText(30, "Starting up...");
      display.drawCenteredText(54, "Stage " + String(stage));

      break;

    default:
      break;
    }
  }

  // update function
  void startUpScreenUpdate()
  {
    // No update logic in original
  }

  // Helper functions
  void setState(StartUpState _state)
  {
    state = _state;
  }

  StartUpState getState()
  {
    return state;
  }

  void setStage(int _stage)
  {
    stage = _stage;
  }

  int getStage()
  {
    return stage;
  }

} // namespace StartUpScreenNamespace

void startUpScreenSetStage(int _stage)
{
  StartUpScreenNamespace::setStage(_stage);
}

// Define the StartUpScreen Screen2 instance
const Screen2 StartUpScreen = {
    F("StartUp"),
    F("StartUp"),
    StartUpScreenNamespace::startUpScreenDraw,
    StartUpScreenNamespace::startUpScreenUpdate,
    StartUpScreenNamespace::startUpScreenOnEnter,
    StartUpScreenNamespace::startUpScreenOnExit};========
==== Screens/StartUp.h: ====
#pragma once

#include "config.h"
#include "IO/ScreenManager.h"

enum StartUpState
{
  StartUp,
};

extern const Screen2 StartUpScreen;

void startUpScreenSetStage(int _stage);
========
==== Screens/SyncScreen.cpp: ====
#include "SyncScreen.h"
#include "IO/Display.h"
#include "IO/GPIO.h"
#include "IO/Menu.h"
#include "Sync/SyncManager.h"
#include "IO/ScreenManager.h"

namespace SyncScreenNamespace
{
  // Sync state variables
  static SyncManager *syncMgr;

  // Selection tracking and state
  static uint32_t selectedDeviceId = 0;
  static uint32_t selectedGroupId = 0;
  // timing
  static uint64_t lastSyncUpdate = 0;
  static uint64_t lastSyncAutoRefresh = 0;

  // Forward declarations
  void syncRefreshData(bool showNotification = true);
  void syncCreateGroup(uint32_t groupId = 0);
  void joinSelectedGroup();
  void leaveSyncGroup();
  void updateThisDeviceDisplay();
  void updateCurrentGroupDisplay();
  void updateDevicesDisplay();
  void updateGroupsDisplay();
  void updateGroupMembersDisplay();
  void showDeviceDetail(uint32_t deviceId);
  void showGroupDetail(uint32_t groupId);
  String formatMacAddress(const uint8_t *mac);
  String formatTimeDuration(uint32_t milliseconds);
  void requestSyncDevices();
  void requestSyncGroups();
  void requestSyncGroupInfo();
  void requestSyncStatus();
  void joinSyncGroup(uint32_t groupId);
  void setSyncMode(SyncMode mode);
  void requestSyncModeStatus();

  // Menu instances
  static Menu menu = Menu(MenuSize::Medium);
  static Menu syncThisDeviceMenu = Menu(MenuSize::Small);
  static Menu syncCurrentGroupMenu = Menu(MenuSize::Small);
  static Menu groupMembersMenu = Menu(MenuSize::Small);
  static Menu syncDevicesMenu = Menu(MenuSize::Medium);
  static Menu deviceDetailMenu = Menu(MenuSize::Small);
  static Menu syncGroupsMenu = Menu(MenuSize::Medium);
  static Menu groupDetailMenu = Menu(MenuSize::Small);

  // Main menu items
  static MenuItemBack backItem;
  static MenuItemAction syncRefreshItem = MenuItemAction("Refresh", 1, []()
                                                         { syncRefreshData(); });

  // This Device section
  static MenuItemSubmenu syncThisDeviceUIItem = MenuItemSubmenu("This Device", &syncThisDeviceMenu);
  static MenuItemBack syncThisDeviceBackItem;
  static MenuItem thisDeviceIdItem = MenuItem("ID: ---");
  static MenuItem thisDeviceGroupItem = MenuItem("Group: ---");
  static MenuItem thisDeviceStatusItem = MenuItem("Status: ---");
  static std::vector<String> syncModeItems = {"Solo", "Join", "Host"};
  static int syncModeIndex = 0;
  static MenuItemSelect syncModeItem = MenuItemSelect("Mode", syncModeItems);
  static MenuItemAction leaveGroupItem = MenuItemAction("Leave Group", 1, []()
                                                        { leaveSyncGroup(); });

  // Current Group section
  static MenuItemSubmenu syncCurrentGroupUIItem = MenuItemSubmenu("Current Group", &syncCurrentGroupMenu);
  static MenuItemBack syncCurrentGroupBackItem;
  static MenuItem currentGroupIdItem = MenuItem("ID: ---");
  static MenuItem currentGroupMasterItem = MenuItem("Master: ---");
  static MenuItem currentGroupMembersItem = MenuItem("Members: ---");
  static MenuItem currentGroupSyncItem = MenuItem("Sync: ---");

  // Group Members submenu (for current group)
  static MenuItemSubmenu groupMembersUIItem = MenuItemSubmenu("View Members", &groupMembersMenu);
  static MenuItemBack groupMembersBackItem;

  // Discovered Devices section
  static MenuItemSubmenu syncDevicesUIItem = MenuItemSubmenu("Devices", &syncDevicesMenu);
  static MenuItemBack syncDevicesBackItem;
  // Device items will be statically created (max 8)
  static MenuItem deviceItems[8] = {
      MenuItem("Device 1: ---"),
      MenuItem("Device 2: ---"),
      MenuItem("Device 3: ---"),
      MenuItem("Device 4: ---"),
      MenuItem("Device 5: ---"),
      MenuItem("Device 6: ---"),
      MenuItem("Device 7: ---"),
      MenuItem("Device 8: ---")};

  // Device Detail submenu
  static MenuItemSubmenu deviceDetailUIItem = MenuItemSubmenu("Device Detail", &deviceDetailMenu);
  static MenuItemBack deviceDetailBackItem;
  static MenuItem deviceDetailIdItem = MenuItem("ID: ---");
  static MenuItem deviceDetailMacItem = MenuItem("MAC: ---");
  static MenuItem deviceDetailLastSeenItem = MenuItem("Last: ---");
  static MenuItem deviceDetailStatusItem = MenuItem("Status: ---");
  static MenuItem deviceDetailGroupItem = MenuItem("Group: ---");

  // Discovered Groups section
  static MenuItemSubmenu syncGroupsUIItem = MenuItemSubmenu("Groups", &syncGroupsMenu);
  static MenuItemBack syncGroupsBackItem;
  // Group items will be statically created (max 4)
  static MenuItem groupItems[4] = {
      MenuItem("Group 1: ---"),
      MenuItem("Group 2: ---"),
      MenuItem("Group 3: ---"),
      MenuItem("Group 4: ---")};

  // Group Detail submenu
  static MenuItemSubmenu groupDetailUIItem = MenuItemSubmenu("Group Detail", &groupDetailMenu);
  static MenuItemBack groupDetailBackItem;
  static MenuItem groupDetailIdItem = MenuItem("ID: ---");
  static MenuItem groupDetailMasterItem = MenuItem("Master: ---");
  static MenuItem groupDetailMacItem = MenuItem("MAC: ---");
  static MenuItem groupDetailLastSeenItem = MenuItem("Last: ---");
  static MenuItem groupDetailStatusItem = MenuItem("Status: ---");
  static MenuItemAction groupJoinItem = MenuItemAction("Join Group", 1, []()
                                                       { joinSelectedGroup(); });

  // Group Management
  static MenuItemAction syncCreateGroupItem = MenuItemAction("Create Group", 1, []()
                                                             { syncCreateGroup(); });

  // onEnter function
  void syncScreenOnEnter()
  {
    // Setup main sync menu
    menu.addMenuItem(&backItem);
    menu.addMenuItem(&syncRefreshItem);
    menu.addMenuItem(&syncThisDeviceUIItem);
    menu.addMenuItem(&syncCurrentGroupUIItem);
    menu.addMenuItem(&syncDevicesUIItem);
    menu.addMenuItem(&syncGroupsUIItem);
    menu.addMenuItem(&syncCreateGroupItem);

    // Setup This Device submenu
    syncThisDeviceMenu.addMenuItem(&syncThisDeviceBackItem);
    syncThisDeviceMenu.addMenuItem(&thisDeviceIdItem);
    syncThisDeviceMenu.addMenuItem(&thisDeviceGroupItem);
    syncThisDeviceMenu.addMenuItem(&thisDeviceStatusItem);
    syncThisDeviceMenu.addMenuItem(&syncModeItem);
    syncThisDeviceMenu.addMenuItem(&leaveGroupItem);
    syncThisDeviceMenu.setParentMenu(&menu);

    // Setup Current Group submenu
    syncCurrentGroupMenu.addMenuItem(&syncCurrentGroupBackItem);
    syncCurrentGroupMenu.addMenuItem(&currentGroupIdItem);
    syncCurrentGroupMenu.addMenuItem(&currentGroupMasterItem);
    syncCurrentGroupMenu.addMenuItem(&currentGroupMembersItem);
    syncCurrentGroupMenu.addMenuItem(&currentGroupSyncItem);
    syncCurrentGroupMenu.addMenuItem(&groupMembersUIItem);
    syncCurrentGroupMenu.setParentMenu(&menu);

    // Setup Group Members submenu
    groupMembersMenu.addMenuItem(&groupMembersBackItem);
    groupMembersMenu.setParentMenu(&syncCurrentGroupMenu);

    // Setup devices submenu
    syncDevicesMenu.addMenuItem(&syncDevicesBackItem);
    for (int i = 0; i < 8; i++)
    {
      syncDevicesMenu.addMenuItem(&deviceItems[i]);
    }
    syncDevicesMenu.setParentMenu(&menu);

    // Setup device detail submenu
    deviceDetailMenu.addMenuItem(&deviceDetailBackItem);
    deviceDetailMenu.addMenuItem(&deviceDetailIdItem);
    deviceDetailMenu.addMenuItem(&deviceDetailMacItem);
    deviceDetailMenu.addMenuItem(&deviceDetailLastSeenItem);
    deviceDetailMenu.addMenuItem(&deviceDetailStatusItem);
    deviceDetailMenu.addMenuItem(&deviceDetailGroupItem);
    deviceDetailMenu.setParentMenu(&syncDevicesMenu);

    // Setup groups submenu
    syncGroupsMenu.addMenuItem(&syncGroupsBackItem);
    for (int i = 0; i < 4; i++)
    {
      syncGroupsMenu.addMenuItem(&groupItems[i]);
    }
    syncGroupsMenu.setParentMenu(&menu);

    // Setup group detail submenu
    groupDetailMenu.addMenuItem(&groupDetailBackItem);
    groupDetailMenu.addMenuItem(&groupDetailIdItem);
    groupDetailMenu.addMenuItem(&groupDetailMasterItem);
    groupDetailMenu.addMenuItem(&groupDetailMacItem);
    groupDetailMenu.addMenuItem(&groupDetailLastSeenItem);
    groupDetailMenu.addMenuItem(&groupDetailStatusItem);
    groupDetailMenu.addMenuItem(&groupJoinItem);
    groupDetailMenu.setParentMenu(&syncGroupsMenu);

    

    // Set up callbacks
    syncThisDeviceUIItem.addFunc(1, []()
                                 {
      requestSyncStatus();
      requestSyncModeStatus();
      updateThisDeviceDisplay(); });

    syncCurrentGroupUIItem.addFunc(1, []()
                                   {
      requestSyncGroupInfo();
      updateCurrentGroupDisplay(); });

    syncDevicesUIItem.addFunc(1, []()
                              {
      requestSyncDevices();
      updateDevicesDisplay(); });

    syncGroupsUIItem.addFunc(1, []()
                             {
      requestSyncGroups();
      updateGroupsDisplay(); });

    groupMembersUIItem.addFunc(1, []()
                               { updateGroupMembersDisplay(); });

    // Set up device selection callbacks
    for (int i = 0; i < 8; i++)
    {
      deviceItems[i].addFunc(1, [i]()
                             {
                               // This is simplified - would need device list management
                               showDeviceDetail(i + 1000); // Dummy device ID
                             });
    }

    // Set up group selection callbacks
    for (int i = 0; i < 4; i++)
    {
      groupItems[i].addFunc(1, [i]()
                            {
                              // This is simplified - would need group list management
                              showGroupDetail(i + 2000); // Dummy group ID
                            });
    }

    syncMgr = SyncManager::getInstance();
    syncModeIndex = static_cast<int>(syncMgr->getSyncMode());
    syncModeItem.setCurrentIndex(syncModeIndex);
    syncRefreshData();
  }

  // onExit function
  void syncScreenOnExit()
  {
    // Clean up allocated memory
  }

  // draw function
  void syncScreenDraw()
  {
    menu.draw();
  }

  // update function
  void syncScreenUpdate()
  {
    menu.update();

    // Auto-refresh sync data when sync menus are active
    if (millis() - lastSyncAutoRefresh > 2000)
    {
      lastSyncAutoRefresh = millis();
      // Check if any sync-related menu is currently active
      Menu *currentMenu = menu.getActiveSubmenu();
      bool syncMenuActive = (currentMenu == &menu);

      if (syncMenuActive)
      {
        syncRefreshData(false); // Don't show notification for auto-refresh
      }
    }
  }

  // Helper method implementations
  void syncRefreshData(bool showNotification)
  {
    requestSyncStatus();
    requestSyncDevices();
    requestSyncGroups();
    requestSyncGroupInfo();
    requestSyncModeStatus();

    if (showNotification)
    {
      display.showNotification("Refreshing...", 1000);
    }
  }

  void syncCreateGroup(uint32_t groupId)
  {
    if (syncMgr->getGroupId() != 0)
    {
      display.showNotification("Leave group first", 1500);
      return;
    }

    syncMgr->createGroup(groupId);
    display.showNotification("Creating group...", 1500);
  }

  void leaveSyncGroup()
  {
    if (syncMgr->getGroupId() != 0)
    {
      syncMgr->leaveGroup();
      display.showNotification("Leaving group...", 1500);
    }
    else
    {
      display.showNotification("Not in group", 1500);
    }
  }

  void joinSelectedGroup()
  {
    if (selectedGroupId != 0)
    {
      joinSyncGroup(selectedGroupId);
      display.showNotification("Joining group...", 1500);
    }
    else
    {
      display.showNotification("No group selected", 1500);
    }
  }

  void joinSyncGroup(uint32_t groupId)
  {
    if (syncMgr->getGroupId() != 0)
    {
      syncMgr->leaveGroup();
    }
    syncMgr->joinGroup(groupId);
  }

  void updateThisDeviceDisplay()
  {
    const GroupInfo &groupInfo = syncMgr->getGroupInfo();

    thisDeviceIdItem.setName("ID: " + String(syncMgr->getDeviceId(), HEX));

    if (groupInfo.groupId == 0)
    {
      thisDeviceGroupItem.setName("Group: None");
      thisDeviceStatusItem.setName("Status: Solo");
    }
    else
    {
      thisDeviceGroupItem.setName("Group: " + String(groupInfo.groupId, HEX));
      String statusText = syncMgr->isGroupMaster() ? "Master" : "Member";
      if (syncMgr->isTimeSynced())
      {
        statusText += " (Synced)";
      }
      thisDeviceStatusItem.setName("Status: " + statusText);
    }

    syncModeItem.setCurrentIndex(static_cast<int>(syncMgr->getSyncMode()));
  }

  void updateCurrentGroupDisplay()
  {
    const GroupInfo &groupInfo = syncMgr->getGroupInfo();

    if (groupInfo.groupId == 0)
    {
      currentGroupIdItem.setName("ID: None");
      currentGroupMasterItem.setName("Master: ---");
      currentGroupMembersItem.setName("Members: 0");
      currentGroupSyncItem.setName("Sync: ---");
      groupMembersUIItem.setHidden(true);
    }
    else
    {
      currentGroupIdItem.setName("ID: " + String(groupInfo.groupId, HEX));
      currentGroupMasterItem.setName("Master: " + String(groupInfo.masterDeviceId, HEX));
      currentGroupMembersItem.setName("Members: " + String(groupInfo.members.size()));

      String syncText = syncMgr->isTimeSynced() ? "OK" : "No";
      if (syncMgr->isTimeSynced() && syncMgr->getTimeOffset() != 0)
      {
        syncText += " (" + String(syncMgr->getTimeOffset()) + "ms)";
      }
      currentGroupSyncItem.setName("Sync: " + syncText);
      groupMembersUIItem.setHidden(groupInfo.members.size() == 0);
    }
  }

  void updateDevicesDisplay()
  {
    auto discoveredDevices = syncMgr->getDiscoveredDevices();

    // Update device items - only show populated ones
    int deviceIndex = 0;
    for (const auto &devicePair : discoveredDevices)
    {
      if (deviceIndex >= 8)
        break;

      const DiscoveredDevice &device = devicePair.second;
      String deviceText = String(device.deviceId, HEX);

      // Add status indicators
      uint32_t timeSince = millis() - device.lastSeen;
      deviceText += " - " + formatTimeDuration(timeSince);

      deviceItems[deviceIndex].setName(deviceText);
      deviceItems[deviceIndex].setHidden(false);
      deviceIndex++;
    }

    // Hide remaining items
    for (int i = deviceIndex; i < 8; i++)
    {
      deviceItems[i].setHidden(true);
    }
  }

  void updateGroupsDisplay()
  {
    auto discoveredGroups = syncMgr->getDiscoveredGroups();

    // Update group items - only show populated ones
    int groupIndex = 0;
    for (const auto &group : discoveredGroups)
    {
      if (groupIndex >= 4)
        break;

      String groupText = "Group " + String(group.groupId, HEX);

      if (group.groupId == syncMgr->getGroupId())
      {
        groupText += " (Current)";
      }
      else
      {
        groupText += " (Available)";
      }

      uint32_t timeSince = millis() - group.lastSeen;
      groupText += " - " + formatTimeDuration(timeSince);

      groupItems[groupIndex].setName(groupText);
      groupItems[groupIndex].setHidden(false);
      groupIndex++;
    }

    // Hide remaining items
    for (int i = groupIndex; i < 4; i++)
    {
      groupItems[i].setHidden(true);
    }
  }

  void updateGroupMembersDisplay()
  {
    // Simplified implementation
    display.showNotification("Group members view", 1000);
  }

  void showDeviceDetail(uint32_t deviceId)
  {
    selectedDeviceId = deviceId;
    deviceDetailIdItem.setName("ID: " + String(deviceId, HEX));
    deviceDetailMacItem.setName("MAC: ---");
    deviceDetailLastSeenItem.setName("Last: ---");
    deviceDetailStatusItem.setName("Status: Unknown");
    deviceDetailGroupItem.setName("Group: Unknown");
  }

  void showGroupDetail(uint32_t groupId)
  {
    selectedGroupId = groupId;
    groupDetailIdItem.setName("ID: " + String(groupId, HEX));
    groupDetailMasterItem.setName("Master: ---");
    groupDetailMacItem.setName("MAC: ---");
    groupDetailLastSeenItem.setName("Last: ---");
    groupDetailStatusItem.setName("Status: Available");
  }

  String formatMacAddress(const uint8_t *mac)
  {
    String result = "";
    for (int i = 0; i < 6; i++)
    {
      if (i > 0)
        result += ":";
      if (mac[i] < 16)
        result += "0";
      result += String(mac[i], HEX);
    }
    result.toUpperCase();
    return result;
  }

  String formatTimeDuration(uint32_t milliseconds)
  {
    if (milliseconds < 1000)
      return String(milliseconds) + "ms";
    else if (milliseconds < 60000)
      return String(milliseconds / 1000) + "s";
    else if (milliseconds < 3600000)
      return String(milliseconds / 60000) + "m";
    else
      return String(milliseconds / 3600000) + "h";
  }

  void requestSyncDevices()
  {
    // Request updated device list from SyncManager
    // The actual implementation would depend on how SyncManager exposes this
  }

  void requestSyncGroups()
  {
    // Request updated group list from SyncManager
  }

  void requestSyncGroupInfo()
  {
    // Request current group info from SyncManager
  }

  void requestSyncStatus()
  {
    // Request detailed status from SyncManager
  }

  void setSyncMode(SyncMode mode)
  {
    syncMgr->setSyncMode(mode);
    display.showNotification(String("Mode: ") + syncMgr->getSyncModeString(), 1500);
  }

  void requestSyncModeStatus()
  {
    // Current sync mode is always available from syncMgr->getSyncMode()
    // No need to cache it like the old auto-join/auto-create bools
  }

} // namespace SyncScreenNamespace

// Define the SyncScreen Screen2 instance
const Screen2 SyncScreen = {
    F("Sync Manager"),
    F("Sync Manager"),
    SyncScreenNamespace::syncScreenDraw,
    SyncScreenNamespace::syncScreenUpdate,
    SyncScreenNamespace::syncScreenOnEnter,
    SyncScreenNamespace::syncScreenOnExit};========
==== Screens/SyncScreen.h: ====
#pragma once

#include "config.h"
#include "IO/ScreenManager.h"

extern const Screen2 SyncScreen;========
==== Sequences/BothIndicatorsSequence.cpp: ====
#include "BothIndicatorsSequence.h"

BothIndicatorsSequence::BothIndicatorsSequence(int _flashes)
    : SequenceBase("BothIndicators-" + String(_flashes), 10000),
      requiredFlashes(_flashes),
      flashCounter(0),
      firstFlashTime(0),
      lastCombinedState(false),
      debounceTime(50),
      lastDebounceTime(0),
      accOnState(false),
      leftIndicatorState(false),
      rightIndicatorState(false)
{
}

bool BothIndicatorsSequence::update()
{
  unsigned long currentTime = millis();

  // Only process if ACC is off.
  if (!accOnState)
  {
    bool combinedState = (leftIndicatorState && rightIndicatorState);

    // Check for rising edge of combined state (with debounce).
    if (combinedState && !lastCombinedState &&
        (currentTime - lastDebounceTime >= debounceTime))
    {
      if (firstFlashTime == 0)
      {
        // record when we saw the first flash
        firstFlashTime = currentTime;
      }
      flashCounter++;
      start();
      lastDebounceTime = currentTime;
    }

    lastCombinedState = combinedState;

    // Check if we got the required number of flashes.
    if (flashCounter >= requiredFlashes)
    {
      return true;
    }
  }
  return false;
}

void BothIndicatorsSequence::VReset()
{
  flashCounter = 0;
  firstFlashTime = 0;
  lastCombinedState = false; 
  lastDebounceTime = millis();
}

void BothIndicatorsSequence::setInputs(bool accOnState, bool leftIndicatorState, bool rightIndicatorState)
{
  this->accOnState = accOnState;
  this->leftIndicatorState = leftIndicatorState;
  this->rightIndicatorState = rightIndicatorState;
}========
==== Sequences/BothIndicatorsSequence.h: ====
#pragma once
#include <Arduino.h>
#include "SequenceBase.h"

class BothIndicatorsSequence : public SequenceBase
{
public:
  BothIndicatorsSequence(int _flashes);

  // Call this in the main loop.
  // Assumes that accOnState, leftIndicatorState and rightIndicatorState are updated globals.
  // For example, you could update these variables from Application::handleNormalEffects().
  bool update() override;
  void VReset() override;

  void setInputs(bool accOnState, bool leftIndicatorState, bool rightIndicatorState);

private:
  int requiredFlashes;
  int flashCounter;
  unsigned long firstFlashTime;
  bool lastCombinedState;
  const unsigned long debounceTime; // in ms
  unsigned long lastDebounceTime;

  bool accOnState;
  bool leftIndicatorState;
  bool rightIndicatorState;
};
========
==== Sequences/BrakeTapSequence.cpp: ====
#include "BrakeTapSequence.h"

BrakeTapSequence::BrakeTapSequence(int desiredTapCount)
    : SequenceBase("BrakeTapSequence", 1000 * desiredTapCount),
      desiredTapCount(desiredTapCount),
      currentTapCount(0),
      interTapTimeout(500),
      lastTapTime(0),
      debounceTime(50),
      lastDebounceTime(0),
      brakeState(false),
      lastBrakeState(false)
{
}

void BrakeTapSequence::VReset()
{
  currentTapCount = 0;
  lastTapTime = 0;
  lastDebounceTime = millis();
  lastBrakeState = false;
}

void BrakeTapSequence::setInput(bool brakeState)
{
  // Update the input state from external sensor/logic.
  this->brakeState = brakeState;
}

bool BrakeTapSequence::update()
{
  unsigned long currentTime = millis();

  // Check for rising edge of the brake tap.
  bool risingEdge = (brakeState && !lastBrakeState &&
                     (currentTime - lastDebounceTime >= debounceTime));

  if (risingEdge)
  {
    // Increase the tap count.
    currentTapCount++;
    lastTapTime = currentTime;
    lastDebounceTime = currentTime;
    start();
  }

  // Save the current state for next call.
  lastBrakeState = brakeState;

  // If at least one tap has occurred, check if enough time has passed without a new tap.
  if (currentTapCount > 0)
  {
    if (currentTime - lastTapTime >= interTapTimeout)
    {
      // The inter-tap period has elapsed.
      if (currentTapCount == desiredTapCount)
      {
        // Correct number of taps detected.
        return true;
      }
      else
      {
        // The tap count does not match the desired count.
        reset();
      }
    }
  }

  return false;
}
========
==== Sequences/BrakeTapSequence.h: ====
#pragma once

#include <Arduino.h>
#include "SequenceBase.h"

class BrakeTapSequence : public SequenceBase {
public:
  // Constructor: takes the desired number of brake taps to trigger the sequence.
  // timeoutMs: time in milliseconds to wait after a tap to see if another tap comes.
  BrakeTapSequence(int desiredTapCount);

  // Called in the main loop.
  // Returns true when the full sequence is detected.
  bool update() override;

  // Resets the sequence tracking so it is ready for a new sequence.
  void VReset() override;

  // Update the current input state for the brake (e.g., using a digital read or
  // similar). This should be updated externally.
  void setInput(bool brakeState);

private:
  // Desired number of taps for this sequence.
  int desiredTapCount;

  // Current number of taps observed.
  int currentTapCount;

  // Timeout after a tap (in ms) to wait for another tap.
  const unsigned long interTapTimeout;

  // The time of the last detected tap.
  unsigned long lastTapTime;

  // Debounce time to avoid multiple triggers per tap.
  const unsigned long debounceTime;
  unsigned long lastDebounceTime;

  // Current input state.
  bool brakeState;

  // Previous input state (for rising edge detection).
  bool lastBrakeState;
};
========
==== Sequences/IndicatorFlickSequence.cpp: ====
#include "IndicatorFlickSequence.h"

IndicatorFlickSequence::IndicatorFlickSequence(IndicatorSide startSide)
    : SequenceBase("IndicatorFlickSequence" + String(startSide), 3000),
      currentIndex(0),
      firstFlashTime(0),
      debounceTime(50),
      lastDebounceTime(0),
      accOnState(false),
      leftIndicatorState(false),
      rightIndicatorState(false),
      lastLeftState(false),
      lastRightState(false),
      hazardStartTime(0)
{
  if (startSide == IndicatorSide::LEFT_SIDE)
  {
    expectedSequence[0] = IndicatorSide::LEFT_SIDE;
    expectedSequence[1] = IndicatorSide::RIGHT_SIDE;
    expectedSequence[2] = IndicatorSide::LEFT_SIDE;
    expectedSequence[3] = IndicatorSide::RIGHT_SIDE;
  }
  else
  {
    expectedSequence[0] = IndicatorSide::RIGHT_SIDE;
    expectedSequence[1] = IndicatorSide::LEFT_SIDE;
    expectedSequence[2] = IndicatorSide::RIGHT_SIDE;
    expectedSequence[3] = IndicatorSide::LEFT_SIDE;
  }
}

bool IndicatorFlickSequence::update()
{
  unsigned long currentTime = millis();

  // Process this sequence only when ACC is on.
  if (accOnState)
  {

    if (leftIndicatorState && rightIndicatorState)
    {
      if (hazardStartTime == 0)
      {
        // Start tracking the time since both indicators turned on.
        hazardStartTime = currentTime;
      }
      else if ((currentTime - hazardStartTime) >= 200)
      {
        reset();
        // Serial.println("IndicatorFlick-" + String(expectedSequence[0]) + " Both indicators are on for 200ms. Resetting sequence.");
        return false;
      }
    }
    else
    {
      // Reset hazard timer if either indicator is off.
      hazardStartTime = 0;
    }

    // Check for rising edge for left indicator.
    bool leftEdge = leftIndicatorState && !lastLeftState &&
                    ((currentTime - lastDebounceTime) >= debounceTime);
    // Check for rising edge for right indicator.
    bool rightEdge = rightIndicatorState && !lastRightState &&
                     ((currentTime - lastDebounceTime) >= debounceTime);

    // Determine which side is expected for the current step.
    IndicatorSide expected = expectedSequence[currentIndex];

    // If the expected side's rising edge is detected, advance the sequence.
    if (expected == LEFT_SIDE && leftEdge)
    {
      if (firstFlashTime == 0)
      {
        firstFlashTime = currentTime;
      }
      start();
      currentIndex++;
      lastDebounceTime = currentTime;
    }
    else if (expected == RIGHT_SIDE && rightEdge)
    {
      if (firstFlashTime == 0)
      {
        firstFlashTime = currentTime;
      }
      start();
      currentIndex++;
      lastDebounceTime = currentTime;
    }
    // If an indicator flash (rising edge) is detected but it does not match the expected side,
    // then reset the sequence.
    else if ((leftEdge || rightEdge) && !((expected == LEFT_SIDE && leftEdge) ||
                                          (expected == RIGHT_SIDE && rightEdge)))
    {
      reset();
    }

    // Save states for the next call.
    lastLeftState = leftIndicatorState;
    lastRightState = rightIndicatorState;

    // If the sequence is complete, return true.
    if (currentIndex >= SEQUENCE_LENGTH)
    {
      return true;
    }
  }
  else
  {
    // When ACC is off, reset the sequence.
    if(currentIndex > 0 || started)
    {
      reset();
    }
  }
  return false;
}

void IndicatorFlickSequence::VReset()
{
  currentIndex = 0;
  firstFlashTime = 0;
  // Reset debounce timer so that a new flash is counted correctly.
  lastDebounceTime = millis();
  lastLeftState = false;
  lastRightState = false;
}

void IndicatorFlickSequence::setInputs(bool accOnState,
                                       bool leftIndicatorState,
                                       bool rightIndicatorState)
{
  this->accOnState = accOnState;
  this->leftIndicatorState = leftIndicatorState;
  this->rightIndicatorState = rightIndicatorState;

  // Serial.print("ACC: ");
  // Serial.print(accOnState ? "ON " : "OFF");
  // Serial.print(" Left: ");
  // Serial.print(leftIndicatorState ? "ON " : "OFF");
  // Serial.print(" Right: ");
  // Serial.println(rightIndicatorState ? "ON " : "OFF");
}
========
==== Sequences/IndicatorFlickSequence.h: ====
#pragma once

#include <Arduino.h>
#include "SequenceBase.h"

enum IndicatorSide
{
  LEFT_SIDE,
  RIGHT_SIDE
};

class IndicatorFlickSequence : public SequenceBase
{
public:
  // Constructor: provide timeout (in ms) if needed.
  IndicatorFlickSequence(IndicatorSide startSide);

  // Called in the main loop.
  // Returns true when the full sequence is detected.
  bool update() override;

  // Resets the sequence tracking so it is ready for a new sequence.
  void VReset() override;

  // Update the current input state.
  // Assumes that accOnState is true (the sequence only works when ACC is on).
  // leftIndicatorState/rightIndicatorState should be updated externally.
  void setInputs(bool accOnState, bool leftIndicatorState, bool rightIndicatorState);

private:
  // The fixed expected sequence.
  static const int SEQUENCE_LENGTH = 4;
  IndicatorSide expectedSequence[SEQUENCE_LENGTH];

  int currentIndex;                 // which step we are expecting next
  unsigned long firstFlashTime;     // time when the first flash of the sequence was detected
  const unsigned long debounceTime; // in ms
  unsigned long lastDebounceTime;

  // Input states:
  bool accOnState;
  bool leftIndicatorState;
  bool rightIndicatorState;

  // For rising edge detection on each indicator:
  bool lastLeftState;
  bool lastRightState;

  // handle hazzards
  uint64_t hazardStartTime;
};
========
==== Sequences/SequenceBase.cpp: ====
#include "SequenceBase.h"

SequenceBase::SequenceBase(String _name, uint64_t _timeout)
    : name(_name),
      timeout(_timeout),
      active(false),
      started(false),
      startTime(0)
{
}

SequenceBase::~SequenceBase()
{
}

void SequenceBase::loop()
{
  if (!active)
  {
    started = false;
    startTime = 0;
    return;
  }

  if (update())
  {
    Serial.println("Sequence complete: " + name);
    if (callback)
    {
      callback();
    }
    reset();
  }
  else if (started && startTime != 0 && (millis() - startTime) > timeout)
  {
    reset();
    Serial.println("Sequence timeout: " + name);
  }
}

void SequenceBase::setCallback(SequenceCallback cb)
{
  callback = cb;
}

void SequenceBase::setTimeout(uint64_t _timeout)
{
  timeout = _timeout;
}

void SequenceBase::setActive(bool _active)
{
  active = _active;
  reset();

  if (active)
    Serial.println("Sequence activated: " + name);
  else
    Serial.println("Sequence deactivated: " + name);
}

bool SequenceBase::isActive()
{
  return active;
}

bool SequenceBase::isStarted()
{
  return started;
}

void SequenceBase::reset()
{
  started = false;
  startTime = 0;
  VReset();
  // Serial.println("Sequence reset: " + name);
}

void SequenceBase::VReset()
{
}

void SequenceBase::trigger()
{
  if (callback)
  {
    callback();
  }
}

bool SequenceBase::update()
{
  return false;
}

void SequenceBase::start()
{
  if (started)
    return;

  startTime = millis();
  started = true;

  Serial.println("Sequence started: " + name);
}========
==== Sequences/SequenceBase.h: ====
#pragma once
#include <Arduino.h>

// Callback type (can be a function pointer or std::function if available)
typedef std::function<void()> SequenceCallback;

class SequenceBase
{
public:
  SequenceBase(String _name, uint64_t _timeout);
  virtual ~SequenceBase();

  // Call this every loop; returns true when the sequence is complete.
  // When complete, the callback is called (if set) and the sequence resets.
  void loop();

  // Set the callback function to be called when the sequence completes.
  void setCallback(SequenceCallback cb);

  void setTimeout(uint64_t _timeout);

  // Set the sequence active state.
  void setActive(bool _active);
  bool isActive();

  bool isStarted();

  // Reset the sequence state.
  void reset();
  virtual void VReset() = 0;

  void trigger();

  // Update the sequence state.
  // Return true if the sequence is complete.
  virtual bool update() = 0;

protected:
  void start();

  SequenceCallback callback;
  String name;
  uint64_t timeout;
  bool active;
  uint64_t startTime;
  bool started;
};
========
==== SerialMenu.cpp: ====
/****************************************************
 * SerialMenu.cpp
 ****************************************************/

#include "SerialMenu.h"

#include <Arduino.h>

#include "freertos/FreeRTOS.h"
#include "freertos/task.h"

#include "SerialMenus/mainMenu.h"
#include "SerialMenus/provisioningMenu.h"
#include "config.h"

//------------------------------------------
// Global pointer to the currently active menu
//------------------------------------------
static SerialMenu *currentMenu = nullptr;

/****************************************************
 * initSerialMenu()
 * - Check if device is provisioned and set appropriate menu
 ****************************************************/
void initSerialMenu()
{
        setMenu(&mainMenu);
}

/****************************************************
 * setMenu()
 ****************************************************/
void setMenu(SerialMenu *newMenu)
{
    if (newMenu != nullptr)
    {
        currentMenu = newMenu;
        if (currentMenu->printMenu)
        {
            currentMenu->printMenu(*currentMenu);
        }
    }
}

/****************************************************
 * getMenu()
 ****************************************************/
SerialMenu *getMenu()
{
    return currentMenu;
}

/****************************************************
 * promptUserInput()
 * - Reusable function that prompts user for input with ">"
 * - Returns the complete input string when Enter is pressed
 * - Handles character echo and backspace
 * - Times out after specified milliseconds (0 = no timeout)
 ****************************************************/
String promptUserInput(const String &prompt, unsigned long timeoutMs)
{
    if (prompt.length() > 0)
    {
        Serial.println(prompt);
    }
    Serial.print("> ");

    String inputBuffer = "";
    unsigned long startTime = millis();

    while (true)
    {
        // Check timeout if specified
        if (timeoutMs > 0 && (millis() - startTime) > timeoutMs)
        {
            Serial.println();
            Serial.println(F("Input timeout."));
            return "";
        }

        if (Serial.available())
        {
            char c = Serial.read();

            // Handle Enter key (CR or LF)
            if (c == '\r' || c == '\n')
            {
                Serial.println(); // Add newline after Enter
                inputBuffer.trim();
                return inputBuffer;
            }
            // Handle Backspace (ASCII 8 or 127)
            else if (c == 8 || c == 127)
            {
                if (inputBuffer.length() > 0)
                {
                    inputBuffer.remove(inputBuffer.length() - 1);
                    // Echo backspace to terminal (backspace, space, backspace)
                    Serial.print("\b \b");
                }
            }
            // Handle printable characters
            else if (c >= 32 && c <= 126)
            {
                inputBuffer += c;
                Serial.print(c); // Echo character back to user
            }
            // Ignore other control characters
        }

        delay(10); // Small delay to prevent excessive CPU usage
    }
}

/****************************************************
 * processMenuInput()
 * - builds up command string character by character
 * - processes complete command when Enter is received
 ****************************************************/
void processMenuInput(const String &input)
{
    static String commandBuffer = "";

    // Process each character in the input
    for (int i = 0; i < input.length(); i++)
    {
        char c = input.charAt(i);

        // Handle Enter key (CR or LF)
        if (c == '\r' || c == '\n')
        {
            // Process the complete command
            if (commandBuffer.length() == 0)
            {
                // Empty command - reprint menu
                if (currentMenu && currentMenu->printMenu)
                {
                    Serial.println(); // Add newline after Enter
                    currentMenu->printMenu(*currentMenu);
                }
            }
            else
            {
                Serial.println(); // Add newline after Enter

                // Check special commands first
                if (handleSpecialCommand(commandBuffer))
                {
                    // Special command handled
                }
                else if (currentMenu && currentMenu->handleInput)
                {
                    // Let the active menu handle it
                    bool recognized = currentMenu->handleInput(*currentMenu, commandBuffer);
                    if (!recognized)
                    {
                        Serial.println("Unknown command.");
                        currentMenu->printMenu(*currentMenu);
                    }
                }
            }

            // Clear the command buffer for next command
            commandBuffer = "";
            Serial.print("> "); // Show prompt for next command
        }
        // Handle Backspace (ASCII 8 or 127)
        else if (c == 8 || c == 127)
        {
            if (commandBuffer.length() > 0)
            {
                commandBuffer.remove(commandBuffer.length() - 1);
                // Echo backspace to terminal (backspace, space, backspace)
                Serial.print("\b \b");
            }
        }
        // Handle printable characters
        else if (c >= 32 && c <= 126)
        {
            commandBuffer += c;
            Serial.print(c); // Echo character back to user
        }
        // Ignore other control characters
    }
}

/****************************************************
 * handleSpecialCommand()
 * - Implement your global commands here, e.g.,
 *   "caltouch", "initml", etc. Return true if handled,
 *   else false.
 ****************************************************/
bool handleSpecialCommand(const String &input)
{
    // // Emergency provisioning bypass (for debugging only)
    // if (input == F("provision:bypass"))
    // {
    //     Serial.println(F("[WARNING] Bypassing provisioning check - DEBUG MODE ONLY"));
    //     deviceInfo.provisioned = true;
    //     saveDeviceInfo();
    //     Serial.println(F("Device marked as provisioned. Restarting..."));
    //     delay(1000);
    //     restart();
    //     return true;
    // }


    // Show provisioning status from any menu
    if (input == F("provision:status"))
    {
        deviceInfo.print();
        return true;
    }

    // If not recognized
    return false;
}

/****************************************************
 * buildBreadcrumbString()
 * - Builds "Parent > Current" recursively
 ****************************************************/
String buildBreadcrumbString(const SerialMenu *menu)
{
    if (!menu)
        return "";
    if (menu->parent == nullptr)
    {
        // This is the root
        return menu->name;
    }
    else
    {
        return buildBreadcrumbString(menu->parent) + " > " + menu->name;
    }
}
========
==== SerialMenu.h: ====
/****************************************************
 * SerialMenu.h
 *
 * Declares the primary Menu struct (with name, parent,
 * function pointers) and the core functions for
 * managing the active menu.
 ****************************************************/

#pragma once
#include <Arduino.h>
#include <functional>
#include "config.h"

/****************************************************
 * SerialMenu struct
 *
 * - name: The displayed name of the menu
 * - parent: The parent menu (used for breadcrumbs)
 * - printMenu: pointer to a function that prints the menu
 * - handleInput: pointer to a function that processes
 *                user input. Returns `true` if the
 *                command is recognized, else `false`.
 ****************************************************/
struct SerialMenu
{
    String name;
    SerialMenu *parent;
    void (*printMenu)(const SerialMenu &menu);
    bool (*handleInput)(SerialMenu &menu, const String &input);
};

/****************************************************
 * initSerialMenu()
 * - Initialises the menu system (e.g. sets current menu
 *   to mainMenu). Call it once in setup, or from your
 *   serialTask, etc.
 ****************************************************/
void initSerialMenu();

/****************************************************
 * setMenu()
 * - Changes the currently active menu and immediately
 *   calls printMenu() for the new menu.
 ****************************************************/
void setMenu(SerialMenu *newMenu);

/****************************************************
 * getMenu()
 * - Returns the pointer to the currently active menu.
 ****************************************************/
SerialMenu *getMenu();

/****************************************************
 * promptUserInput()
 * - Reusable function that prompts user for input with ">"
 * - Returns the complete input string when Enter is pressed
 * - Handles character echo and backspace
 * - Times out after specified milliseconds (0 = no timeout)
 ****************************************************/
String promptUserInput(const String &prompt = "", unsigned long timeoutMs = 0);

/****************************************************
 * processMenuInput()
 * - If `input` is empty, reprint the current menu.
 * - Checks "global" or "special" commands by calling
 *   handleSpecialCommand().
 * - If not handled, calls currentMenu->handleInput().
 ****************************************************/
void processMenuInput(const String &input);

/****************************************************
 * handleSpecialCommand()
 * - Processes commands that work from any menu,
 *   e.g., "gohome". Returns true if handled, false
 *   otherwise.
 ****************************************************/
bool handleSpecialCommand(const String &input);

/****************************************************
 * buildBreadcrumbString()
 * - Recursively builds a string for the breadcrumb
 *   like "Main > System" or "Main".
 ****************************************************/
String buildBreadcrumbString(const SerialMenu *menu);
========
==== SerialMenus/hvInputMenu.cpp: ====
/****************************************************
 * hvInputMenu.cpp
 *
 * Implementation of the HV input status menu system.
 * This menu displays the status of all HV inputs in
 * both boolean and voltage format.
 ****************************************************/

#include "hvInputMenu.h"
#include "mainMenu.h"
#include "SerialMenu.h"
#include "config.h"
#include "Application.h"
#include <Arduino.h>

/****************************************************
 * hvInputMenu object
 ****************************************************/
SerialMenu hvInputMenu = {
    "HV Input Status",
    &mainMenu,
    printHVInputMenu,
    handleHVInputMenuInput};

/****************************************************
 * printHVInputMenu()
 ****************************************************/
void printHVInputMenu(const SerialMenu &menu)
{
  Serial.println(String(F("\nBreadcrumb: ")) + buildBreadcrumbString(&menu));
  Serial.println(F("╔══════════════════════════════════════════════════════════════╗"));
  Serial.println(F("║                    HV INPUT STATUS                          ║"));
  Serial.println(F("╚══════════════════════════════════════════════════════════════╝"));
  Serial.println();

  Application *app = Application::getInstance();
  if (!app)
  {
    Serial.println(F("Application not initialized - cannot read input status"));
    Serial.println(F("b) Back to Main Menu"));
    Serial.println(F("Press Enter to re-print this menu"));
    return;
  }

  // Get current status of all HV inputs
  Serial.println(F("Current HV Input Status:"));
  Serial.println(F("====================================="));

  Serial.println(F("Input 1 (ACC):"));
  Serial.print(F("  Digital State: "));
  Serial.println(app->accOnInput.get() ? "HIGH" : "LOW");
  Serial.print(F("  Voltage: "));
  Serial.print(app->accOnInput.getVoltage(), 2);
  Serial.println(F("V"));
  Serial.print(F("  Enabled: "));
  Serial.println(app->accOnInput.isEnabled() ? "YES" : "NO");
  Serial.println(F("  Override: "));
  Serial.println(app->accOnInput.isOverride() ? "YES" : "NO");
  Serial.println();

  Serial.println(F("Input 2 (Left Indicator):"));
  Serial.print(F("  Digital State: "));
  Serial.println(app->leftIndicatorInput.get() ? "HIGH" : "LOW");
  Serial.print(F("  Voltage: "));
  Serial.print(app->leftIndicatorInput.getVoltage(), 2);
  Serial.println(F("V"));
  Serial.print(F("  Enabled: "));
  Serial.println(app->leftIndicatorInput.isEnabled() ? "YES" : "NO");
  Serial.println(F("  Override: "));
  Serial.println(app->leftIndicatorInput.isOverride() ? "YES" : "NO");
  Serial.println();

  Serial.println(F("Input 3 (Right Indicator):"));
  Serial.print(F("  Digital State: "));
  Serial.println(app->rightIndicatorInput.get() ? "HIGH" : "LOW");
  Serial.print(F("  Voltage: "));
  Serial.print(app->rightIndicatorInput.getVoltage(), 2);
  Serial.println(F("V"));
  Serial.print(F("  Enabled: "));
  Serial.println(app->rightIndicatorInput.isEnabled() ? "YES" : "NO");
  Serial.println(F("  Override: "));
  Serial.println(app->rightIndicatorInput.isOverride() ? "YES" : "NO");
  Serial.println();

  Serial.println(F("Input 4 (Headlight):"));
  Serial.print(F("  Digital State: "));
  Serial.println(app->headlightInput.get() ? "HIGH" : "LOW");
  Serial.print(F("  Voltage: "));
  Serial.print(app->headlightInput.getVoltage(), 2);
  Serial.println(F("V"));
  Serial.print(F("  Enabled: "));
  Serial.println(app->headlightInput.isEnabled() ? "YES" : "NO");
  Serial.println(F("  Override: "));
  Serial.println(app->headlightInput.isOverride() ? "YES" : "NO");
  Serial.println();

  Serial.println(F("Input 5 (Brake):"));
  Serial.print(F("  Digital State: "));
  Serial.println(app->brakeInput.get() ? "HIGH" : "LOW");
  Serial.print(F("  Voltage: "));
  Serial.print(app->brakeInput.getVoltage(), 2);
  Serial.println(F("V"));
  Serial.print(F("  Enabled: "));
  Serial.println(app->brakeInput.isEnabled() ? "YES" : "NO");
  Serial.println(F("  Override: "));
  Serial.println(app->brakeInput.isOverride() ? "YES" : "NO");
  Serial.println();

  Serial.println(F("Input 6 (Reverse):"));
  Serial.print(F("  Digital State: "));
  Serial.println(app->reverseInput.get() ? "HIGH" : "LOW");
  Serial.print(F("  Voltage: "));
  Serial.print(app->reverseInput.getVoltage(), 2);
  Serial.println(F("V"));
  Serial.print(F("  Enabled: "));
  Serial.println(app->reverseInput.isEnabled() ? "YES" : "NO");
  Serial.println(F("  Override: "));
  Serial.println(app->reverseInput.isOverride() ? "YES" : "NO");
  Serial.println();

  Serial.println(F("Commands:"));
  Serial.println(F("r) Refresh status"));
  Serial.println(F("m) Monitor mode (continuous refresh)"));
  Serial.println(F("s) Stop monitor mode"));
  Serial.println(F("b) Back to Main Menu"));
  Serial.println(F("Press Enter to re-print this menu"));
}

/****************************************************
 * handleHVInputMenuInput()
 ****************************************************/
bool handleHVInputMenuInput(SerialMenu &menu, const String &input)
{
  if (input == F("r"))
  {
    // Refresh - just reprint the menu
    printHVInputMenu(menu);
    return true;
  }
  else if (input == F("m"))
  {
    // Monitor mode - continuously print status
    Serial.println(F("Entering monitor mode... Press 's' and Enter to stop"));
    Serial.println(F("Refreshing every 1 second:"));
    Serial.println();

    // Simple monitor loop
    unsigned long lastUpdate = 0;
    while (true)
    {
      // Check for stop command
      if (Serial.available())
      {
        String stopInput = Serial.readString();
        stopInput.trim();
        if (stopInput == F("s"))
        {
          Serial.println(F("Monitor mode stopped."));
          printHVInputMenu(menu);
          break;
        }
      }

      // Update display every 1000ms
      if (millis() - lastUpdate >= 1000)
      {
        lastUpdate = millis();

        Application *monitorApp = Application::getInstance();
        if (!monitorApp)
        {
          Serial.println(F("Application not available"));
          break;
        }

        Serial.println(F("HV Input Status Update:"));
        Serial.println("Time: " + String(millis() / 1000) + "s");


        Serial.print(F("ACC: "));
        Serial.print(monitorApp->accOnInput.get() ? F("HIGH") : F("LOW"));
        Serial.print(F(" ("));
        Serial.print(monitorApp->accOnInput.getVoltage(), 2);
        Serial.print(F("V) "));

        Serial.print(F("L.IND: "));
        Serial.print(monitorApp->leftIndicatorInput.get() ? F("HIGH") : F("LOW"));
        Serial.print(F(" ("));
        Serial.print(monitorApp->leftIndicatorInput.getVoltage(), 2);
        Serial.print(F("V) "));

        Serial.print(F("R.IND: "));
        Serial.print(monitorApp->rightIndicatorInput.get() ? F("HIGH") : F("LOW"));
        Serial.print(F(" ("));
        Serial.print(monitorApp->rightIndicatorInput.getVoltage(), 2);
        Serial.println(F("V)"));

        Serial.print(F("HEAD: "));
        Serial.print(monitorApp->headlightInput.get() ? F("HIGH") : F("LOW"));
        Serial.print(F(" ("));
        Serial.print(monitorApp->headlightInput.getVoltage(), 2);
        Serial.print(F("V) "));

        Serial.print(F("BRAKE: "));
        Serial.print(monitorApp->brakeInput.get() ? F("HIGH") : F("LOW"));
        Serial.print(F(" ("));
        Serial.print(monitorApp->brakeInput.getVoltage(), 2);
        Serial.print(F("V) "));

        Serial.print(F("REV: "));
        Serial.print(monitorApp->reverseInput.get() ? F("HIGH") : F("LOW"));
        Serial.print(F(" ("));
        Serial.print(monitorApp->reverseInput.getVoltage(), 2);
        Serial.println(F("V)"));
        Serial.println(F("--------------------------------"));
      }

      delay(50); // Small delay to prevent watchdog issues
    }
    return true;
  }
  else if (input == F("s"))
  {
    // Stop command - handled in monitor mode
    Serial.println(F("Not in monitor mode"));
    return true;
  }

  // If not recognized, return false so parent menu can handle "b" command
  return false;
}========
==== SerialMenus/hvInputMenu.h: ====
/****************************************************
 * hvInputMenu.h
 *
 * Declares the hvInputMenu object and its function
 * pointers for printing/handling input.
 ****************************************************/
#pragma once

#include "SerialMenu.h"

extern SerialMenu hvInputMenu;

void printHVInputMenu(const SerialMenu &menu);
bool handleHVInputMenuInput(SerialMenu &menu, const String &input);========
==== SerialMenus/ledConfigMenu.cpp: ====
/****************************************************
 * ledConfigMenu.cpp
 *
 * Implementation of the LED configuration menu system.
 * This menu allows configuration of LED strip parameters
 * including lengths, pins, enable states, and flip settings.
 ****************************************************/

#include "ledConfigMenu.h"
#include "mainMenu.h"
#include "SerialMenu.h"
#include "config.h"
#include <Arduino.h>

/****************************************************
 * ledConfigMenu object
 ****************************************************/
SerialMenu ledConfigMenu = {
    "LED Configuration",
    &mainMenu,
    printLEDConfigMenu,
    handleLEDConfigMenuInput};

/****************************************************
 * printLEDConfigMenu()
 ****************************************************/
void printLEDConfigMenu(const SerialMenu &menu)
{
  Serial.println(String(F("\nBreadcrumb: ")) + buildBreadcrumbString(&menu));
  Serial.println(F("╔══════════════════════════════════════════════════════════════╗"));
  Serial.println(F("║                    LED STRIP CONFIGURATION                  ║"));
  Serial.println(F("╚══════════════════════════════════════════════════════════════╝"));
  Serial.println();

  // Show current LED configuration
  ledConfig.print();

  Serial.println(F("=== LED CONFIGURATION MENU ==="));
  Serial.println(F("1) Show Current Configuration"));
  Serial.println(F("2) Set Headlight LED Count"));
  Serial.println(F("3) Toggle Headlight Enable/Disable"));
  Serial.println(F("4) Toggle Headlight Flip"));
  Serial.println(F("5) Set Taillight LED Count"));
  Serial.println(F("6) Toggle Taillight Enable/Disable"));
  Serial.println(F("7) Toggle Taillight Flip"));
  Serial.println(F("8) Set Underglow LED Count"));
  Serial.println(F("9) Toggle Underglow Enable/Disable"));
  Serial.println(F("10) Toggle Underglow Flip"));
  Serial.println(F("11) Set Interior LED Count"));
  Serial.println(F("12) Toggle Interior Enable/Disable"));
  Serial.println(F("13) Toggle Interior Flip"));
  Serial.println(F("14) Set All Strip Lengths"));
  Serial.println(F("15) Enable/Disable All Strips"));
  Serial.println(F("16) Reset to Defaults"));
  Serial.println(F("17) Save Configuration"));
  Serial.println(F("s) Show Configuration"));
  Serial.println(F("b) Back to Main Menu"));
  Serial.println(F("Press Enter to re-print this menu"));
  Serial.println();
}

/****************************************************
 * handleLEDConfigMenuInput()
 ****************************************************/
bool handleLEDConfigMenuInput(SerialMenu &menu, const String &input)
{
  if (input == F("1") || input == F("s"))
  {
    showLEDConfig();
    return true;
  }
  else if (input == F("2"))
  {
    // Set Headlight LED Count
    configureStripLength("Headlight", &ledConfig.headlightLedCount);
    return true;
  }
  else if (input == F("3"))
  {
    // Toggle Headlight Enable/Disable
    toggleStripEnabled("Headlight", &ledConfig.headlightsEnabled);
    return true;
  }
  else if (input == F("4"))
  {
    // Toggle Headlight Flip
    toggleStripFlipped("Headlight", &ledConfig.headlightFlipped);
    return true;
  }
  else if (input == F("5"))
  {
    // Set Taillight LED Count
    configureStripLength("Taillight", &ledConfig.taillightLedCount);
    return true;
  }
  else if (input == F("6"))
  {
    // Toggle Taillight Enable/Disable
    toggleStripEnabled("Taillight", &ledConfig.taillightsEnabled);
    return true;
  }
  else if (input == F("7"))
  {
    // Toggle Taillight Flip
    toggleStripFlipped("Taillight", &ledConfig.taillightFlipped);
    return true;
  }
  else if (input == F("8"))
  {
    // Set Underglow LED Count
    configureStripLength("Underglow", &ledConfig.underglowLedCount);
    return true;
  }
  else if (input == F("9"))
  {
    // Toggle Underglow Enable/Disable
    toggleStripEnabled("Underglow", &ledConfig.underglowEnabled);
    return true;
  }
  else if (input == F("10"))
  {
    // Toggle Underglow Flip
    toggleStripFlipped("Underglow", &ledConfig.underglowFlipped);
    return true;
  }
  else if (input == F("11"))
  {
    // Set Interior LED Count
    configureStripLength("Interior", &ledConfig.interiorLedCount);
    return true;
  }
  else if (input == F("12"))
  {
    // Toggle Interior Enable/Disable
    toggleStripEnabled("Interior", &ledConfig.interiorEnabled);
    return true;
  }
  else if (input == F("13"))
  {
    // Toggle Interior Flip
    toggleStripFlipped("Interior", &ledConfig.interiorFlipped);
    return true;
  }
  else if (input == F("14"))
  {
    // Set all strip lengths
    String lengthStr = promptUserInput(F("Enter LED count for all strips (1-1000):"), 15000);
    if (lengthStr.length() > 0)
    {
      uint16_t length = lengthStr.toInt();
      if (length > 0 && length <= 1000)
      {
        ledConfig.headlightLedCount = length;
        ledConfig.taillightLedCount = length;
        ledConfig.underglowLedCount = length;
        ledConfig.interiorLedCount = length;
        Serial.println("All strip lengths set to " + String(length));
        saveLEDConfig();
      }
      else
      {
        Serial.println(F("Invalid length. Must be between 1 and 1000."));
      }
    }
    return true;
  }
  else if (input == F("15"))
  {
    // Enable/Disable all strips
    Serial.println(F("1) Enable All Strips"));
    Serial.println(F("2) Disable All Strips"));
    String choice = promptUserInput(F("Enter choice:"), 10000);

    if (choice == F("1"))
    {
      ledConfig.headlightsEnabled = true;
      ledConfig.taillightsEnabled = true;
      ledConfig.underglowEnabled = true;
      ledConfig.interiorEnabled = true;
      Serial.println(F("All strips enabled"));
      saveLEDConfig();
    }
    else if (choice == F("2"))
    {
      ledConfig.headlightsEnabled = false;
      ledConfig.taillightsEnabled = false;
      ledConfig.underglowEnabled = false;
      ledConfig.interiorEnabled = false;
      Serial.println(F("All strips disabled"));
      saveLEDConfig();
    }
    return true;
  }
  else if (input == F("16"))
  {
    // Reset to defaults
    Serial.println(F("WARNING: This will reset all LED configuration to defaults!"));
    String confirm = promptUserInput(F("Type 'RESET' to confirm:"), 15000);

    if (confirm == F("RESET"))
    {
      ledConfig = LEDConfig(); // Reset to default values
      saveLEDConfig();
      Serial.println(F("LED configuration reset to defaults"));
    }
    else
    {
      Serial.println(F("Reset cancelled"));
    }
    return true;
  }
  else if (input == F("17"))
  {
    saveLEDConfig();
    Serial.println(F("LED configuration saved!"));
    return true;
  }
  else if (input == F("b"))
  {
    setMenu(&mainMenu);
    return true;
  }

  return false;
}

/****************************************************
 * Helper functions
 ****************************************************/
void showLEDConfig()
{
  Serial.println();
  ledConfig.print();
}

void configureStripLength(const String &stripName, uint16_t *lengthPtr)
{
  String lengthStr = promptUserInput("Enter LED count for " + stripName + " (1-1000):", 15000);

  if (lengthStr.length() > 0)
  {
    uint16_t length = lengthStr.toInt();
    if (length > 0 && length <= 1000)
    {
      *lengthPtr = length;
      Serial.println(stripName + F(" LED count set to ") + String(length));
      saveLEDConfig();
    }
    else
    {
      Serial.println(F("Invalid length. Must be between 1 and 1000."));
    }
  }
}

void configureStripPin(const String &stripName, uint8_t *pinPtr)
{
  String pinStr = promptUserInput("Enter pin number for " + stripName + " (0-50):", 15000);

  if (pinStr.length() > 0)
  {
    uint8_t pin = pinStr.toInt();
    if (pin <= 50)
    {
      *pinPtr = pin;
      Serial.println(stripName + F(" pin set to ") + String(pin));
      saveLEDConfig();
    }
    else
    {
      Serial.println(F("Invalid pin. Must be between 0 and 50."));
    }
  }
}

void toggleStripEnabled(const String &stripName, bool *enabledPtr)
{
  *enabledPtr = !(*enabledPtr);
  Serial.println(stripName + F(" ") + (*enabledPtr ? F("ENABLED") : F("DISABLED")));
  saveLEDConfig();
}

void toggleStripFlipped(const String &stripName, bool *flippedPtr)
{
  *flippedPtr = !(*flippedPtr);
  Serial.println(stripName + F(" flip setting: ") + (*flippedPtr ? F("FLIPPED") : F("NORMAL")));
  saveLEDConfig();
}========
==== SerialMenus/ledConfigMenu.h: ====
/****************************************************
 * ledConfigMenu.h
 *
 * Declares the ledConfigMenu object and its
 * functions for managing LED strip configuration
 * through the serial menu system.
 ****************************************************/

#pragma once
#include "SerialMenu.h"

// Declare the ledConfigMenu object
extern SerialMenu ledConfigMenu;

// Function prototypes
void printLEDConfigMenu(const SerialMenu &menu);
bool handleLEDConfigMenuInput(SerialMenu &menu, const String &input);

// Helper functions for LED configuration
void showLEDConfig();
void configureStripLength(const String &stripName, uint16_t *lengthPtr);
// void configureStripPin(const String &stripName, uint8_t *pinPtr);
void toggleStripEnabled(const String &stripName, bool *enabledPtr);
void toggleStripFlipped(const String &stripName, bool *flippedPtr);========
==== SerialMenus/mainMenu.cpp: ====
/****************************************************LOW
 * mainMenu.cpp
 *
 * Defines the mainMenu object, providing the
 * function pointers to printMainMenu and
 * handleMainMenuInput.
 *
 * Contains the actual code for those two functions.
 ****************************************************/

#include "mainMenu.h"

#include "SerialMenu.h"
#include <Arduino.h> // for Serial, String, etc.

#include "systemMenu.h"
#include "syncMenu.h"
#include "provisioningMenu.h"
#include "ledConfigMenu.h"
#include "hvInputMenu.h"
#include "IO/TimeProfiler.h"
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>

/****************************************************
 * mainMenu object
 * - name: "Main"
 * - parent: nullptr (this is the root menu)
 * - printMenu: printMainMenu
 * - handleInput: handleMainMenuInput
 ****************************************************/
SerialMenu mainMenu = {
    "Main",
    nullptr,
    printMainMenu,
    handleMainMenuInput};

void printMainMenu(const SerialMenu &menu)
{
    String breadcrumb = buildBreadcrumbString(&menu);
    Serial.println(String(F("\nBreadcrumb: ")) + breadcrumb);
    Serial.println(F("=== MAIN MENU ==="));
    Serial.println(F("1) System Menu"));
    Serial.println(F("2) Sync Manager"));
    Serial.println(F("3) Device Provisioning"));
    Serial.println(F("4) LED Configuration"));
    Serial.println(F("5) HV Input Status"));
    Serial.println(F("6) Time Profiler"));
    Serial.println(F("r) Reboot"));
    Serial.println(F("Press Enter to re-print this menu"));
}

bool handleMainMenuInput(SerialMenu &menu, const String &input)
{
    if (input == F("1"))
    {
        setMenu(&systemMenu);
        return true;
    }
    else if (input == F("2"))
    {
        setMenu(&syncMenu);
        return true;
    }
    else if (input == F("3"))
    {
        setMenu(&provisioningMenu);
        return true;
    }
    else if (input == F("4"))
    {
        setMenu(&ledConfigMenu);
        return true;
    }
    else if (input == F("5"))
    {
        setMenu(&hvInputMenu);
        return true;
    }
    else if (input == F("6"))
    {
        timeProfiler.printAll();
        return true;
    }

    else if (input == F("r"))
    {
        Serial.println(F("Rebooting..."));
        restart();
        return true;
    }

    // If not recognized
    return false;
}
========
==== SerialMenus/mainMenu.h: ====
/****************************************************
 * mainMenu.h
 *
 * Declares the "mainMenu" object and the
 * functions that implement its printMenu and
 * handleInput logic.
 ****************************************************/

#pragma once
#include "SerialMenu.h" // needed for struct Menu

// Declare the mainMenu instance
extern SerialMenu mainMenu;

// Declare function prototypes for the main menu
void printMainMenu(const SerialMenu &menu);
bool handleMainMenuInput(SerialMenu &menu, const String &input);

========
==== SerialMenus/provisioningMenu.cpp: ====
/****************************************************
 * provisioningMenu.cpp
 *
 * Implementation of the provisioning menu system.
 * This menu allows configuration of device parameters
 * before normal operation is enabled.
 ****************************************************/

#include "provisioningMenu.h"
#include "config.h"
#include "SerialMenu.h"
#include <Arduino.h>
#include "SerialMenus/mainMenu.h"

/****************************************************
 * provisioningMenu object
 ****************************************************/
SerialMenu provisioningMenu = {
    "Provisioning",
    nullptr,
    printProvisioningMenu,
    handleProvisioningMenuInput};

/****************************************************
 * printProvisioningMenu()
 ****************************************************/
void printProvisioningMenu(const SerialMenu &menu)
{
  Serial.println();
  Serial.println(F("╔══════════════════════════════════════════════════════════════╗"));
  Serial.println(F("║                      DEVICE PROVISIONING                    ║"));
  Serial.println(F("╠══════════════════════════════════════════════════════════════╣"));

  Serial.println(F("║  This device requires provisioning before it can be used.   ║"));
  Serial.println(F("║  Please configure the device parameters below.              ║"));

  Serial.println(F("╚══════════════════════════════════════════════════════════════╝"));
  Serial.println();

  Serial.println(F("=== PROVISIONING MENU ==="));
  Serial.println(F("1) Show Current Status"));
  Serial.println(F("2) Set Serial Number"));
  Serial.println(F("3) Set Hardware Version"));
  Serial.println(F("4) Toggle Debug Mode"));
  Serial.println(F("5) Toggle OLED Display"));

  Serial.println(F("6) Complete Provisioning"));

  Serial.println(F("9) Factory Reset"));
  Serial.println(F("h) Help"));

  Serial.println(F("b) Back to Main Menu"));

  Serial.println(F("Press Enter to re-print this menu"));
  Serial.println();
}

/****************************************************
 * handleProvisioningMenuInput()
 ****************************************************/
bool handleProvisioningMenuInput(SerialMenu &menu, const String &input)
{
  if (input == F("1"))
  {
    showProvisioningStatus();
    return true;
  }
  else if (input == F("2"))
  {
    String serialStr = promptUserInput(F("Enter Serial Number (1-4294967295):"), 30000);

    if (serialStr.length() > 0)
    {
      uint32_t serialNum = serialStr.toInt();

      if (serialNum > 0)
      {
        setSerialNumber(serialNum);
        Serial.println(F("Serial number set successfully!"));
      }
      else
      {
        Serial.println(F("Invalid serial number. Must be greater than 0."));
      }
    }
    return true;
  }
  else if (input == F("3"))
  {
    String versionStr = promptUserInput(F("Enter Hardware Version (1-65535):"), 30000);

    if (versionStr.length() > 0)
    {
      uint16_t version = versionStr.toInt();

      if (version > 0)
      {
        setHardwareVersion(version);
        Serial.println(F("Hardware version set successfully!"));
      }
      else
      {
        Serial.println(F("Invalid hardware version. Must be greater than 0."));
      }
    }
    return true;
  }
  else if (input == F("4"))
  {
    deviceInfo.debugEnabled = !deviceInfo.debugEnabled;
    enableDebugMode(deviceInfo.debugEnabled);
    Serial.println(String(F("Debug mode ")) + (deviceInfo.debugEnabled ? "ENABLED" : "DISABLED"));
    return true;
  }
  else if (input == F("5"))
  {
    deviceInfo.oledEnabled = !deviceInfo.oledEnabled;
    saveDeviceInfo();
    Serial.println(String(F("OLED display ")) + (deviceInfo.oledEnabled ? "ENABLED" : "DISABLED"));
    Serial.println(F("Note: Restart required for change to take effect"));
    return true;
  }
  else if (input == F("6"))
  {

    // Complete provisioning
    if (deviceInfo.serialNumber == 0 || deviceInfo.hardwareVersion == 0)
    {
      Serial.println(F("ERROR: Cannot complete provisioning!"));
      Serial.println(F("Serial number and hardware version must be set first."));
      return true;
    }

    String confirm = promptUserInput(F("Are you sure you want to complete provisioning? (y/N)"), 10000);
    confirm.toLowerCase();

    if (confirm.length() > 0 && (confirm == "y" || confirm == "yes"))
    {
      completeProvisioning();
      Serial.println(F("Device provisioning completed! Restarting..."));
      delay(2000);
      restart();
    }
    else
    {
      Serial.println(F("Provisioning cancelled."));
    }

    return true;
  }
  else if (input == F("9"))
  {
    Serial.println(F("WARNING: This will erase all device configuration!"));
    String confirm = promptUserInput(F("Type 'FACTORY RESET' to confirm:"), 30000);

    if (confirm.length() > 0 && confirm == "FACTORY RESET")
    {
      factoryReset();
      Serial.println(F("Factory reset completed! Restarting..."));
      delay(2000);
      restart();
    }
    else
    {
      Serial.println(F("Incorrect confirmation. Factory reset cancelled."));
    }
    return true;
  }
  else if (input == F("h"))
  {
    Serial.println();
    Serial.println(F("=== PROVISIONING HELP ==="));
    Serial.println(F("This device must be provisioned before normal operation."));
    Serial.println(F("Required steps:"));
    Serial.println(F("1. Set a unique serial number for this device"));
    Serial.println(F("2. Set the hardware version"));
    Serial.println(F("3. Complete provisioning to enable normal operation"));
    Serial.println();
    Serial.println(F("Optional:"));
    Serial.println(F("- Enable debug mode for detailed logging"));
    Serial.println(F("- Enable/disable OLED display (requires restart)"));
    Serial.println();
    Serial.println(F("The device MAC address is automatically set and cannot be changed."));
    Serial.println();
    return true;
  }
  else if (input == F("b"))
  {
    Serial.println(F("Returning to main menu..."));
    setMenu(&mainMenu);
    return true;
  }

  // Not recognized
  return false;
}

/****************************************************
 * Provisioning functions
 ****************************************************/
void startProvisioning()
{
  Serial.println(F("[INFO] [PROVISIONING] Starting provisioning mode"));
}

void setSerialNumber(uint32_t serialNumber)
{
  deviceInfo.serialNumber = serialNumber;
  saveDeviceInfo();
  Serial.println(String(F("[INFO] [PROVISIONING] Serial number set to: ")) + String(serialNumber));
}

void setHardwareVersion(uint16_t hardwareVersion)
{
  deviceInfo.hardwareVersion = hardwareVersion;
  saveDeviceInfo();
  Serial.println(String(F("[INFO] [PROVISIONING] Hardware version set to: ")) + String(hardwareVersion));
}

void enableDebugMode(bool enabled)
{
  deviceInfo.debugEnabled = enabled;
  saveDeviceInfo();
  Serial.println(String(F("[INFO] [PROVISIONING] Debug mode ")) + (enabled ? "enabled" : "disabled"));
}

void completeProvisioning()
{
  saveDeviceInfo();
  Serial.println(F("[INFO] [PROVISIONING] Device provisioning completed"));
}

void showProvisioningStatus()
{
  Serial.println();
  Serial.println(F("=== DEVICE STATUS ==="));
  Serial.println(String(F("Serial Number: ")) + (deviceInfo.serialNumber == 0 ? "NOT SET" : String(deviceInfo.serialNumber)));
  Serial.println(String(F("Hardware Version: ")) + (deviceInfo.hardwareVersion == 0 ? "NOT SET" : String(deviceInfo.hardwareVersion)));
  Serial.println(String(F("Debug Mode: ")) + (deviceInfo.debugEnabled ? "ENABLED" : "DISABLED"));
  Serial.println(String(F("OLED Display: ")) + (deviceInfo.oledEnabled ? "ENABLED" : "DISABLED"));
  Serial.printf("MAC Address: %02X:%02X:%02X:%02X:%02X:%02X\n",
                deviceInfo.macAddress[0], deviceInfo.macAddress[1], deviceInfo.macAddress[2],
                deviceInfo.macAddress[3], deviceInfo.macAddress[4], deviceInfo.macAddress[5]);
  Serial.println();

  Serial.println(F("STATUS: Device requires provisioning"));
  if (deviceInfo.serialNumber == 0)
  {
    Serial.println(F("  - Serial number must be set"));
  }
  if (deviceInfo.hardwareVersion == 0)
  {
    Serial.println(F("  - Hardware version must be set"));
  }

  Serial.println();
}

void factoryReset()
{
  Serial.println(F("[INFO] [PROVISIONING] Performing factory reset"));

  // Clear all preferences
  preferences.clear();

  // Reset device info to defaults
  deviceInfo = DeviceInfo();

  // Set MAC address from WiFi
  uint8_t baseMac[6];
  esp_read_mac(baseMac, ESP_MAC_WIFI_STA);
  memcpy(deviceInfo.macAddress, baseMac, 6);

  saveDeviceInfo();
  Serial.println(F("[INFO] [PROVISIONING] Factory reset completed"));
}========
==== SerialMenus/provisioningMenu.h: ====
/****************************************************
 * provisioningMenu.h
 *
 * Defines the provisioning menu system that allows
 * device configuration before the main application
 * functionality is enabled.
 ****************************************************/

#pragma once
#include "SerialMenu.h"

extern SerialMenu provisioningMenu;

void printProvisioningMenu(const SerialMenu &menu);
bool handleProvisioningMenuInput(SerialMenu &menu, const String &input);

// Provisioning functions
void startProvisioning();
void setSerialNumber(uint32_t serialNumber);
void setHardwareVersion(uint16_t hardwareVersion);
void enableDebugMode(bool enabled);
void completeProvisioning();
void showProvisioningStatus();
void factoryReset();========
==== SerialMenus/syncMenu.cpp: ====
/****************************************************
 * syncMenu.cpp
 *
 * Defines the syncMenu object and implements its
 * printMenu/handleInput for managing SyncManager.
 ****************************************************/

#include "syncMenu.h"
#include "mainMenu.h"
#include "SerialMenu.h"
#include "Sync/SyncManager.h"
#include <Arduino.h>
#include <map>
#include <vector>

// Store available groups for numbered selection
static std::vector<uint32_t> availableGroups;

SerialMenu syncMenu = {
    "Sync Manager",
    &mainMenu,
    printSyncMenu,
    handleSyncMenuInput};

void printSyncMenu(const SerialMenu &menu)
{
  Serial.println(String(F("\nBreadcrumb: ")) + buildBreadcrumbString(&menu));
  Serial.println(F("=== SYNC MANAGER ==="));

  SyncManager *syncMgr = SyncManager::getInstance();

  // Show current status
  Serial.println(F("Current Status:"));
  if (syncMgr->getGroupId() != 0)
  {
    Serial.println(String(F("  Group: 0x")) + String(syncMgr->getGroupId(), HEX));
    Serial.println(String(F("  Role: ")) + (syncMgr->isGroupMaster() ? "MASTER" : "SLAVE"));

    const GroupInfo &groupInfo = syncMgr->getGroupInfo();
    Serial.println(String(F("  Devices: ")) + String(groupInfo.members.size()));
    Serial.println(String(F("  Time Synced: ")) + (syncMgr->isTimeSynced() ? "YES" : "NO"));
  }
  else
  {
    Serial.println(F("  No group joined"));
  }

  Serial.println(String(F("  Sync Mode: ")) + syncMgr->getSyncModeString());

  Serial.println();
  Serial.println(F("Actions:"));
  Serial.println(F("1) Show detailed status"));
  Serial.println(F("2) Show available groups"));
  Serial.println(F("3) Create new group"));
  Serial.println(F("4) Join group (by number)"));
  Serial.println(F("5) Leave current group"));
  Serial.println(F("6) List known devices"));
  Serial.println(F("7) Set sync mode"));
  Serial.println(F("8) Refresh group list"));
  Serial.println(F("9) Print device info"));
  Serial.println(F("10) Print group info"));
  Serial.println(F("11) Print sync mode info"));
  Serial.println(F("b) Back to main menu"));
  Serial.println(F("Press Enter to refresh this menu"));
}

bool handleSyncMenuInput(SerialMenu &menu, const String &input)
{
  SyncManager *syncMgr = SyncManager::getInstance();

  if (input == F("1"))
  {
    showSyncStatus();
    return true;
  }
  else if (input == F("2"))
  {
    showAvailableGroups();
    return true;
  }
  else if (input == F("3"))
  {
    createNewGroup();
    return true;
  }
  else if (input == F("4"))
  {
    if (availableGroups.empty())
    {
      Serial.println(F("No groups available. Use option 2 to scan for groups first."));
    }
    else
    {
      Serial.println("Enter group number (1-" + String(availableGroups.size()) + "):");
      Serial.print(F("> "));

      // Wait for input
      while (!Serial.available())
      {
        delay(10);
      }
      String groupInput = Serial.readStringUntil('\n');
      groupInput.trim();

      int groupNum = groupInput.toInt();
      if (groupNum >= 1 && groupNum <= (int)availableGroups.size())
      {
        joinGroupByNumber(groupNum - 1); // Convert to 0-based index
      }
      else
      {
        Serial.println(F("Invalid group number."));
      }
    }
    return true;
  }
  else if (input == F("5"))
  {
    if (syncMgr->getGroupId() != 0)
    {
      Serial.println(F("Leaving current group..."));
      syncMgr->leaveGroup();
      Serial.println(F("Left group successfully."));
    }
    else
    {
      Serial.println(F("Not currently in a group."));
    }
    return true;
  }
  else if (input == F("6"))
  {
    listKnownDevices();
    return true;
  }
  else if (input == F("7"))
  {
    setSyncMode();
    return true;
  }
  else if (input == F("8"))
  {
    Serial.println(F("Refreshing group list..."));
    showAvailableGroups();
    return true;
  }
  else if (input == F("9"))
  {
    syncMgr->printDeviceInfo();
    return true;
  }
  else if (input == F("10"))
  {
    syncMgr->printGroupInfo();
    return true;
  }
  else if (input == F("11"))
  {
    syncMgr->printSyncModeInfo();
    return true;
  }
  else if (input == F("b"))
  {
    setMenu(&mainMenu);
    return true;
  }

  return false;
}

void showSyncStatus()
{
  Serial.println(F("\n=== DETAILED SYNC STATUS ==="));

  SyncManager *syncMgr = SyncManager::getInstance();
  const GroupInfo &groupInfo = syncMgr->getGroupInfo();

  Serial.println(String(F("Device ID: 0x")) + String(syncMgr->getDeviceId(), HEX));
  Serial.println(String(F("Group ID: ")) + (groupInfo.groupId != 0 ? ("0x" + String(groupInfo.groupId, HEX)) : "None"));
  Serial.println(String(F("Role: ")) + (syncMgr->isGroupMaster() ? "MASTER" : "SLAVE"));
  Serial.println(String(F("Group Members: ")) + String(groupInfo.members.size()));
  Serial.println(String(F("Time Synced: ")) + (syncMgr->isTimeSynced() ? "YES" : "NO"));

  if (syncMgr->isTimeSynced())
  {
    Serial.println(String(F("Synced Time: ")) + String(syncMgr->getSyncedTime()));
    Serial.println(String(F("Time Offset: ")) + String(syncMgr->getTimeOffset()) + "ms");
  }

  if (groupInfo.groupId != 0)
  {
    Serial.println(String(F("Master Device: 0x")) + String(groupInfo.masterDeviceId, HEX));
  }

  Serial.println(String(F("Sync Mode: ")) + syncMgr->getSyncModeString());

  // Show discovered devices
  const auto &discoveredDevices = syncMgr->getDiscoveredDevices();
  Serial.println(String(F("Discovered Devices: ")) + String(discoveredDevices.size()));

  // Show discovered groups
  auto discoveredGroups = syncMgr->getDiscoveredGroups();
  Serial.println(String(F("Discovered Groups: ")) + String(discoveredGroups.size()));

  Serial.println(F("===========================\n"));

  // Print detailed information
  syncMgr->printDeviceInfo();
  syncMgr->printGroupInfo();
}

void showAvailableGroups()
{
  Serial.println(F("\n=== AVAILABLE GROUPS ==="));

  SyncManager *syncMgr = SyncManager::getInstance();
  std::vector<GroupAdvert> groups = syncMgr->getDiscoveredGroups();

  // Clear and rebuild available groups list
  availableGroups.clear();

  if (groups.empty())
  {
    Serial.println(F("No groups found."));
    Serial.println(F("Tip: Wait a few seconds for device discovery or create a new group."));
  }
  else
  {
    Serial.println(F("Found groups:"));
    int index = 1;

    for (const auto &group : groups)
    {
      availableGroups.push_back(group.groupId);

      Serial.println(String(F("  ")) + String(index) +
                     String(F(") Group 0x")) + String(group.groupId, HEX) +
                     String(F(" - Master: 0x")) + String(group.masterDeviceId, HEX) +
                     String(F(" (last seen ")) + String(millis() - group.lastSeen) + String(F("ms ago)")));
      index++;
    }

    Serial.println(F("\nUse option 4 to join a group by number."));
  }

  Serial.println(F("========================\n"));
}

void createNewGroup()
{
  Serial.println(F("\n=== CREATE NEW GROUP ==="));

  SyncManager *syncMgr = SyncManager::getInstance();

  if (syncMgr->getGroupId() != 0)
  {
    Serial.println(F("Warning: You are already in a group. Leave current group first? (y/n)"));
    Serial.print(F("> "));

    while (!Serial.available())
    {
      delay(10);
    }
    String confirm = Serial.readStringUntil('\n');
    confirm.trim();
    confirm.toLowerCase();

    if (confirm != "y" && confirm != "yes")
    {
      Serial.println(F("Group creation cancelled."));
      return;
    }

    syncMgr->leaveGroup();
    Serial.println(F("Left previous group."));
  }

  Serial.println(F("Enter group ID (hex, e.g. 12345678) or press Enter for random:"));
  Serial.print(F("> "));

  while (!Serial.available())
  {
    delay(10);
  }
  String groupInput = Serial.readStringUntil('\n');
  groupInput.trim();

  uint32_t groupId = 0;
  if (groupInput.length() > 0)
  {
    // Parse hex input
    groupId = strtoul(groupInput.c_str(), NULL, 16);
    if (groupId == 0)
    {
      Serial.println(F("Invalid hex input. Using random group ID."));
    }
  }

  syncMgr->createGroup(groupId);

  if (groupId == 0)
  {
    groupId = syncMgr->getGroupId();
  }

  Serial.println(String(F("Created group 0x")) + String(groupId, HEX));
  Serial.println(F("You are now the master of this group."));
  Serial.println(F("========================\n"));
}

void joinGroupByNumber(int groupNumber)
{
  if (groupNumber < 0 || groupNumber >= (int)availableGroups.size())
  {
    Serial.println(F("Invalid group number."));
    return;
  }

  uint32_t groupId = availableGroups[groupNumber];

  Serial.println(String(F("\n=== JOINING GROUP 0x")) + String(groupId, HEX) + F(" ==="));

  SyncManager *syncMgr = SyncManager::getInstance();

  if (syncMgr->getGroupId() != 0)
  {
    Serial.println(F("Leaving current group first..."));
    syncMgr->leaveGroup();
  }

  Serial.println(F("Joining group..."));
  syncMgr->joinGroup(groupId);

  Serial.println(String(F("Joined group 0x")) + String(groupId, HEX));
  Serial.println(F("Waiting for master election and time sync..."));
  Serial.println(F("==============================\n"));
}

void listKnownDevices()
{
  Serial.println(F("\n=== KNOWN DEVICES ==="));

  SyncManager *syncMgr = SyncManager::getInstance();
  const auto &devices = syncMgr->getDiscoveredDevices();

  if (devices.empty())
  {
    Serial.println(F("No devices discovered yet."));
    Serial.println(F("Wait a few seconds for device discovery."));
  }
  else
  {
    Serial.println(String(F("Found ")) + String(devices.size()) + F(" device(s):"));
    Serial.println();

    int index = 1;
    for (const auto &devicePair : devices)
    {
      const DiscoveredDevice &device = devicePair.second;

      Serial.println(String(F("Device ")) + String(index) + F(":"));
      Serial.println(String(F("  ID: 0x")) + String(device.deviceId, HEX));
      Serial.println(String(F("  Last Seen: ")) + String(millis() - device.lastSeen) + F("ms ago"));

      // Format MAC address
      String macStr = "";
      for (int j = 0; j < 6; j++)
      {
        if (device.mac[j] < 16)
          macStr += "0";
        macStr += String(device.mac[j], HEX);
        if (j < 5)
          macStr += ":";
      }
      macStr.toUpperCase();
      Serial.println(String(F("  MAC: ")) + macStr);
      Serial.println();
      index++;
    }
  }

  Serial.println(F("====================\n"));
}

void setSyncMode()
{
  Serial.println(F("\n=== SET SYNC MODE ==="));
  Serial.println(F("Choose sync mode:"));
  Serial.println(F("1) SOLO - No group interaction"));
  Serial.println(F("2) JOIN - Look for and join groups"));
  Serial.println(F("3) HOST - Create and host a group"));
  Serial.println(F("0) Cancel"));
  Serial.print(F("Enter choice (0-3): "));

  while (!Serial.available())
  {
    delay(10);
  }
  String choice = Serial.readStringUntil('\n');
  choice.trim();

  SyncManager *syncMgr = SyncManager::getInstance();

  if (choice == "1")
  {
    syncMgr->setSyncMode(SyncMode::SOLO);
    Serial.println(F("Sync mode set to SOLO"));
  }
  else if (choice == "2")
  {
    syncMgr->setSyncMode(SyncMode::JOIN);
    Serial.println(F("Sync mode set to JOIN"));
  }
  else if (choice == "3")
  {
    syncMgr->setSyncMode(SyncMode::HOST);
    Serial.println(F("Sync mode set to HOST"));
  }
  else if (choice == "0")
  {
    Serial.println(F("Mode change cancelled"));
  }
  else
  {
    Serial.println(F("Invalid choice"));
  }

  Serial.println(F("=====================\n"));
}========
==== SerialMenus/syncMenu.h: ====
/****************************************************
 * syncMenu.h
 *
 * Declares the syncMenu object and its associated
 * functions for managing the SyncManager through
 * the serial menu system.
 ****************************************************/

#pragma once
#include "SerialMenu.h"

// Declare the syncMenu object
extern SerialMenu syncMenu;

// Function prototypes
void printSyncMenu(const SerialMenu &menu);
bool handleSyncMenuInput(SerialMenu &menu, const String &input);

// Helper functions for sync management
void showSyncStatus();
void showAvailableGroups();
void createNewGroup();
void joinGroupByNumber(int groupNumber);
void listKnownDevices();
void setSyncMode();========
==== SerialMenus/systemMenu.cpp: ====
/****************************************************
 * systemMenu.cpp
 *
 * Defines the systemMenu object and implements its
 * printMenu/handleInput.
 ****************************************************/
#include "systemMenu.h"

// If you need references to mainMenu for going back:
#include "mainMenu.h"

// If you want to do setMenu, processMenuInput, etc.
#include "SerialMenu.h"

#include <WiFi.h> // If you're using WiFi.localIP, etc.

SerialMenu systemMenu = {
    F("System"),
    &mainMenu, // parent is mainMenu
    printSystemMenu,
    handleSystemMenuInput};

void printSystemMenu(const SerialMenu &menu)
{
    Serial.println(String(F("\nBreadcrumb: ")) + buildBreadcrumbString(&menu));
    Serial.println(F("=== SYSTEM MENU ==="));
    Serial.println(F("1) Get ID"));
    Serial.println(F("2) Get Version"));
    Serial.println(F("3) Get IP"));
    Serial.println(F("4) Get MAC"));
    Serial.println(F("5) Sysinfo"));
    Serial.println(F("b) Back"));
    Serial.println(F("Press Enter to re-print this menu"));
}

bool handleSystemMenuInput(SerialMenu &menu, const String &input)
{
    if (input == F("1"))
    {
        // example: getDeviceId()
        // (where getDeviceId() is from your code)
        Serial.println(1);
        return true;
    }
    else if (input == F("2"))
    {
        // e.g. updater.currentVersion
        Serial.println(2);
        return true;
    }
    else if (input == F("3"))
    {
        Serial.println(WiFi.localIP());
        return true;
    }
    else if (input == F("4"))
    {
        Serial.println(WiFi.macAddress());
        return true;
    }
    else if (input == F("5"))
    {
        // Sysinfo example
        Serial.println(F("System Info:"));
        Serial.println(String(F("Device ID: ")) + "1");
        Serial.println(String(F("IP Address: ")) + WiFi.localIP().toString());
        Serial.println(String(F("MAC Address: ")) + WiFi.macAddress());

        // show memory usage
        uint32_t usedHeap = ESP.getHeapSize() - ESP.getFreeHeap();
        uint32_t usedPsram = ESP.getPsramSize() - ESP.getFreePsram();

        Serial.println(String(F("Heap: ")) +
                       formatBytes(usedHeap) + String(F(" / ")) + formatBytes(ESP.getHeapSize()));
        Serial.println(String(F("PSRAM: ")) +
                       formatBytes(usedPsram) + String(F(" / ")) + formatBytes(ESP.getPsramSize()));
        return true;
    }
    else if (input == F("b"))
    {
        // go back to main menu
        setMenu(&mainMenu);
        return true;
    }

    // Not recognized
    return false;
}
========
==== SerialMenus/systemMenu.h: ====
/****************************************************
 * systemMenu.h
 *
 * Declares the systemMenu object and its function
 * pointers for printing/handling input.
 ****************************************************/
#pragma once

#include "SerialMenu.h"

extern SerialMenu systemMenu;

void printSystemMenu(const SerialMenu &menu);
bool handleSystemMenuInput(SerialMenu &menu, const String &input);

========
==== Sync/SyncManager.cpp: ====
// SyncManager.cpp
#include "SyncManager.h"
#include <WiFi.h>
#include <Arduino.h>
#include <string.h>
#include <stdio.h>
#include "IO/GPIO.h"
#include "IO/StatusLed.h"
#include "IO/TimeProfiler.h"
#include "Application.h"

SyncManager *SyncManager::getInstance()
{
  static SyncManager inst;
  return &inst;
}

SyncManager::SyncManager()
{
  ourDeviceId = generateDeviceId();
  // clear initial group
  currentGroup = {};
}

SyncManager::~SyncManager() {}

void SyncManager::begin()
{
  wireless.addOnReceiveFor(
      SYNC_MSG_TYPE,
      [this](fullPacket *fp)
      { handleSyncPacket(fp); });

  loadPreferences();
}

void SyncManager::loop()
{
  timeProfiler.start("syncManagerLoop", TimeUnit::MICROSECONDS);

  uint32_t now = millis();
  if (now - lastHeartbeat >= HEARTBEAT_INTERVAL)
  {
    sendHeartbeat();
    lastHeartbeat = now;
  }

  checkDiscoveryCleanup(now);
  checkGroupCleanup(now);
  checkMemberTimeout(now);

  if (currentGroup.groupId != 0)
  {
    if (currentGroup.isMaster)
    {
      if (now - lastGrpAnnounce >= GROUP_ANNOUNCE_INTERVAL)
      {
        sendGroupAnnounce();
        lastGrpAnnounce = now;
      }
      if (now - lastGrpInfo >= GROUP_INFO_INTERVAL)
      {
        sendGroupInfo();
        lastGrpInfo = now;
      }
      if (effectSyncEnabled && now - lastEffectSync >= EFFECT_SYNC_INTERVAL)
      {
        // currentEffectState.print();
        sendEffectState();
        lastEffectSync = now;
      }
    }
    else
    {
      if (now - lastTimeSync >= TIME_SYNC_INTERVAL)
      {
        requestTimeSync();
        lastTimeSync = now;
      }
    }
  }
  else
  {
    // Check join mode when not in a group
    if (syncMode == SyncMode::JOIN)
    {
      checkJoinMode(now);
    }
  }

  timeProfiler.stop("syncManagerLoop");
}

const std::map<std::string, DiscoveredDevice> &
SyncManager::getDiscoveredDevices() const
{
  return discoveredDevices;
}

std::vector<GroupAdvert> SyncManager::getDiscoveredGroups() const
{
  std::vector<GroupAdvert> out;
  for (auto &kv : discoveredGroups)
  {
    out.push_back(kv.second);
  }
  return out;
}

const GroupInfo &SyncManager::getGroupInfo() const
{
  return currentGroup;
}

bool SyncManager::isInGroup() const
{
  return currentGroup.groupId != 0;
}

bool SyncManager::isGroupMaster() const
{
  return currentGroup.isMaster;
}

uint32_t SyncManager::getGroupId() const
{
  return currentGroup.groupId;
}

uint32_t SyncManager::getDeviceId() const
{
  return ourDeviceId;
}

void SyncManager::createGroup(uint32_t groupId)
{
  if (groupId == 0)
    groupId = generateGroupId();
  currentGroup.groupId = groupId;
  currentGroup.masterDeviceId = ourDeviceId;
  currentGroup.isMaster = true;
  currentGroup.members.clear();

  // Masters are immediately time synced (they are the reference)
  timeSynced = true;
  timeOffset = 0;
  currentGroup.timeSynced = true;
  currentGroup.timeOffset = 0;

  // add self
  std::string ms = macToString(getOurMac());
  GroupMember gm;
  gm.deviceId = ourDeviceId;
  memcpy(gm.mac, getOurMac(), 6);
  currentGroup.members[ms] = gm;
  sendGroupAnnounce();
  sendGroupInfo();
  if (onGroupCreated)
    onGroupCreated(currentGroup);
}

void SyncManager::joinGroup(uint32_t groupId)
{
  if (currentGroup.groupId == groupId)
    return;
  // leave old
  leaveGroup();
  auto it = discoveredGroups.find(groupId);
  if (it == discoveredGroups.end())
    return;
  auto &adv = it->second;
  currentGroup.groupId = groupId;
  currentGroup.masterDeviceId = adv.masterDeviceId;
  currentGroup.isMaster = false;
  currentGroup.members.clear();

  // Reset sync state when joining a group (slaves need to sync)
  timeSynced = false;
  timeOffset = 0;
  currentGroup.timeSynced = false;
  currentGroup.timeOffset = 0;

  // add self
  std::string ms = macToString(getOurMac());
  GroupMember gm;
  gm.deviceId = ourDeviceId;
  memcpy(gm.mac, getOurMac(), 6);
  currentGroup.members[ms] = gm;
  // send join
  data_packet pkt;
  pkt.type = SYNC_MSG_TYPE;
  pkt.data[0] = SYNC_GROUP_JOIN;

  GroupJoinCmd joinCmd;
  joinCmd.groupId = groupId;
  joinCmd.deviceId = ourDeviceId;

  memcpy(&pkt.data[1], &joinCmd, sizeof(joinCmd));
  pkt.len = 1 + sizeof(joinCmd);
  wireless.send(&pkt, adv.masterMac);

  // Request immediate time sync after joining
  requestTimeSync();
  lastTimeSync = millis();

  if (onGroupJoined)
    onGroupJoined(currentGroup);
}

void SyncManager::leaveGroup()
{
  if (currentGroup.groupId == 0)
    return;

  // Prepare the leave/disband packet
  data_packet pkt;
  pkt.type = SYNC_MSG_TYPE;
  pkt.data[0] = SYNC_GROUP_LEAVE;

  GroupLeaveCmd leaveCmd;
  leaveCmd.groupId = currentGroup.groupId;
  leaveCmd.deviceId = ourDeviceId;
  memcpy(&pkt.data[1], &leaveCmd, sizeof(leaveCmd));
  pkt.len = 1 + sizeof(leaveCmd);

  if (currentGroup.isMaster)
  {
    // Master is disbanding the group: broadcast to all slaves
    wireless.send(&pkt, BROADCAST_MAC);
    Serial.println("[GroupLeave] Master disbanding group, notifying all slaves");
  }
  else
  {
    // Slave is leaving: notify the master only
    auto &groupAdv = discoveredGroups[currentGroup.groupId];
    wireless.send(&pkt, (uint8_t *)groupAdv.masterMac);
    Serial.println("[GroupLeave] Notified master of group departure");
  }

  // Clear local group state on this device
  timeSynced = false;
  timeOffset = 0;
  currentGroup = {};

  if (onGroupLeft)
    onGroupLeft();
}

// Sync Mode Management
void SyncManager::setSyncMode(SyncMode mode)
{
  if (syncMode == mode)
    return;

  SyncMode oldMode = syncMode;
  syncMode = mode;
  preferences.putUInt("syncMode", static_cast<uint8_t>(mode));

  Serial.println(String("[SyncMode] Changing from ") + getSyncModeString(oldMode) + " to " + getSyncModeString());

  switch (mode)
  {
  case SyncMode::SOLO:
    // Leave any current group and stop all group operations
    if (currentGroup.groupId != 0)
    {
      leaveGroup();
    }
    Serial.println("[SyncMode] SOLO mode - no group interaction");
    break;

  case SyncMode::JOIN:
    // If not in a group, start looking for groups to join
    if (currentGroup.groupId == 0)
    {
      Serial.println("[SyncMode] JOIN mode - looking for groups to join");
      // checkJoinMode will be called in the next loop iteration
    }
    else
    {
      Serial.println("[SyncMode] JOIN mode - already in a group - leaving");
      // check if we are the master
      if (currentGroup.isMaster)
      {
        Serial.println("[SyncMode] JOIN mode - we are the master - leaving");
        leaveGroup();
      }
      else
      {
        Serial.println("[SyncMode] JOIN mode - we are a slave - staying in group");
      }
    }
    break;

  case SyncMode::HOST:
    // Create a group immediately
    if (currentGroup.groupId == 0)
    {
      Serial.println("[SyncMode] HOST mode - creating group immediately");
      createGroup();
    }
    else if (!currentGroup.isMaster)
    {
      Serial.println("[SyncMode] HOST mode - leaving current group and creating new one");
      leaveGroup();
      createGroup();
    }
    else
    {
      Serial.println("[SyncMode] HOST mode - already hosting a group");
    }
    break;
  }

  saveSyncModePreferences();
}

SyncMode SyncManager::getSyncMode()
{
  return syncMode;
}

String SyncManager::getSyncModeString()
{
  return getSyncModeString(syncMode);
}

String SyncManager::getSyncModeString(SyncMode mode)
{
  switch (mode)
  {
  case SyncMode::SOLO:
    return "SOLO";
  case SyncMode::JOIN:
    return "JOIN";
  case SyncMode::HOST:
    return "HOST";
  default:
    return "UNKNOWN";
  }
}

void SyncManager::requestTimeSync()
{
  if (currentGroup.groupId == 0 || currentGroup.isMaster)
    return;
  uint32_t reqTs = millis();
  lastTimeReq = reqTs;

  Serial.println("[TimeSync] Requesting time sync from master");

  data_packet pkt;
  pkt.type = SYNC_MSG_TYPE;
  pkt.data[0] = SYNC_TIME_REQUEST;

  TimeRequestCmd requestCmd;
  requestCmd.requestTimestamp = reqTs;

  memcpy(&pkt.data[1], &requestCmd, sizeof(requestCmd));
  pkt.len = 1 + sizeof(requestCmd);
  auto &adv = discoveredGroups[currentGroup.groupId];
  wireless.send(&pkt, adv.masterMac);
}

bool SyncManager::isTimeSynced() const
{
  // Masters are always considered synced (they are the time reference)
  if (currentGroup.isMaster && currentGroup.groupId != 0)
    return true;

  return timeSynced;
}

uint32_t SyncManager::getSyncedTime() const
{
  return timeSynced ? millis() + timeOffset : millis();
}

int32_t SyncManager::getTimeOffset() const
{
  return timeOffset;
}

uint32_t SyncManager::syncMillis()
{
  SyncManager *syncMgr = SyncManager::getInstance();
  if (syncMgr->isTimeSynced())
  {
    return syncMgr->getSyncedTime();
  }
  return millis();
}

void SyncManager::setDeviceDiscoveredCallback(
    std::function<void(const DiscoveredDevice &)> cb) { onDeviceDiscovered = cb; }

void SyncManager::setGroupFoundCallback(
    std::function<void(const GroupAdvert &)> cb) { onGroupFound = cb; }

void SyncManager::setGroupCreatedCallback(
    std::function<void(const GroupInfo &)> cb) { onGroupCreated = cb; }

void SyncManager::setGroupJoinedCallback(
    std::function<void(const GroupInfo &)> cb) { onGroupJoined = cb; }

void SyncManager::setGroupLeftCallback(std::function<void()> cb)
{
  onGroupLeft = cb;
}

void SyncManager::setTimeSyncCallback(
    std::function<void(uint32_t)> cb) { onTimeSynced = cb; }

void SyncManager::setEffectSyncCallback(
    std::function<void(const EffectSyncState &)> cb) { onEffectSync = cb; }

void SyncManager::printDeviceInfo()
{
  Serial.println(F("\n=== DISCOVERED DEVICES ==="));

  if (discoveredDevices.empty())
  {
    Serial.println(F("No devices discovered."));
  }
  else
  {
    Serial.println(String(F("Found ")) + String(discoveredDevices.size()) + F(" device(s):"));
    Serial.println();

    int index = 1;
    for (const auto &devicePair : discoveredDevices)
    {
      const DiscoveredDevice &device = devicePair.second;

      Serial.println(String(F("Device ")) + String(index) + F(":"));
      Serial.println(String(F("  Device ID: 0x")) + String(device.deviceId, HEX));

      // Format MAC address
      String macStr = "";
      for (int j = 0; j < 6; j++)
      {
        if (device.mac[j] < 16)
          macStr += "0";
        macStr += String(device.mac[j], HEX);
        if (j < 5)
          macStr += ":";
      }
      macStr.toUpperCase();
      Serial.println(String(F("  MAC Address: ")) + macStr);

      uint32_t timeSinceLastSeen = millis() - device.lastSeen;
      Serial.println(String(F("  Last Seen: ")) + String(timeSinceLastSeen) + F("ms ago"));

      // Check if this device is in our current group
      if (currentGroup.groupId != 0)
      {
        auto memberIt = currentGroup.members.find(devicePair.first);
        if (memberIt != currentGroup.members.end())
        {
          Serial.println(F("  Status: In current group"));
        }
        else
        {
          Serial.println(F("  Status: Not in current group"));
        }
      }
      else
      {
        Serial.println(F("  Status: No group context"));
      }

      Serial.println();
      index++;
    }
  }

  Serial.println(F("==========================="));
}

void SyncManager::printGroupInfo()
{
  Serial.println(F("\n=== GROUP INFORMATION ==="));

  if (currentGroup.groupId == 0)
  {
    Serial.println(F("Not currently in a group."));
  }
  else
  {
    Serial.println(String(F("Group ID: 0x")) + String(currentGroup.groupId, HEX));
    Serial.println(String(F("Master Device: 0x")) + String(currentGroup.masterDeviceId, HEX));
    Serial.println(String(F("Role: ")) + (currentGroup.isMaster ? "MASTER" : "SLAVE"));
    Serial.println(String(F("Time Synced: ")) + (timeSynced ? "YES" : "NO"));

    if (timeSynced)
    {
      Serial.println(String(F("Time Offset: ")) + String(timeOffset) + F("ms"));
      Serial.println(String(F("Synced Time: ")) + String(getSyncedTime()));
    }

    Serial.println(String(F("Group Members: ")) + String(currentGroup.members.size()));

    if (!currentGroup.members.empty())
    {
      Serial.println(F("\nMember Details:"));
      int index = 1;

      for (const auto &memberPair : currentGroup.members)
      {
        const GroupMember &member = memberPair.second;

        Serial.println(String(F("  Member ")) + String(index) + F(":"));
        Serial.println(String(F("    Device ID: 0x")) + String(member.deviceId, HEX));

        // Format MAC address
        String macStr = "";
        for (int j = 0; j < 6; j++)
        {
          if (member.mac[j] < 16)
            macStr += "0";
          macStr += String(member.mac[j], HEX);
          if (j < 5)
            macStr += ":";
        }
        macStr.toUpperCase();
        Serial.println(String(F("    MAC Address: ")) + macStr);

        // Check if this is the master
        if (member.deviceId == currentGroup.masterDeviceId)
        {
          Serial.println(F("    Role: MASTER"));
        }
        else
        {
          Serial.println(F("    Role: SLAVE"));
        }

        // Check if this is us
        if (member.deviceId == ourDeviceId)
        {
          Serial.println(F("    Status: This device"));
        }
        else
        {
          Serial.println(F("    Status: Remote device"));

          // Try to find additional info from discovered devices
          auto discoveredIt = discoveredDevices.find(memberPair.first);
          if (discoveredIt != discoveredDevices.end())
          {
            uint32_t timeSinceLastSeen = millis() - discoveredIt->second.lastSeen;
            Serial.println(String(F("    Last Heartbeat: ")) + String(timeSinceLastSeen) + F("ms ago"));
          }
          else
          {
            Serial.println(F("    Last Heartbeat: Unknown"));
          }
        }

        Serial.println();
        index++;
      }
    }
  }

  // Also show discovered groups
  Serial.println(F("\nDiscovered Groups:"));
  if (discoveredGroups.empty())
  {
    Serial.println(F("No other groups discovered."));
  }
  else
  {
    int index = 1;
    for (const auto &groupPair : discoveredGroups)
    {
      const GroupAdvert &group = groupPair.second;

      Serial.println(String(F("  Group ")) + String(index) + F(":"));
      Serial.println(String(F("    Group ID: 0x")) + String(group.groupId, HEX));
      Serial.println(String(F("    Master Device: 0x")) + String(group.masterDeviceId, HEX));

      // Format master MAC address
      String macStr = "";
      for (int j = 0; j < 6; j++)
      {
        if (group.masterMac[j] < 16)
          macStr += "0";
        macStr += String(group.masterMac[j], HEX);
        if (j < 5)
          macStr += ":";
      }
      macStr.toUpperCase();
      Serial.println(String(F("    Master MAC: ")) + macStr);

      uint32_t timeSinceLastSeen = millis() - group.lastSeen;
      Serial.println(String(F("    Last Announce: ")) + String(timeSinceLastSeen) + F("ms ago"));

      if (group.groupId == currentGroup.groupId)
      {
        Serial.println(F("    Status: Current group"));
      }
      else
      {
        Serial.println(F("    Status: Available to join"));
      }

      Serial.println();
      index++;
    }
  }

  Serial.println(F("========================="));
}

void SyncManager::updateSyncedLED()
{
  uint32_t currentTime = millis();
  bool fastBlink = (currentTime % 250) < 125;       // 4Hz fast blink
  bool slowBlink = (currentTime % 1000) < 500;      // 1Hz slow blink
  bool verySlowBlink = (currentTime % 2000) < 1000; // 0.5Hz very slow blink

  // if app mode is off, turn off the led
  if (Application::getInstance()->getMode() == ApplicationMode::OFF)
  {
    statusLed2.setColor(0, 0, 0);
    return;
  }

  // Use synchronized time for blinking when available
  if (timeSynced && currentGroup.groupId != 0)
  {
    uint32_t syncTime = getSyncedTime();
    slowBlink = (syncTime % 1000) < 500;
  }

  switch (syncMode)
  {
  case SyncMode::SOLO:
    // SOLO mode: Steady white - no group interaction
    statusLed2.setColor(100, 100, 100);
    break;

  case SyncMode::JOIN:
    if (currentGroup.groupId == 0)
    {
      // JOIN mode, not in group: Fast blinking yellow - actively searching
      if (fastBlink)
        statusLed2.setColor(255, 255, 0);
      else
        statusLed2.setColor(0, 0, 0);
    }
    else if (!timeSynced)
    {
      // JOIN mode, in group but not synced: Fast blinking orange
      if (fastBlink)
        statusLed2.setColor(255, 165, 0);
      else
        statusLed2.setColor(0, 0, 0);
    }
    else
    {
      // JOIN mode, in group and synced: Slow blinking blue (slave)
      if (slowBlink)
        statusLed2.setColor(0, 0, 255);
      else
        statusLed2.setColor(0, 0, 0);
    }
    break;

  case SyncMode::HOST:
    if (currentGroup.groupId == 0)
    {
      // HOST mode, no group created yet: Very slow blinking red
      if (verySlowBlink)
        statusLed2.setColor(255, 0, 0);
      else
        statusLed2.setColor(0, 0, 0);
    }
    else if (currentGroup.isMaster)
    {
      if (currentGroup.members.size() < 2)
      {
        // HOST mode, master with no other members: Steady magenta
        statusLed2.setColor(255, 0, 255);
      }
      else if (timeSynced)
      {
        // HOST mode, master with members and synced: Slow blinking magenta
        if (slowBlink)
          statusLed2.setColor(255, 0, 255);
        else
          statusLed2.setColor(0, 0, 0); // Dimmer magenta when "off"
      }
      else
      {
        // HOST mode, master but somehow not synced: Fast blinking magenta
        if (fastBlink)
          statusLed2.setColor(255, 0, 255);
        else
          statusLed2.setColor(0, 0, 0);
      }
    }
    else
    {
      // HOST mode but we're somehow a slave (shouldn't happen): Fast blinking cyan
      if (fastBlink)
        statusLed2.setColor(0, 255, 255);
      else
        statusLed2.setColor(0, 0, 0);
    }
    break;

  default:
    // Unknown mode: Fast blinking red
    if (fastBlink)
      statusLed2.setColor(255, 0, 0);
    else
      statusLed2.setColor(0, 0, 0);
    break;
  }
}

void SyncManager::handleSyncPacket(fullPacket *fp)
{

  if (fp->p.len < 1)
  {

    return;
  }

  uint8_t sub = fp->p.data[0];
  switch (sub)
  {
  case SYNC_HEARTBEAT:
    processHeartbeat(fp);
    break;
  case SYNC_GROUP_ANNOUNCE:
    processGroupAnnounce(fp);
    break;
  case SYNC_GROUP_JOIN:
    processGroupJoin(fp);
    break;
  case SYNC_GROUP_INFO:
    processGroupInfo(fp);
    break;
  case SYNC_GROUP_LEAVE:
    processGroupLeave(fp);
    break;
  case SYNC_TIME_REQUEST:
    processTimeRequest(fp);
    break;
  case SYNC_TIME_RESPONSE:
    processTimeResponse(fp);
    break;
  case SYNC_EFFECT_STATE:
    processEffectState(fp);
    break;
  default:
    break;
  }
}

void SyncManager::processHeartbeat(fullPacket *fp)
{
  if (fp->p.len < 1 + sizeof(HeartbeatCmd))
    return;
  if (memcmp(fp->mac, getOurMac(), 6) == 0)
    return;

  HeartbeatCmd heartbeatCmd;
  memcpy(&heartbeatCmd, &fp->p.data[1], sizeof(heartbeatCmd));

  std::string ms = macToString(fp->mac);
  bool isNew = (discoveredDevices.find(ms) == discoveredDevices.end());
  DiscoveredDevice d{heartbeatCmd.deviceId, {}, millis()};
  memcpy(d.mac, fp->mac, 6);
  discoveredDevices[ms] = d;
  if (isNew && onDeviceDiscovered)
    onDeviceDiscovered(d);
}

void SyncManager::processGroupAnnounce(fullPacket *fp)
{
  if (fp->p.len < 1 + sizeof(GroupAnnounceCmd))
    return;
  if (memcmp(fp->mac, getOurMac(), 6) == 0)
    return;

  GroupAnnounceCmd announceCmd;
  memcpy(&announceCmd, &fp->p.data[1], sizeof(announceCmd));

  std::string ms = macToString(fp->mac);
  bool isNew = (discoveredGroups.find(announceCmd.groupId) == discoveredGroups.end());
  GroupAdvert adv;
  adv.groupId = announceCmd.groupId;
  adv.masterDeviceId = announceCmd.masterDeviceId;
  memcpy(adv.masterMac, fp->mac, 6);
  adv.lastSeen = millis();
  discoveredGroups[announceCmd.groupId] = adv;
  if (isNew && onGroupFound)
    onGroupFound(adv);
}

void SyncManager::processGroupJoin(fullPacket *fp)
{
  if (!currentGroup.isMaster)
    return;
  if (fp->p.len < 1 + sizeof(GroupJoinCmd))
    return;

  GroupJoinCmd joinCmd;
  memcpy(&joinCmd, &fp->p.data[1], sizeof(joinCmd));

  if (joinCmd.groupId != currentGroup.groupId)
    return;

  std::string ms = macToString(fp->mac);
  GroupMember gm{
      joinCmd.deviceId,
      {0},
  };
  memcpy(gm.mac, fp->mac, 6);
  currentGroup.members[ms] = gm;
  sendGroupInfo();
}

void SyncManager::processGroupInfo(fullPacket *fp)
{
  if (currentGroup.isMaster)
    return;
  if (fp->p.len < 1 + sizeof(GroupInfoCmd))
    return;

  GroupInfoCmd infoCmd;
  memcpy(&infoCmd, &fp->p.data[1], sizeof(infoCmd));

  if (infoCmd.groupId != currentGroup.groupId)
    return;

  currentGroup.masterDeviceId = infoCmd.masterDeviceId;
  currentGroup.members.clear();

  size_t off = 1 + sizeof(infoCmd);
  for (uint8_t i = 0; i < infoCmd.memberCount; i++)
  {
    if (off + sizeof(GroupInfoMember) > fp->p.len)
      break;

    GroupInfoMember member;
    memcpy(&member, &fp->p.data[off], sizeof(member));
    off += sizeof(member);

    std::string ms;
    char buf[3];
    for (int b = 0; b < 6; b++)
    {
      sprintf(buf, "%02X", member.mac[b]);
      ms += buf;
    }

    GroupMember gm{
        member.deviceId,
        {0},
    };
    memcpy(gm.mac, member.mac, 6);
    currentGroup.members[ms] = gm;
  }
}

void SyncManager::processGroupLeave(fullPacket *fp)
{
  if (fp->p.len < 1 + sizeof(GroupLeaveCmd))
    return;

  GroupLeaveCmd leaveCmd;
  memcpy(&leaveCmd, &fp->p.data[1], sizeof(leaveCmd));

  // Ignore if not for our current group
  if (leaveCmd.groupId != currentGroup.groupId)
    return;

  if (currentGroup.isMaster)
  {
    // We're the master: a slave is leaving
    std::string macStr = macToString(fp->mac);
    auto memberIt = currentGroup.members.find(macStr);
    if (memberIt != currentGroup.members.end())
    {
      Serial.println("[GroupLeave] Device 0x" +
                     String(leaveCmd.deviceId, HEX) +
                     " left the group");
      currentGroup.members.erase(memberIt);
      // Broadcast updated group info to remaining members
      sendGroupInfo();
    }
  }
  else
  {
    // We're a slave: check if master is disbanding
    if (leaveCmd.deviceId == currentGroup.masterDeviceId)
    {
      Serial.println("[GroupDisband] Master 0x" +
                     String(leaveCmd.deviceId, HEX) +
                     " disbanded the group. Leaving group...");
      // Clear sync & group info
      timeSynced = false;
      timeOffset = 0;
      uint32_t gid = currentGroup.groupId;
      currentGroup = {};
      // Remove the now-dead group from discovery
      discoveredGroups.erase(gid);
      if (onGroupLeft)
        onGroupLeft();
    }
  }
}

void SyncManager::processTimeRequest(fullPacket *fp)
{
  if (!currentGroup.isMaster)
    return;
  if (fp->p.len < 1 + sizeof(TimeRequestCmd))
    return;

  TimeRequestCmd requestCmd;
  memcpy(&requestCmd, &fp->p.data[1], sizeof(requestCmd));

  uint32_t now = millis();

  Serial.println("[TimeSync] Master processing time request, responding with time: " + String(now));

  data_packet pkt;
  pkt.type = SYNC_MSG_TYPE;
  pkt.data[0] = SYNC_TIME_RESPONSE;

  TimeResponseCmd responseCmd;
  responseCmd.requestTimestamp = requestCmd.requestTimestamp;
  responseCmd.masterTimestamp = now;

  memcpy(&pkt.data[1], &responseCmd, sizeof(responseCmd));
  pkt.len = 1 + sizeof(responseCmd);
  wireless.send(&pkt, fp->mac);
}

void SyncManager::processTimeResponse(fullPacket *fp)
{
  if (currentGroup.isMaster || currentGroup.groupId == 0)
    return;
  if (fp->p.len < 1 + sizeof(TimeResponseCmd))
    return;

  TimeResponseCmd responseCmd;
  memcpy(&responseCmd, &fp->p.data[1], sizeof(responseCmd));

  uint32_t now = millis();
  uint32_t rtt = now - responseCmd.requestTimestamp;
  int32_t newOff = (int32_t)responseCmd.masterTimestamp + (int32_t)(rtt / 2) - (int32_t)now;

  Serial.println("[TimeSync] Received time response - RTT: " + String(rtt) + "ms, New offset: " + String(newOff) + "ms");

  if (!timeSynced)
  {
    timeOffset = newOff;
    timeSynced = true;
    Serial.println("[TimeSync] Initial sync achieved!");
  }
  else
  {
    int32_t oldOffset = timeOffset;
    timeOffset = (timeOffset * 3 + newOff) / 4;
    Serial.println("[TimeSync] Sync updated - Old offset: " + String(oldOffset) + "ms, New offset: " + String(timeOffset) + "ms");
  }

  // Update group sync state to match
  currentGroup.timeSynced = timeSynced;
  currentGroup.timeOffset = timeOffset;

  if (onTimeSynced)
    onTimeSynced(getSyncedTime());
}

void SyncManager::processEffectState(fullPacket *fp)
{
  // Only slaves should process effect state from master
  if (currentGroup.isMaster || currentGroup.groupId == 0)
    return;

  if (fp->p.len < 1 + sizeof(EffectSyncState))
    return;

  EffectSyncState newState;
  memcpy(&newState, &fp->p.data[1], sizeof(newState));

  // Update our local state
  currentEffectState = newState;

  // Notify the application
  if (onEffectSync)
  {
    onEffectSync(currentEffectState);
  }

  Serial.println("[EffectSync] Received effect state from master");
}

void SyncManager::sendHeartbeat()
{
  data_packet pkt;
  pkt.type = SYNC_MSG_TYPE;
  pkt.data[0] = SYNC_HEARTBEAT;

  HeartbeatCmd heartbeatCmd;
  heartbeatCmd.deviceId = ourDeviceId;

  memcpy(&pkt.data[1], &heartbeatCmd, sizeof(heartbeatCmd));
  pkt.len = 1 + sizeof(heartbeatCmd);
  wireless.send(&pkt, BROADCAST_MAC);
}

void SyncManager::sendGroupAnnounce()
{
  if (!currentGroup.isMaster)
    return;
  data_packet pkt;
  pkt.type = SYNC_MSG_TYPE;
  pkt.data[0] = SYNC_GROUP_ANNOUNCE;

  GroupAnnounceCmd announceCmd;
  announceCmd.groupId = currentGroup.groupId;
  announceCmd.masterDeviceId = currentGroup.masterDeviceId;

  memcpy(&pkt.data[1], &announceCmd, sizeof(announceCmd));
  pkt.len = 1 + sizeof(announceCmd);
  wireless.send(&pkt, BROADCAST_MAC);
}

void SyncManager::sendGroupInfo()
{
  if (!currentGroup.isMaster)
    return;
  data_packet pkt;
  pkt.type = SYNC_MSG_TYPE;
  pkt.data[0] = SYNC_GROUP_INFO;

  GroupInfoCmd infoCmd;
  infoCmd.groupId = currentGroup.groupId;
  infoCmd.masterDeviceId = currentGroup.masterDeviceId;
  infoCmd.memberCount = currentGroup.members.size();

  memcpy(&pkt.data[1], &infoCmd, sizeof(infoCmd));
  size_t off = 1 + sizeof(infoCmd);

  for (auto &kv : currentGroup.members)
  {
    if (off + sizeof(GroupInfoMember) > sizeof(pkt.data))
      break;

    GroupInfoMember member;
    member.deviceId = kv.second.deviceId;
    memcpy(member.mac, kv.second.mac, 6);

    memcpy(&pkt.data[off], &member, sizeof(member));
    off += sizeof(member);
  }
  pkt.len = off;
  wireless.send(&pkt, BROADCAST_MAC);
}

void SyncManager::sendEffectState()
{
  if (!currentGroup.isMaster || !effectSyncEnabled)
    return;

  data_packet pkt;
  pkt.type = SYNC_MSG_TYPE;
  pkt.data[0] = SYNC_EFFECT_STATE;
  memcpy(&pkt.data[1], &currentEffectState, sizeof(currentEffectState));
  pkt.len = 1 + sizeof(currentEffectState);
  wireless.send(&pkt, BROADCAST_MAC);

  // Serial.println("[EffectSync] Broadcasting effect state to group");
}

void SyncManager::checkDiscoveryCleanup(uint32_t now)
{
  std::vector<std::string> rm;
  for (auto &kv : discoveredDevices)
  {
    if (now - kv.second.lastSeen > DISCOVERY_TIMEOUT)
    {
      rm.push_back(kv.first);
    }
  }
  for (auto &key : rm)
    discoveredDevices.erase(key);
}

void SyncManager::checkGroupCleanup(uint32_t now)
{
  std::vector<uint32_t> rm;
  for (auto &kv : discoveredGroups)
  {
    if (now - kv.second.lastSeen > GROUP_DISCOVERY_TIMEOUT)
    {
      rm.push_back(kv.first);
    }
  }
  for (auto gid : rm)
  {
    discoveredGroups.erase(gid);
    if (!currentGroup.isMaster &&
        currentGroup.groupId == gid)
    {
      leaveGroup();
    }
  }
}

void SyncManager::checkMemberTimeout(uint32_t now)
{
  // Only check member timeouts if we're in a group
  if (currentGroup.groupId == 0)
    return;

  std::vector<std::string> membersToRemove;

  // Check each group member for timeout
  for (const auto &memberPair : currentGroup.members)
  {
    const std::string &macStr = memberPair.first;
    const GroupMember &member = memberPair.second;

    // Skip checking our own device
    if (member.deviceId == ourDeviceId)
      continue;

    // Check if this member is still in discovered devices and hasn't timed out
    auto discoveredIt = discoveredDevices.find(macStr);
    if (discoveredIt == discoveredDevices.end() ||
        (now - discoveredIt->second.lastSeen > GROUP_MEMBER_TIMEOUT))
    {
      // Member has timed out - mark for removal
      membersToRemove.push_back(macStr);
      Serial.println("[MemberTimeout] Removing timed out member: Device 0x" +
                     String(member.deviceId, HEX) + " (MAC: " + String(macStr.c_str()) + ")");
    }
  }

  // Remove timed out members
  bool membersWereRemoved = false;
  for (const std::string &macStr : membersToRemove)
  {
    currentGroup.members.erase(macStr);
    membersWereRemoved = true;
  }

  // If we're the master and members were removed, broadcast updated group info
  if (currentGroup.isMaster && membersWereRemoved)
  {
    Serial.println("[MemberTimeout] " + String(membersToRemove.size()) +
                   " member(s) removed. Current group size: " + String(currentGroup.members.size()));
    sendGroupInfo();
  }
}

void SyncManager::checkJoinMode(uint32_t now)
{
  if (currentGroup.groupId != 0)
    return;

  // In JOIN mode, immediately join any discovered group
  if (!discoveredGroups.empty())
  {
    Serial.println("[JoinMode] Found group, joining immediately...");
    joinGroup(discoveredGroups.begin()->first);
  }
}

uint32_t SyncManager::generateDeviceId()
{

  if (ourDeviceId != 0)
    return ourDeviceId;

  if (deviceInfo.serialNumber != 0)
  {
    return deviceInfo.serialNumber;
  }

  // Use multiple entropy sources for better randomization
  uint64_t macVal = ESP.getEfuseMac();
  uint32_t mac32Val = (uint32_t)(macVal & 0xFFFFFFFF);
  uint32_t currentTime = millis();
  uint32_t microTime = micros();

  // Re-seed random with current time and chip info for additional entropy
  randomSeed(mac32Val ^ currentTime ^ microTime);

  // Generate multiple random values and combine them
  uint32_t rand1 = random(1, UINT32_MAX);
  uint32_t rand2 = random(1, UINT32_MAX);
  uint32_t rand3 = random(1, UINT32_MAX);
  uint32_t rand4 = random(1, UINT32_MAX);

  // Combine all entropy sources using different operations
  uint32_t deviceId = 0;
  deviceId ^= (uint32_t)(macVal & 0xFFFFFFFF);         // Lower 32 bits of MAC
  deviceId ^= (uint32_t)((macVal >> 32) & 0xFFFFFFFF); // Upper 32 bits of MAC
  deviceId ^= currentTime;
  deviceId ^= microTime;
  deviceId ^= rand1;
  deviceId = (deviceId << 7) ^ rand2;               // Bit shift and XOR
  deviceId = (deviceId * 31) ^ rand3;               // Multiply by prime and XOR
  deviceId = ((deviceId >> 13) ^ deviceId) * rand4; // More bit mixing

  // Final mixing to ensure good distribution
  deviceId ^= (deviceId >> 16);
  deviceId *= 0x85ebca6b;
  deviceId ^= (deviceId >> 13);
  deviceId *= 0xc2b2ae35;
  deviceId ^= (deviceId >> 16);

  // Ensure we never return 0
  if (deviceId == 0)
  {
    deviceId = rand1 ^ rand2 ^ rand3 ^ rand4 ^ 0xDEADBEEF;
  }

  return deviceId;
}

uint32_t SyncManager::generateGroupId()
{
  return random(1, UINT32_MAX);
}

std::string SyncManager::macToString(const uint8_t *mac) const
{
  char buf[3];
  std::string s;
  for (int i = 0; i < 6; i++)
  {
    sprintf(buf, "%02X", mac[i]);
    s += buf;
  }
  return s;
}

const uint8_t *SyncManager::getOurMac()
{
  static uint8_t our[6];
  static bool inited = false;
  if (!inited)
  {
    WiFi.macAddress(our);
    inited = true;
  }
  return our;
}

// Effect sync methods
void SyncManager::setEffectSyncState(const EffectSyncState &state)
{
  currentEffectState = state;

  // if (millis() % 1000 < 10)
  // {
  //   currentEffectState.print();
  // }

  // If we're the master and effect sync is enabled, broadcast the state
  if (currentGroup.isMaster && effectSyncEnabled)
  {
    // sendEffectState();
  }
}

const EffectSyncState &SyncManager::getEffectSyncState() const
{
  return currentEffectState;
}

void SyncManager::enableEffectSync(bool enabled)
{
  effectSyncEnabled = enabled;
}

bool SyncManager::isEffectSyncEnabled() const
{
  return effectSyncEnabled;
}

// Preferences Management
void SyncManager::loadPreferences()
{
  // Load sync mode preference
  uint8_t savedMode = preferences.getUChar("sync_mode", static_cast<int>(SyncMode::SOLO));
  syncMode = static_cast<SyncMode>(savedMode);

  Serial.println("[SyncManager] Loaded preferences:");
  Serial.println(String("  Sync Mode: ") + getSyncModeString());
}

void SyncManager::saveSyncModePreferences()
{
  preferences.putUChar("sync_mode", static_cast<int>(syncMode));
  Serial.println(String("[SyncManager] Sync mode preferences saved: ") + getSyncModeString());
}

void SyncManager::printSyncModeInfo()
{
  Serial.println(F("\n=== SYNC MODE INFO ==="));
  Serial.println(String("Current Mode: ") + getSyncModeString());

  switch (syncMode)
  {
  case SyncMode::SOLO:
    Serial.println(F("  - No group interaction"));
    Serial.println(F("  - Won't host or join groups"));
    break;
  case SyncMode::JOIN:
    Serial.println(F("  - Looking for groups to join"));
    Serial.println(String(F("  - Discovered groups: ")) + String(discoveredGroups.size()));
    break;
  case SyncMode::HOST:
    Serial.println(F("  - Hosting mode"));
    if (currentGroup.groupId != 0 && currentGroup.isMaster)
    {
      Serial.println(String(F("  - Currently hosting group: 0x")) + String(currentGroup.groupId, HEX));
      Serial.println(String(F("  - Group members: ")) + String(currentGroup.members.size()));
    }
    else
    {
      Serial.println(F("  - Ready to create group"));
    }
    break;
  }

  Serial.println(F("======================="));
}========
==== Sync/SyncManager.h: ====
// SyncManager.h
#pragma once

#include <Arduino.h>
#include <map>
#include <vector>
#include <functional>
#include <string>
#include "IO/Wireless.h"
#include "config.h"

#include "IO/LED/Types.h"

// Message types
constexpr uint8_t SYNC_MSG_TYPE = 0xA0;
constexpr uint8_t SYNC_HEARTBEAT = 0x01;
constexpr uint8_t SYNC_GROUP_ANNOUNCE = 0x02;
constexpr uint8_t SYNC_GROUP_JOIN = 0x03;
constexpr uint8_t SYNC_GROUP_INFO = 0x04;
constexpr uint8_t SYNC_TIME_REQUEST = 0x05;
constexpr uint8_t SYNC_TIME_RESPONSE = 0x06;
constexpr uint8_t SYNC_EFFECT_STATE = 0x07;
constexpr uint8_t SYNC_GROUP_LEAVE = 0x08;

// Sync modes - simplified from complex auto-join/auto-create system
enum class SyncMode : uint8_t
{
  SOLO,
  JOIN,
  HOST
};

struct DiscoveredDevice
{
  uint32_t deviceId;
  uint8_t mac[6];
  uint32_t lastSeen;
};

struct GroupAdvert
{
  uint32_t groupId;
  uint32_t masterDeviceId;
  uint8_t masterMac[6];
  uint32_t lastSeen;
};

struct GroupMember
{
  uint32_t deviceId;
  uint8_t mac[6];
};

struct GroupLeaveCmd
{
  uint32_t groupId;
  uint32_t deviceId;
};

struct GroupInfo
{
  uint32_t groupId;
  uint32_t masterDeviceId;
  bool isMaster;
  // keyed by MAC string
  std::map<std::string, GroupMember> members;
  bool timeSynced;
  int32_t timeOffset;
};

// Sync command structs for maintainability
struct HeartbeatCmd
{
  uint32_t deviceId;
};

struct GroupAnnounceCmd
{
  uint32_t groupId;
  uint32_t masterDeviceId;
};

struct GroupJoinCmd
{
  uint32_t groupId;
  uint32_t deviceId;
};

struct GroupInfoCmd
{
  uint32_t groupId;
  uint32_t masterDeviceId;
  uint8_t memberCount;
  // Members follow as GroupInfoMember array
};

struct GroupInfoMember
{
  uint32_t deviceId;
  uint8_t mac[6];
};

struct TimeRequestCmd
{
  uint32_t requestTimestamp;
};

struct TimeResponseCmd
{
  uint32_t requestTimestamp;
  uint32_t masterTimestamp;
};

class SyncManager
{
public:
  static SyncManager *getInstance();

  void begin();
  void loop();

  // Device discovery
  const std::map<std::string, DiscoveredDevice> &
  getDiscoveredDevices() const;

  // Group discovery
  std::vector<GroupAdvert> getDiscoveredGroups() const;

  // Current group state
  const GroupInfo &getGroupInfo() const;
  bool isInGroup() const;
  bool isGroupMaster() const;
  uint32_t getGroupId() const;

  // Self
  uint32_t getDeviceId() const;

  // Group operations
  void createGroup(uint32_t groupId = 0);
  void joinGroup(uint32_t groupId);
  void leaveGroup();

  // Simplified mode system replacing auto-join and auto-create
  void setSyncMode(SyncMode mode);
  SyncMode getSyncMode();
  String getSyncModeString();
  String getSyncModeString(SyncMode mode);

  // Time sync
  void requestTimeSync();
  bool isTimeSynced() const;
  uint32_t getSyncedTime() const;
  int32_t getTimeOffset() const;

  static uint32_t syncMillis();

  // Effect sync
  void setEffectSyncState(const EffectSyncState &state);
  const EffectSyncState &getEffectSyncState() const;
  void enableEffectSync(bool enabled = true);
  bool isEffectSyncEnabled() const;

  // Callbacks
  void setDeviceDiscoveredCallback(
      std::function<void(const DiscoveredDevice &)> cb);
  void setGroupFoundCallback(
      std::function<void(const GroupAdvert &)> cb);
  void setGroupCreatedCallback(
      std::function<void(const GroupInfo &)> cb);
  void setGroupJoinedCallback(
      std::function<void(const GroupInfo &)> cb);
  void setGroupLeftCallback(std::function<void()> cb);
  void setTimeSyncCallback(
      std::function<void(uint32_t syncedTime)> cb);
  void setEffectSyncCallback(
      std::function<void(const EffectSyncState &)> cb);

  // Debug/Info functions
  void printDeviceInfo();
  void printGroupInfo();
  void printSyncModeInfo();

  // senders
  void sendHeartbeat();
  void sendGroupAnnounce();
  void sendGroupInfo();
  void sendEffectState();

  // Test LED for sync visualization
  void updateSyncedLED();

private:
  SyncManager();
  ~SyncManager();

  // packet handlers
  void handleSyncPacket(fullPacket *fp);
  void processHeartbeat(fullPacket *fp);
  void processGroupAnnounce(fullPacket *fp);
  void processGroupJoin(fullPacket *fp);
  void processGroupInfo(fullPacket *fp);
  void processGroupLeave(fullPacket *fp);
  void processTimeRequest(fullPacket *fp);
  void processTimeResponse(fullPacket *fp);
  void processEffectState(fullPacket *fp);

  // periodic tasks
  void checkDiscoveryCleanup(uint32_t now);
  void checkGroupCleanup(uint32_t now);
  void checkMemberTimeout(uint32_t now);
  void checkJoinMode(uint32_t now);

  // preferences management
  void loadPreferences();
  void saveSyncModePreferences();

  // utilities
  uint32_t generateDeviceId();
  uint32_t generateGroupId();
  std::string macToString(const uint8_t *mac) const;
  const uint8_t *getOurMac();

  // state
  std::map<std::string, DiscoveredDevice> discoveredDevices;
  std::map<uint32_t, GroupAdvert> discoveredGroups;
  GroupInfo currentGroup;
  uint32_t ourDeviceId;

  // Simplified sync mode system
  SyncMode syncMode = SyncMode::SOLO;

  // time‐sync
  bool timeSynced = false;
  int32_t timeOffset = 0;
  uint32_t lastTimeSync = 0;
  uint32_t lastTimeReq = 0;

  // effect sync
  bool effectSyncEnabled = true;
  EffectSyncState currentEffectState = {};
  uint32_t lastEffectSync = 0;

  // timers
  uint32_t lastHeartbeat = 0;
  uint32_t lastGrpAnnounce = 0;
  uint32_t lastGrpInfo = 0;
  uint32_t lastDiscCleanup = 0;
  uint32_t lastGrpCleanup = 0;

  // callbacks
  std::function<void(const DiscoveredDevice &)> onDeviceDiscovered;
  std::function<void(const GroupAdvert &)> onGroupFound;
  std::function<void(const GroupInfo &)> onGroupCreated;
  std::function<void(const GroupInfo &)> onGroupJoined;
  std::function<void()> onGroupLeft;
  std::function<void(uint32_t)> onTimeSynced;
  std::function<void(const EffectSyncState &)> onEffectSync;

  // intervals/timeouts (ms)
  static constexpr uint32_t HEARTBEAT_INTERVAL = 1000;
  static constexpr uint32_t DISCOVERY_TIMEOUT = 6000;
  static constexpr uint32_t GROUP_ANNOUNCE_INTERVAL = 2000;
  static constexpr uint32_t GROUP_DISCOVERY_TIMEOUT = 6000;
  static constexpr uint32_t GROUP_INFO_INTERVAL = 2000;
  static constexpr uint32_t TIME_SYNC_INTERVAL = 10000;
  static constexpr uint32_t EFFECT_SYNC_INTERVAL = 1000;
  static constexpr uint32_t GROUP_MEMBER_TIMEOUT = 8000; // Time after which a member is considered inactive
};========
==== config.cpp: ====
#include "config.h"

DeviceInfo::DeviceInfo()
{
  debugEnabled = false;
  oledEnabled = false;
  memset(macAddress, 0, sizeof(macAddress));
  serialNumber = 0;
  hardwareVersion = 0;
}

void DeviceInfo::print()
{
  Serial.println("DeviceInfo:");
  Serial.printf("Debug Enabled: %s\n", debugEnabled ? "true" : "false");
  Serial.printf("OLED Enabled: %s\n", oledEnabled ? "true" : "false");
  Serial.printf("Mac Address: %02X:%02X:%02X:%02X:%02X:%02X\n",
                macAddress[0], macAddress[1], macAddress[2],
                macAddress[3], macAddress[4], macAddress[5]);
  Serial.printf("Serial Number: %d\n", serialNumber);
  Serial.printf("Hardware Version: %d\n", hardwareVersion);
  Serial.println();
}

Preferences preferences;

DeviceInfo deviceInfo;

LEDConfig::LEDConfig()
{
  // Constructor initializes with default values as set in header
  headlightsEnabled = true;
  taillightsEnabled = true;
  underglowEnabled = false;
  interiorEnabled = false;

  headlightLedCount = 50;
  taillightLedCount = 50;
  underglowLedCount = 50;
  interiorLedCount = 50;

  // headlightPin = OUTPUT_LED_1_PIN;
  // taillightPin = OUTPUT_LED_2_PIN;
  // underglowPin = OUTPUT_LED_3_PIN;
  // interiorPin = OUTPUT_LED_4_PIN;

  headlightFlipped = false;
  taillightFlipped = false;
  underglowFlipped = false;
  interiorFlipped = false;
}

void LEDConfig::print()
{
  Serial.println("LED Configuration:");
  Serial.printf("Headlights: %s, Count: %d, Pin: %d, Flipped: %s\n",
                headlightsEnabled ? "ENABLED" : "DISABLED",
                headlightLedCount, 0, // headlightPin,
                headlightFlipped ? "YES" : "NO");
  Serial.printf("Taillights: %s, Count: %d, Pin: %d, Flipped: %s\n",
                taillightsEnabled ? "ENABLED" : "DISABLED",
                taillightLedCount, 0, // taillightPin,
                taillightFlipped ? "YES" : "NO");
  Serial.printf("Underglow: %s, Count: %d, Pin: %d, Flipped: %s\n",
                underglowEnabled ? "ENABLED" : "DISABLED",
                underglowLedCount, 0, // underglowPin,
                underglowFlipped ? "YES" : "NO");
  Serial.printf("Interior: %s, Count: %d, Pin: %d, Flipped: %s\n",
                interiorEnabled ? "ENABLED" : "DISABLED",
                interiorLedCount, 0, // interiorPin,
                interiorFlipped ? "YES" : "NO");
  Serial.println();
}

LEDConfig ledConfig;

void restart()
{
  Serial.println("[INFO] [CONFIG] Restarting...");
  ESP.restart();
}

String formatBytes(size_t bytes, bool _short)
{
  if (bytes < 1024)
  {
    if (_short)
    {
      // Since bytes is an integer, leave it as is.
      return String(bytes);
    }
    else
    {
      return String(bytes) + " B";
    }
  }
  else if (bytes < (1024UL * 1024UL))
  {
    // Force floating point math by casting bytes to double.
    double kb = ((double)bytes) / 1024.0;
    if (_short)
    {
      return String(kb, 1) + "K";
    }
    else
    {
      return String(kb, 2) + " KB";
    }
  }
  else
  {
    double mb = ((double)bytes) / (1024.0 * 1024.0);
    if (_short)
    {
      return String(mb, 1) + "M";
    }
    else
    {
      return String(mb, 2) + " MB";
    }
  }
}

void saveDeviceInfo()
{
  preferences.putBytes("deviceInfo", &deviceInfo, sizeof(DeviceInfo));
}

void loadDeviceInfo()
{
  size_t schLen = preferences.getBytesLength("deviceInfo");
  if (schLen == sizeof(DeviceInfo))
  {
    preferences.getBytes("deviceInfo", &deviceInfo, sizeof(DeviceInfo));
    Serial.println("[INFO] [CONFIG] Device info loaded from preferences");
  }
  else
  {
    Serial.println("[INFO] [CONFIG] No valid device info found in preferences, using defaults");
  }

  uint8_t baseMac[6];
  esp_read_mac(baseMac, ESP_MAC_WIFI_STA);
  memcpy(deviceInfo.macAddress, baseMac, 6);
  saveDeviceInfo();
}

void saveLEDConfig()
{
  preferences.putBytes("ledConfig", &ledConfig, sizeof(LEDConfig));
  Serial.println("[INFO] [CONFIG] LED config saved to preferences");
}

void loadLEDConfig()
{
  size_t schLen = preferences.getBytesLength("ledConfig");
  if (schLen == sizeof(LEDConfig))
  {
    preferences.getBytes("ledConfig", &ledConfig, sizeof(LEDConfig));
    Serial.println("[INFO] [CONFIG] LED config loaded from preferences");
  }
  else
  {
    Serial.println("[INFO] [CONFIG] No valid LED config found in preferences, using defaults");
    saveLEDConfig(); // Save defaults
  }
}
========
==== config.h: ====
#pragma once

#include <Arduino.h>

#include "IO/GPIO.h"

#include <WiFi.h>
#include <esp_wifi.h>
#include <esp_now.h>

#include <Preferences.h>

#define setBit(x, y, z) (x |= (z << y)) // Set a bit to a value
#define clearBit(x, y) (x &= ~(1 << y)) // Clear a bit
#define toggleBit(x, y) (x ^= (1 << y)) // Toggle a bit (0 -> 1, 1 -> 0) and return the new value
#define checkBit(x, y) ((x >> y) & 1)   // Check a bit and return 1 or 0

struct DeviceInfo
{
  bool debugEnabled = false;
  bool oledEnabled = false;

  uint8_t macAddress[6];
  uint32_t serialNumber;
  uint16_t hardwareVersion;

  DeviceInfo();
  void print();
};

struct LEDConfig
{
  // LED strip enable flags
  bool headlightsEnabled;
  bool taillightsEnabled;
  bool underglowEnabled;
  bool interiorEnabled;

  // LED strip lengths (default to 50 as requested)
  uint16_t headlightLedCount;
  uint16_t taillightLedCount;
  uint16_t underglowLedCount;
  uint16_t interiorLedCount;

  // LED strip pins (use defaults from defines)
  // uint8_t headlightPin;
  // uint8_t taillightPin;
  // uint8_t underglowPin;
  // uint8_t interiorPin;

  // LED strip flip settings
  bool headlightFlipped;
  bool taillightFlipped;
  bool underglowFlipped;
  bool interiorFlipped;

  LEDConfig();
  void print();
};

extern Preferences preferences;

extern DeviceInfo deviceInfo;
extern LEDConfig ledConfig;



void restart();
String formatBytes(size_t bytes, bool _short = false);

void saveDeviceInfo();
void loadDeviceInfo();

void saveLEDConfig();
void loadLEDConfig();

#define S3_V1
// #define S3_DEV
// #define S2_CAR

// WiFi

#define ESP_NOW_CHANNEL 1
#define CHANNEL 1
// #define DEBUG_ESP_NOW
// #define ESPNOW_NO_DISABLE_WIFI

// #define DEBUG_SYNC
#define ENABLE_SYNC

#ifdef S3_V1
#define LED_PIN 40 // make optinal

#define ENABLE_HV_INPUTS

#define INPUT_BTN_BOOT_PIN 0
#define INPUT_BTN_PREV_PIN 21
#define INPUT_BTN_SEL_PIN 14
#define INPUT_BTN_NEXT_PIN 13

#define INPUT_VOLTAGE_PIN 2

#define INPUT_1_PIN 4
#define INPUT_2_PIN 5
#define INPUT_3_PIN 6
#define INPUT_4_PIN 7
#define INPUT_5_PIN 15
#define INPUT_6_PIN 16
#define INPUT_7_PIN 17
#define INPUT_8_PIN 18

#define OUTPUT_STATUS_LED_PIN 1

#define OUTPUT_LED_1_PIN 3
#define OUTPUT_LED_2_PIN 10
#define OUTPUT_LED_3_PIN 11
#define OUTPUT_LED_4_PIN 12
#endif

#ifdef S3_DEV
#define LED_PIN 21
#define OUTPUT_STATUS_LED_PIN 16

// #define ENABLE_HV_INPUTS

#endif

#ifdef S2_CAR
#define LED_PIN 15

#define ENABLE_HV_INPUTS

#define INPUT_1_PIN 1
#define INPUT_2_PIN 2
#define INPUT_3_PIN 3
#define INPUT_4_PIN 4
#define INPUT_5_PIN 5
#define INPUT_6_PIN 6
#endif

// #define ENABLE_HEADLIGHTS
// #define ENABLE_TAILLIGHTS
// // #define ENABLE_UNDERGLOW
// // #define ENABLE_INTERIOR

// #ifdef ENABLE_HEADLIGHTS
// #define HEADLIGHT_LED_COUNT 99
// #define HEADLIGHT_LED_PIN OUTPUT_LED_1_PIN
// // #define HEADLIGHT_FLIPED
// #endif

// #ifdef ENABLE_TAILLIGHTS
// #define TAILLIGHT_LED_COUNT 120
// #define TAILLIGHT_LED_PIN OUTPUT_LED_2_PIN
// #endif

// #ifdef ENABLE_UNDERGLOW
// #define UNDERGLOW_LED_COUNT 120
// #define UNDERGLOW_LED_PIN OUTPUT_LED_3_PIN
// #endif

// #ifdef ENABLE_INTERIOR
// #define INTERIOR_LED_COUNT 60
// #define INTERIOR_LED_PIN OUTPUT_LED_4_PIN
// #endif========
==== main.cpp: ====
// main.cpp

// #include "secrets.h"
#include "config.h"

#include "IO/GPIO.h"
#include "IO/Wireless.h"
#include "Application.h"
#include "SerialMenu.h"
#include "IO/StatusLed.h"
#include "IO/Display.h"
#include "IO/ScreenManager.h"
#include "IO/TimeProfiler.h"

#include "Screens/StartUp.h"
#include "Screens/Home.h"

Application *app;

void setup()
{
  Serial.begin(115200);
  Serial.setTimeout(10);

  GpIO::initIO();
  statusLeds.begin();
  statusLeds.setBrightness(50);
  statusLed1.begin(&statusLeds, statusLeds.getLedPtr(0));
  statusLed2.begin(&statusLeds, statusLeds.getLedPtr(1));
  statusLeds.startShowTask();

  statusLed1.setMode(RGB_MODE::Overide);
  statusLed2.setMode(RGB_MODE::Overide);

  statusLed1.setOverideColor(255, 0, 0);
  statusLed2.setOverideColor(255, 0, 0);

  // Initialize random seed with multiple entropy sources
  uint64_t macVal = ESP.getEfuseMac();
  uint32_t millisVal = millis();
  uint32_t microsVal = micros();

  // Combine entropy sources for initial seed
  uint32_t initialSeed = (uint32_t)(macVal ^ (macVal >> 32)) ^ millisVal ^ microsVal;
  randomSeed(initialSeed);

  preferences.begin("esp", false);
  loadDeviceInfo();
  loadLEDConfig();

  timeProfiler.begin();

  if (deviceInfo.oledEnabled)
  {
    display.init();
    screenManager.init();

    screenManager.setScreen(&StartUpScreen);
    startUpScreenSetStage(1);
    display.display();
  }
  else
  {
    Serial.println("[INFO] [CONFIG] OLED display disabled, skipping display initialization");
  }

  WiFi.mode(WIFI_AP_STA);

  statusLed1.setOverideColor(0, 255, 0);
  statusLed2.setOverideColor(0, 255, 0);

  long bootCount = preferences.getLong("bootCount", 0);
  bootCount++;
  preferences.putLong("bootCount", bootCount);

  Serial.println("[INFO] [CONFIG] Boot count: " + String(bootCount));

  // Update startup screen if OLED is enabled
  if (deviceInfo.oledEnabled)
  {
    startUpScreenSetStage(2);
    display.display();
  }

  wireless.setup();

  app = Application::getInstance();

  if (!app)
  {
    Serial.println("Failed to create Application instance.");
    return;
  }

  app->begin();

  // Update screen display if OLED is enabled
  if (deviceInfo.oledEnabled)
  {
    startUpScreenSetStage(3);
    display.display();
  }

  statusLed1.setOverideColor(0, 0, 255);
  statusLed2.setOverideColor(0, 0, 255);

  vTaskDelay(300 / portTICK_PERIOD_MS);

  statusLed1.goBackSteps(1);
  statusLed2.goBackSteps(1);

  // Set home screen if OLED is enabled
  if (deviceInfo.oledEnabled)
  {
    screenManager.setScreen(&HomeScreen);
    display.display();
  }

  initSerialMenu();
}

unsigned long batteryLoopMs = 0;
unsigned long lastDraw = 0;

void loop()
{
  unsigned long currentTime = millis();
  timeProfiler.start("mainLoop", TimeUnit::MICROSECONDS);
  timeProfiler.increment("mainLoopFps");

  wireless.loop(); // does nothing

  if (millis() - batteryLoopMs > 500)
  {
    batteryLoopMs = millis();
    timeProfiler.start("batteryUpdate", TimeUnit::MICROSECONDS);
    batteryUpdate(); // ~130 us
    timeProfiler.stop("batteryUpdate");
  }

  app->loop(); // ~1000 us most of the time ~5000 sometimes

  if (millis() - lastDraw > 35)
  {
    lastDraw = millis();

    timeProfiler.start("btnUpdate", TimeUnit::MICROSECONDS);
    BtnBoot.Update();
    BtnPrev.Update();
    BtnSel.Update();
    BtnNext.Update();
    timeProfiler.stop("btnUpdate");

    // Only update display if screen is enabled
    if (deviceInfo.oledEnabled)
    {
      // display.display(); //  ~22000 us
    }
    else
    {
      // if (BtnBoot.clicks == -1)
      // {
      //   deviceInfo.oledEnabled = true;
      //   saveDeviceInfo();
      //   BtnBoot.clicks = 0;
      // }

      app->btnLoop();
    }
  }

  if (Serial.available() > 0)
  {
    String input = Serial.readString();
    processMenuInput(input); // idk probably fuck all
  }

  timeProfiler.stop("mainLoop"); // ~ 1300 us avg, slowest ~24000 us
}
========
==== secrets.h: ====
#pragma once 
========
